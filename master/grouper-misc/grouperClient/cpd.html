<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<!-- Generated by Apache Maven Doxia Site Renderer 1.4 at 2014-07-22 -->
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
    <title>Grouper Client - CPD Results</title>
    <style type="text/css" media="all">
      @import url("./css/maven-base.css");
      @import url("./css/maven-theme.css");
      @import url("./css/site.css");
    </style>
    <link rel="stylesheet" href="./css/print.css" type="text/css" media="print" />
    <meta name="Date-Revision-yyyymmdd" content="20140722" />
    <meta http-equiv="Content-Language" content="en" />
        
        </head>
  <body class="composite">
    <div id="banner">
                    <div id="bannerLeft">
                Grouper Client
                </div>
                    <div class="clear">
        <hr/>
      </div>
    </div>
    <div id="breadcrumbs">
            
                    
                <div class="xleft">
        <span id="publishDate">Last Published: 2014-07-22</span>
                  &nbsp;| <span id="projectVersion">Version: 2.2.0</span>
                      </div>
            <div class="xright">                    <a href="./" title="Grouper Client">Grouper Client</a>
              
                    
      </div>
      <div class="clear">
        <hr/>
      </div>
    </div>
    <div id="leftColumn">
      <div id="navcolumn">
             
                    
                                <h5>Parent Project</h5>
                  <ul>
                  <li class="none">
                          <a href="../../grouper-parent/index.html" title="Grouper">Grouper</a>
            </li>
          </ul>
                       <h5>Project Documentation</h5>
                  <ul>
                                                                                                                                                              <li class="collapsed">
                          <a href="project-info.html" title="Project Information">Project Information</a>
                  </li>
                                                                                                                                                                                                            <li class="expanded">
                          <a href="project-reports.html" title="Project Reports">Project Reports</a>
                    <ul>
                      <li class="none">
                          <a href="apidocs/index.html" title="JavaDocs">JavaDocs</a>
            </li>
                      <li class="none">
                          <a href="xref/index.html" title="Source Xref">Source Xref</a>
            </li>
                      <li class="none">
                          <a href="pmd.html" title="PMD">PMD</a>
            </li>
                      <li class="none">
            <strong>CPD</strong>
          </li>
                      <li class="none">
                          <a href="dependency-updates-report.html" title="Dependency Updates Report">Dependency Updates Report</a>
            </li>
                      <li class="none">
                          <a href="plugin-updates-report.html" title="Plugin Updates Report">Plugin Updates Report</a>
            </li>
                      <li class="none">
                          <a href="property-updates-report.html" title="Property Updates Report">Property Updates Report</a>
            </li>
                      <li class="none">
                          <a href="taglist.html" title="Tag List">Tag List</a>
            </li>
              </ul>
        </li>
          </ul>
                             <a href="http://maven.apache.org/" title="Built by Maven" class="poweredBy">
        <img class="poweredBy" alt="Built by Maven" src="./images/logos/maven-feather.png" />
      </a>
                   
                    
            </div>
    </div>
    <div id="bodyColumn">
      <div id="contentBox">
        <div class="section">
<h2>CPD Results<a name="CPD_Results"></a></h2>
<p>The following document contains the results of PMD's  <a class="externalLink" href="http://pmd.sourceforge.net/cpd.html">CPD</a> 5.0.5.</p></div>
<div class="section">
<h2>Duplications<a name="Duplications"></a></h2>
<table border="0" class="bodyTable">
<tr class="a">
<th>File</th>
<th>Line</th></tr>
<tr class="b">
<td>edu\internet2\middleware\grouperClient\config\ConfigPropertiesCascadeCommonUtils.java</td>
<td><a href="./xref/edu/internet2/middleware/grouperClient/config/ConfigPropertiesCascadeCommonUtils.html#L518">518</a></td></tr>
<tr class="a">
<td>edu\internet2\middleware\grouperClient\util\GrouperClientCommonUtils.java</td>
<td><a href="./xref/edu/internet2/middleware/grouperClient/util/GrouperClientCommonUtils.html#L581">581</a></td></tr>
<tr class="b"><td colspan='2'>
<div>
<pre>  }

  /**
   * get the extension from name.  if name is a:b:c, name is c
   * @param name
   * @return the name
   */
  public static String extensionFromName(String name) {
    if (isBlank(name)) {
      return name;
    }
    int lastColonIndex = name.lastIndexOf(':');
    if (lastColonIndex == -1) {
      return name;
    }
    String extension = name.substring(lastColonIndex+1);
    return extension;
  }
  
  /**
   * &lt;pre&gt;Returns the class object.&lt;/pre&gt;
   * @param origClassName is fully qualified
   * @return the class
   */
  public static Class forName(String origClassName) {
        
    try {
      return Class.forName(origClassName);
    } catch (Throwable t) {
      throw new RuntimeException(&quot;Problem loading class: &quot; + origClassName, t);
    }
    
  }
  
  /**
   * Construct a class
   * @param &lt;T&gt; template type
   * @param theClass
   * @return the instance
   */
  public static &lt;T&gt; T newInstance(Class&lt;T&gt; theClass) {
    try {
      return theClass.newInstance();
    } catch (Throwable e) {
      if (theClass != null &amp;&amp; Modifier.isAbstract(theClass.getModifiers())) {
        throw new RuntimeException(&quot;Problem with class: &quot; + theClass + &quot;, maybe because it is abstract!&quot;, e);        
      }
      throw new RuntimeException(&quot;Problem with class: &quot; + theClass, e);
    }
  }
  
  /**
   * Construct a class
   * @param &lt;T&gt; template type
   * @param theClass
   * @param allowPrivateConstructor true if should allow private constructors
   * @return the instance
   */
  public static &lt;T&gt; T newInstance(Class&lt;T&gt; theClass, boolean allowPrivateConstructor) {
    if (!allowPrivateConstructor) {
      return newInstance(theClass);
    }
    try {
      Constructor&lt;?&gt;[] constructorArray = theClass.getDeclaredConstructors();
      for (Constructor&lt;?&gt; constructor : constructorArray) {
         if (constructor.getGenericParameterTypes().length == 0) {
           if (allowPrivateConstructor) {
             constructor.setAccessible(true);
           }
           return (T)constructor.newInstance();
         }
      }
      //why cant we find a constructor???
      throw new RuntimeException(&quot;Why cant we find a constructor for class: &quot; + theClass);
    } catch (Throwable e) {
      if (theClass != null &amp;&amp; Modifier.isAbstract(theClass.getModifiers())) {
        throw new RuntimeException(&quot;Problem with class: &quot; + theClass + &quot;, maybe because it is abstract!&quot;, e);        
      }
      throw new RuntimeException(&quot;Problem with class: &quot; + theClass, e);
    }
  }
  
  /**
   * get the parent stem name from name.  if already a root stem
   * then just return null.  e.g. if the name is a:b:c then
   * the return value is a:b
   * @param name
   * @return the parent stem name or null if none
   */
  public static String parentStemNameFromName(String name) {
    int lastColonIndex = name.lastIndexOf(':');
    if (lastColonIndex == -1) {
      return null;
    }
    String parentStemName = name.substring(0,lastColonIndex);
    return parentStemName;

  }
  
  /**
   * return the string or the other if the first is blank
   * @param string
   * @param defaultStringIfBlank
   * @return the string or the default one
   */
  public static String defaultIfBlank(String string, String defaultStringIfBlank) {
    return isBlank(string) ? defaultStringIfBlank : string;
  }
  
  /**
   * genericized method to see if first is null, if so then return second, else first.
   * @param &lt;T&gt;
   * @param theValue first input
   * @param defaultIfTheValueIsNull second input
   * @return the first if not null, second if no
   */
  public static &lt;T&gt; T defaultIfNull(T theValue, T defaultIfTheValueIsNull) {
    return theValue != null ? theValue : defaultIfTheValueIsNull;
  }
  
  /**
   * add each element of listToAdd if it is not already in list
   * @param &lt;T&gt;
   * @param list to add to
   * @param listToAdd each element will be added to list, or null if none
   */
  public static &lt;T&gt; void addIfNotThere(Collection&lt;T&gt; list, Collection&lt;T&gt; listToAdd) {
    //maybe nothing to do
    if (listToAdd == null) {
      return;
    }
    for (T t : listToAdd) {
      if (!list.contains(t)) {
        list.add(t);
      }
    }
  }

  
  /**
   * print out various types of objects
   * 
   * @param object
   * @param maxChars is where it should stop when figuring out object.  note, result might be longer than max...
   * need to abbreviate when back
   * @param result is where to append to
   */
  @SuppressWarnings(&quot;unchecked&quot;)
  private static void toStringForLogHelper(Object object, int maxChars, StringBuilder result) {
    
    try {
      if (object == null) {
        result.append(&quot;null&quot;);
      } else if (object.getClass().isArray()) {
        // handle arrays
        int length = Array.getLength(object);
        if (length == 0) {
          result.append(&quot;Empty array&quot;);
        } else {
          result.append(&quot;Array size: &quot;).append(length).append(&quot;: &quot;);
          for (int i = 0; i &lt; length; i++) {
            result.append(&quot;[&quot;).append(i).append(&quot;]: &quot;).append(
                Array.get(object, i)).append(&quot;\n&quot;);
            if (maxChars != -1 &amp;&amp; result.length() &gt; maxChars) {
              return;
            }
          }
        }
      } else if (object instanceof Collection) {
        //give size and type if collection
        Collection&lt;Object&gt; collection = (Collection&lt;Object&gt;) object;
        int collectionSize = collection.size();
        if (collectionSize == 0) {
          result.append(&quot;Empty &quot;).append(object.getClass().getSimpleName());
        } else {
          result.append(object.getClass().getSimpleName()).append(&quot; size: &quot;).append(collectionSize).append(&quot;: &quot;);
          int i=0;
          for (Object collectionObject : collection) {
            result.append(&quot;[&quot;).append(i).append(&quot;]: &quot;).append(
                collectionObject).append(&quot;\n&quot;);
            if (maxChars != -1 &amp;&amp; result.length() &gt; maxChars) {
              return;
            }
            i++;
          }
        }
      } else {
        result.append(object.toString());
      }
    } catch (Exception e) {
      result.append(&quot;&lt;&lt;exception&gt;&gt; &quot;).append(object.getClass()).append(&quot;:\n&quot;)
        .append(getFullStackTrace(e)).append(&quot;\n&quot;);
    }
  }

  /**
   * convert a set to a string (comma separate)
   * @param set
   * @return the String
   */
  public static String setToString(Set set) {
    if (set == null) {
      return &quot;null&quot;;
    }
    if (set.size() == 0) {
      return &quot;empty&quot;;
    }
    StringBuilder result = new StringBuilder();
    boolean first = true;
    for (Object object : set) {
      if (!first) {
        result.append(&quot;, &quot;);
      }
      first = false;
      result.append(object);
    }
    return result.toString();
  }
  
  /**
   * convert a set to a string (comma separate)
   * @param map
   * @return the String
   * @deprecated use mapToString(map)
   */
  @Deprecated
  public static String MapToString(Map map) {
    return mapToString(map);
  }

  /**
   * convert a set to a string (comma separate)
   * @param map
   * @return the String
   */
  public static String mapToString(Map map) {
    if (map == null) {
      return &quot;null&quot;;
    }
    if (map.size() == 0) {
      return &quot;empty&quot;;
    }
    StringBuilder result = new StringBuilder();
    boolean first = true;
    for (Object object : map.keySet()) {
      if (!first) {
        result.append(&quot;, &quot;);
      }
      first = false;
      result.append(object).append(&quot;: &quot;).append(map.get(object));
    }
    return result.toString();
  }

  /**
   * print out various types of objects
   * 
   * @param object
   * @return the string value
   */
  public static String toStringForLog(Object object) {
    StringBuilder result = new StringBuilder();
    toStringForLogHelper(object, -1, result);
    return result.toString();
  }

  /**
   * print out various types of objects
   * 
   * @param object
   * @param maxChars is the max chars that should be returned (abbreviate if longer), or -1 for any amount
   * @return the string value
   */
  public static String toStringForLog(Object object, int maxChars) {
    StringBuilder result = new StringBuilder();
    toStringForLogHelper(object, -1, result);
    String resultString = result.toString();
    if (maxChars != -1) {
      return abbreviate(resultString, maxChars);
    }
    return resultString;
  }

  /**
   * If batching this is the number of batches
   * @param count is size of set
   * @param batchSize
   * @return the number of batches
   */
  public static int batchNumberOfBatches(int count, int batchSize) {
    int batches = 1 + ((count - 1) / batchSize);
    return batches;

  }

  /**
   * If batching this is the number of batches
   * @param collection
   * @param batchSize
   * @return the number of batches
   */
  public static int batchNumberOfBatches(Collection&lt;?&gt; collection, int batchSize) {
    int arrraySize = length(collection);
    return batchNumberOfBatches(arrraySize, batchSize);

  }

  /**
   * retrieve a batch by 0 index. Will return an array of size batchSize or
   * the remainder. the array will be full of elements. Note, this requires an
   * ordered input (so use linkedhashset not hashset if doing sets)
   * @param &lt;T&gt; template type
   * @param collection
   * @param batchSize
   * @param batchIndex
   * @return the list
   *         This never returns null, only empty list
   */
  @SuppressWarnings(&quot;unchecked&quot;)
  public static &lt;T&gt; List&lt;T&gt; batchList(Collection&lt;T&gt; collection, int batchSize,
      int batchIndex) {

    int numberOfBatches = batchNumberOfBatches(collection, batchSize);
    int arraySize = length(collection);

    // short circuit
    if (arraySize == 0) {
      return new ArrayList&lt;T&gt;();
    }

    List&lt;T&gt; theBatchObjects = new ArrayList&lt;T&gt;();

    // lets get the type of the first element if possible
//    Object first = get(arrayOrCollection, 0);
//
//    Class theType = first == null ? Object.class : first.getClass();

    // if last batch
    if (batchIndex == numberOfBatches - 1) {

      // needs to work to 1-n
      //int thisBatchSize = 1 + ((arraySize - 1) % batchSize);

      int collectionIndex = 0;
      for (T t : collection) {
        if (collectionIndex++ &lt; batchIndex * batchSize) {
          continue;
        }
        //just copy the rest
        //if (collectionIndex &gt;= (batchIndex * batchSize) + arraySize) {
        //  break;
        //}
        //we are in the copy mode
        theBatchObjects.add(t);
      }

    } else {
      // if non-last batch
      //int newIndex = 0;
      int collectionIndex = 0;
      for (T t : collection) {
        if (collectionIndex &lt; batchIndex * batchSize) {
          collectionIndex++;
          continue;
        }
        //done with batch
        if (collectionIndex &gt;= (batchIndex + 1) * batchSize) {
          break;
        }
        theBatchObjects.add(t);
        collectionIndex++;
      }
    }
    return theBatchObjects;
  }
  
  /**
   * split a string based on a separator into an array, and trim each entry (see
   * the Commons Util trim() for more details)
   * 
   * @param input
   *          is the delimited input to split and trim
   * @param separator
   *          is what to split on
   * 
   * @return the array of items after split and trimmed, or null if input is null.  will be trimmed to empty
   */
  public static String[] splitTrim(String input, String separator) {
    return splitTrim(input, separator, true);
  }

  /**
   * split a string based on a separator into an array, and trim each entry (see
   * the Commons Util trim() for more details)
   * 
   * @param input
   *          is the delimited input to split and trim
   * @param separator
   *          is what to split on
   * 
   * @return the list of items after split and trimmed, or null if input is null.  will be trimmed to empty
   */
  public static List&lt;String&gt; splitTrimToList(String input, String separator) {
    if (isBlank(input)) {
      return null;
    }
    String[] array =  splitTrim(input, separator);
    return toList(array);
  }

  /**
   * split a string based on a separator into an array, and trim each entry (see
   * the Commons Util trim() for more details)
   * 
   * @param input
   *          is the delimited input to split and trim
   * @param separator
   *          is what to split on
   * @param treatAdjacentSeparatorsAsOne
   * @return the array of items after split and trimmed, or null if input is null.  will be trimmed to empty
   */
  public static String[] splitTrim(String input, String separator, boolean treatAdjacentSeparatorsAsOne) {
    if (isBlank(input)) {
      return null;
    }

    //first split
    String[] items = treatAdjacentSeparatorsAsOne ? split(input, separator) : 
      splitPreserveAllTokens(input, separator);

    //then trim
    for (int i = 0; (items != null) &amp;&amp; (i &lt; items.length); i++) {
      items[i] = trim(items[i]);
    }

    //return the array
    return items;
  }

  /**
   * escape url chars (e.g. a # is %23)
   * @param string input
   * @return the encoded string
   */
  public static String escapeUrlEncode(String string) {
    String result = null;
    try {
      result = URLEncoder.encode(string, &quot;UTF-8&quot;);
    } catch (UnsupportedEncodingException ex) {
      throw new RuntimeException(&quot;UTF-8 not supported&quot;, ex);
    }
    return result;
  }
  
  /**
   * unescape url chars (e.g. a space is %20)
   * @param string input
   * @return the encoded string
   */
  public static String escapeUrlDecode(String string) {
    String result = null;
    try {
      result = URLDecoder.decode(string, &quot;UTF-8&quot;);
    } catch (UnsupportedEncodingException ex) {
      throw new RuntimeException(&quot;UTF-8 not supported&quot;, ex);
    }
    return result;
  }

  /**
   * make sure a list is non null.  If null, then return an empty list
   * @param &lt;T&gt;
   * @param list
   * @return the list or empty list if null
   */
  public static &lt;T&gt; List&lt;T&gt; nonNull(List&lt;T&gt; list) {
    return list == null ? new ArrayList&lt;T&gt;() : list;
  }
  
  /**
   * make sure a list is non null.  If null, then return an empty set
   * @param &lt;T&gt;
   * @param set
   * @return the set or empty set if null
   */
  public static &lt;T&gt; Set&lt;T&gt; nonNull(Set&lt;T&gt; set) {
    return set == null ? new HashSet&lt;T&gt;() : set;
  }
  
  /**
   * make sure it is non null, if null, then give new map
   * 
   * @param &lt;K&gt; key of map
   * @param &lt;V&gt; value of map
   * @param map is map
   * @return set non null
   */
  public static &lt;K,V&gt; Map&lt;K,V&gt; nonNull(Map&lt;K,V&gt; map) {
    return map == null ? new HashMap&lt;K,V&gt;() : map;
  }

  /**
   * return a list of objects from varargs.  Though if there is one
   * object, and it is a list, return it.
   * 
   * @param &lt;T&gt;
   *            template type of the objects
   * @param objects
   * @return the list or null if objects is null
   */
  @SuppressWarnings(&quot;unchecked&quot;)
  public static &lt;T&gt; List&lt;T&gt; toList(T... objects) {
    if (objects == null) {
      return null;
    }
    if (objects.length == 1 &amp;&amp; objects[0] instanceof List) {
      return (List&lt;T&gt;)objects[0];
    }
    
    List&lt;T&gt; result = new ArrayList&lt;T&gt;();
    for (T object : objects) {
      result.add(object);
    }
    return result;
  }

  /**
   * convert classes to a list
   * @param classes
   * @return list of classes
   */
  public static List&lt;Class&lt;?&gt;&gt; toListClasses(Class&lt;?&gt;... classes) {
    return toList(classes);
  }
  

  
  /**
   * return a set of objects from varargs.
   * 
   * @param &lt;T&gt; template type of the objects
   * @param objects
   * @return the set
   */
  public static &lt;T&gt; Set&lt;T&gt; toSet(T... objects) {

    Set&lt;T&gt; result = new LinkedHashSet&lt;T&gt;();
    for (T object : objects) {
      result.add(object);
    }
    return result;
  }

  /**
   * cache separator
   */
  private static final String CACHE_SEPARATOR = &quot;__&quot;;

  /**
   * string format of dates
   */
  public static final String DATE_FORMAT = &quot;yyyyMMdd&quot;;

  /**
   * format including minutes and seconds: yyyy/MM/dd HH:mm:ss
   */
  public static final String DATE_MINUTES_SECONDS_FORMAT = &quot;yyyy/MM/dd HH:mm:ss&quot;;

  /**
   * format including minutes and seconds: yyyyMMdd HH:mm:ss
   */
  public static final String DATE_MINUTES_SECONDS_NO_SLASH_FORMAT = &quot;yyyyMMdd HH:mm:ss&quot;;

  /**
   * format on screen of config for milestone: yyyy/MM/dd HH:mm:ss.SSS
   */
  public static final String TIMESTAMP_FORMAT = &quot;yyyy/MM/dd HH:mm:ss.SSS&quot;;

  /**
   * format on screen of config for milestone: yyyyMMdd HH:mm:ss.SSS
   */
  public static final String TIMESTAMP_NO_SLASH_FORMAT = &quot;yyyyMMdd HH:mm:ss.SSS&quot;;

  /**
   * date format, make sure to synchronize
   */
  final static SimpleDateFormat dateFormat = new SimpleDateFormat(DATE_FORMAT);

  /**
   * synchronize code that uses this standard formatter for dates with minutes and seconds
   */
  final static SimpleDateFormat dateMinutesSecondsFormat = new SimpleDateFormat(
      DATE_MINUTES_SECONDS_FORMAT);

  /**
   * synchronize code that uses this standard formatter for dates with minutes and seconds
   */
  final static SimpleDateFormat dateMinutesSecondsNoSlashFormat = new SimpleDateFormat(
      DATE_MINUTES_SECONDS_NO_SLASH_FORMAT);

  /**
   * &lt;pre&gt; format: yyyy/MM/dd HH:mm:ss.SSS synchronize code that uses this standard formatter for timestamps &lt;/pre&gt;
   */
  final static SimpleDateFormat timestampFormat = new SimpleDateFormat(TIMESTAMP_FORMAT);

  /**
   * synchronize code that uses this standard formatter for timestamps
   */
  final static SimpleDateFormat timestampNoSlashFormat = new SimpleDateFormat(
      TIMESTAMP_NO_SLASH_FORMAT);

  /**
   * If false, throw an assertException, and give a reason
   * 
   * @param isTrue
   * @param reason
   */
  public static void assertion(boolean isTrue, String reason) {
    if (!isTrue) {
      throw new RuntimeException(reason);
    }

  }

  /**
   * use the field cache, expire every day (just to be sure no leaks)
   */
  private static ExpirableCache&lt;String, Set&lt;Field&gt;&gt; fieldSetCache = null;
  
  /**
   * lazy load
   * @return field set cache
   */
  private static ExpirableCache&lt;String, Set&lt;Field&gt;&gt; fieldSetCache() {
    if (fieldSetCache == null) {
      fieldSetCache = new ExpirableCache&lt;String, Set&lt;Field&gt;&gt;(60*24);
    }
    return fieldSetCache;
  }
    

  /**
   * make a cache with max size to cache declared methods
   */
  private static ExpirableCache&lt;Class, Method[]&gt; declaredMethodsCache = null;
  
  /**
   * lazy load
   * @return declared method cache
   */
  private static ExpirableCache&lt;Class, Method[]&gt; declaredMethodsCache() {
    if (declaredMethodsCache == null) {
      declaredMethodsCache = new ExpirableCache&lt;Class, Method[]&gt;(60*24);
    }
    return declaredMethodsCache;
  }
  
    

  /**
   * use the field cache, expire every day (just to be sure no leaks) 
   */
  private static ExpirableCache&lt;String, Set&lt;Method&gt;&gt; getterSetCache = null;
    

  /**
   * lazy load
   * @return getter cache
   */
  private static ExpirableCache&lt;String, Set&lt;Method&gt;&gt; getterSetCache() {
    if (getterSetCache == null) {
      getterSetCache = new ExpirableCache&lt;String, Set&lt;Method&gt;&gt;(60*24);
    }
    return getterSetCache;
  }
  
    

  /**
   * use the field cache, expire every day (just to be sure no leaks) 
   */
  private static ExpirableCache&lt;String, Set&lt;Method&gt;&gt; setterSetCache = null;
    

  /**
   * lazy load
   * @return setter cache
   */
  private static ExpirableCache&lt;String, Set&lt;Method&gt;&gt; setterSetCache() {
    if (setterSetCache == null) {
      setterSetCache = new ExpirableCache&lt;String, Set&lt;Method&gt;&gt;(60*24);
    }
    return setterSetCache;
  }
  
  
  /**
   * Field lastId.
   */
  private static char[] lastId = convertLongToStringSmall(new Date().getTime())
      .toCharArray();

  /**
   * cache the properties read from resource 
   */
  private static Map&lt;String, Properties&gt; resourcePropertiesCache = new HashMap&lt;String, Properties&gt;();

  /**
   * assign data to a field
   * 
   * @param theClass
   *            the class which has the method
   * @param invokeOn
   *            to call on or null for static
   * @param fieldName
   *            method name to call
   * @param dataToAssign
   *            data
   * @param callOnSupers
   *            if static and method not exists, try on supers
   * @param overrideSecurity
   *            true to call on protected or private etc methods
   * @param typeCast
   *            true if we should typecast
   * @param annotationWithValueOverride
   *            annotation with value of override
   */
  public static void assignField(Class theClass, Object invokeOn,
      String fieldName, Object dataToAssign, boolean callOnSupers,
      boolean overrideSecurity, boolean typeCast,
      Class&lt;? extends Annotation&gt; annotationWithValueOverride) {
    if (theClass == null &amp;&amp; invokeOn != null) {
      theClass = invokeOn.getClass();
    }
    Field field = field(theClass, fieldName, callOnSupers, true);
    assignField(field, invokeOn, dataToAssign, overrideSecurity, typeCast,
        annotationWithValueOverride);
  }

  /**
   * assign data to a field. Will find the field in superclasses, will
   * typecast, and will override security (private, protected, etc)
   * 
   * @param theClass
   *            the class which has the method
   * @param invokeOn
   *            to call on or null for static
   * @param fieldName
   *            method name to call
   * @param dataToAssign
   *            data
   * @param annotationWithValueOverride
   *            annotation with value of override
   */
  public static void assignField(Class theClass, Object invokeOn,
      String fieldName, Object dataToAssign,
      Class&lt;? extends Annotation&gt; annotationWithValueOverride) {
    assignField(theClass, invokeOn, fieldName, dataToAssign, true, true,
        true, annotationWithValueOverride);
  }

  /**
   * assign data to a field
   * 
   * @param field
   *            is the field to assign to
   * @param invokeOn
   *            to call on or null for static
   * @param dataToAssign
   *            data
   * @param overrideSecurity
   *            true to call on protected or private etc methods
   * @param typeCast
   *            true if we should typecast
   */
  @SuppressWarnings(&quot;unchecked&quot;)
  public static void assignField(Field field, Object invokeOn,
      Object dataToAssign, boolean overrideSecurity, boolean typeCast) {

    try {
      Class fieldType = field.getType();
      // typecast
      if (typeCast) {
        dataToAssign = 
                 typeCast(dataToAssign, fieldType,
                 true, true);
      }
      if (overrideSecurity) {
        field.setAccessible(true);
      }
      field.set(invokeOn, dataToAssign);
    } catch (Exception e) {
      throw new RuntimeException(&quot;Cant assign reflection field: &quot;
          + (field == null ? null : field.getName()) + &quot;, on: &quot;
          + className(invokeOn) + &quot;, with args: &quot;
          + classNameCollection(dataToAssign), e);
    }
  }

  /**
   * null safe iterator getter if the type if collection
   * 
   * @param collection
   * @return the iterator
   */
  public static Iterator iterator(Object collection) {
    if (collection == null) {
      return null;
    }
    // array list doesnt need an iterator
    if (collection instanceof Collection
        &amp;&amp; !(collection instanceof ArrayList)) {
      return ((Collection) collection).iterator();
    }
    return null;
  }

  /**
   * Null safe array length or map
   * 
   * @param arrayOrCollection
   * @return the length of the array (0 for null)
   */
  public static int length(Object arrayOrCollection) {
    if (arrayOrCollection == null) {
      return 0;
    }
    if (arrayOrCollection.getClass().isArray()) {
      return Array.getLength(arrayOrCollection);
    }
    if (arrayOrCollection instanceof Collection) {
      return ((Collection) arrayOrCollection).size();
    }
    if (arrayOrCollection instanceof Map) {
      return ((Map) arrayOrCollection).size();
    }
    // simple non array non collection object
    return 1;
  }

  /**
   * If array, get the element based on index, if Collection, get it based on
   * iterator.
   * 
   * @param arrayOrCollection
   * @param iterator
   * @param index
   * @return the object
   */
  public static Object next(Object arrayOrCollection, Iterator iterator,
      int index) {
    if (arrayOrCollection.getClass().isArray()) {
      return Array.get(arrayOrCollection, index);
    }
    if (arrayOrCollection instanceof ArrayList) {
      return ((ArrayList) arrayOrCollection).get(index);
    }
    if (arrayOrCollection instanceof Collection) {
      return iterator.next();
    }
    // simple object
    if (0 == index) {
      return arrayOrCollection;
    }
    throw new RuntimeException(&quot;Invalid class type: &quot;
        + arrayOrCollection.getClass().getName());
  }

  /**
   * Remove the iterator or index
   * 
   * @param arrayOrCollection
   * @param index
   * @return the object list or new array
   */
  public static Object remove(Object arrayOrCollection, 
      int index) {
    return remove(arrayOrCollection, null, index);
  }
  
  /**
   * Remove the iterator or index
   * 
   * @param arrayOrCollection
   * @param iterator
   * @param index
   * @return the object list or new array
   */
  public static Object remove(Object arrayOrCollection, Iterator iterator,
      int index) {
    
    //if theres an iterator, just use that
    if (iterator != null) {
      iterator.remove();
      return arrayOrCollection;
    }
    if (arrayOrCollection.getClass().isArray()) {
      int newLength = Array.getLength(arrayOrCollection) - 1;
      Object newArray = Array.newInstance(arrayOrCollection.getClass().getComponentType(), newLength);
      if (newLength == 0) {
        return newArray;
      }
      if (index &gt; 0) {
        System.arraycopy(arrayOrCollection, 0, newArray, 0, index);
      }
      if (index &lt; newLength) {
        System.arraycopy(arrayOrCollection, index+1, newArray, index, newLength - index);
      }
      return newArray;
    }
    if (arrayOrCollection instanceof List) {
      ((List)arrayOrCollection).remove(index);
      return arrayOrCollection;
    } else if (arrayOrCollection instanceof Collection) {
      //this should work unless there are duplicates or something weird
      ((Collection)arrayOrCollection).remove(get(arrayOrCollection, index));
      return arrayOrCollection;
    }
    throw new RuntimeException(&quot;Invalid class type: &quot;
        + arrayOrCollection.getClass().getName());
  }

  /**
   * print the simple names of a list of classes
   * @param object
   * @return the simple names
   */
  public static String classesString(Object object) {
    StringBuilder result = new StringBuilder();
    if (object.getClass().isArray()) {
      int length = Array.getLength(object);
      for (int i=0;i&lt;length;i++) {
        result.append(((Class)object).getSimpleName());
        if (i &lt; length-1) {
          result.append(&quot;, &quot;);
        }
      }
      return result.toString();
    }
    
    throw new RuntimeException(&quot;Not implemented: &quot; + className(object));
  }
  
  /**
   * null safe classname method, max out at 20
   * 
   * @param object
   * @return the classname
   */
  public static String classNameCollection(Object object) {
    if (object == null) {
      return null;
    }
    StringBuffer result = new StringBuffer();
    
    Iterator iterator = iterator(object);
    int length = length(object);
    for (int i = 0; i &lt; length &amp;&amp; i &lt; 20; i++) {
      result.append(className(next(object, iterator, i)));
      if (i != length - 1) {
        result.append(&quot;, &quot;);
      }
    }
    return result.toString();
  }

  /**
   * null safe classname method, gets the unenhanced name
   * 
   * @param object
   * @return the classname
   */
  public static String className(Object object) {
    return object == null ? null : object.getClass().getName();
  }

  /**
   * assign data to a field
   * 
   * @param field
   *            is the field to assign to
   * @param invokeOn
   *            to call on or null for static
   * @param dataToAssign
   *            data
   * @param overrideSecurity
   *            true to call on protected or private etc methods
   * @param typeCast
   *            true if we should typecast
   * @param annotationWithValueOverride
   *            annotation with value of override, or null if none
   */
  @SuppressWarnings(&quot;unchecked&quot;)
  public static void assignField(Field field, Object invokeOn,
      Object dataToAssign, boolean overrideSecurity, boolean typeCast,
      Class&lt;? extends Annotation&gt; annotationWithValueOverride) {

    if (annotationWithValueOverride != null) {
      // see if in annotation
      Annotation annotation = field
          .getAnnotation(annotationWithValueOverride);
      if (annotation != null) {
        
         // type of the value, or String if not specific Class
          // typeOfAnnotationValue = typeCast ? field.getType() :
          // String.class; dataToAssign =
          // AnnotationUtils.retrieveAnnotationValue(
          // typeOfAnnotationValue, annotation, &quot;value&quot;);
        
        throw new RuntimeException(&quot;Not supported&quot;);
      }
    }
    assignField(field, invokeOn, dataToAssign, overrideSecurity, typeCast);
  }

  /**
   * assign data to a field. Will find the field in superclasses, will
   * typecast, and will override security (private, protected, etc)
   * 
   * @param invokeOn
   *            to call on or null for static
   * @param fieldName
   *            method name to call
   * @param dataToAssign
   *            data
   */
  public static void assignField(Object invokeOn, String fieldName,
      Object dataToAssign) {
    assignField(null, invokeOn, fieldName, dataToAssign, true, true, true,
        null);
  }

  /**
   * get a field object for a class, potentially in superclasses
   * 
   * @param theClass
   * @param fieldName
   * @param callOnSupers
   *            true if superclasses should be looked in for the field
   * @param throwExceptionIfNotFound
   *            will throw runtime exception if not found
   * @return the field object or null if not found (or exception if param is
   *         set)
   */
  public static Field field(Class theClass, String fieldName,
      boolean callOnSupers, boolean throwExceptionIfNotFound) {
    try {
      Field field = theClass.getDeclaredField(fieldName);
      // found it
      return field;
    } catch (NoSuchFieldException e) {
      // if method not found
      // if traversing up, and not Object, and not instance method
      if (callOnSupers &amp;&amp; !theClass.equals(Object.class)) {
        return field(theClass.getSuperclass(), fieldName, callOnSupers,
            throwExceptionIfNotFound);
      }
    }
    // maybe throw an exception
    if (throwExceptionIfNotFound) {
      throw new RuntimeException(&quot;Cant find field: &quot; + fieldName
          + &quot;, in: &quot; + theClass + &quot;, callOnSupers: &quot; + callOnSupers);
    }
    return null;
  }

  /**
   * return a set of Strings for a class and type. This is not for any
   * supertypes, only for the type at hand. includes final fields
   * 
   * @param theClass
   * @param fieldType
   *            or null for all
   * @param includeStaticFields
   * @return the set of strings, or the empty Set if none
   */
  @SuppressWarnings(&quot;unchecked&quot;)
  public static Set&lt;String&gt; fieldNames(Class theClass, Class fieldType,
      boolean includeStaticFields) {
    return fieldNamesHelper(theClass, theClass, fieldType, true, true,
        includeStaticFields, null, true);
  }

  /**
   * get all field names from a class, including superclasses (if specified)
   * 
   * @param theClass
   *            to look for fields in
   * @param superclassToStopAt
   *            to go up to or null to go up to Object
   * @param fieldType
   *            is the type of the field to get
   * @param includeSuperclassToStopAt
   *            if we should include the superclass
   * @param includeStaticFields
   *            if include static fields
   * @param includeFinalFields
   *            if final fields should be included
   * @return the set of field names or empty set if none
   */
  public static Set&lt;String&gt; fieldNames(Class theClass,
      Class superclassToStopAt, Class&lt;?&gt; fieldType,
      boolean includeSuperclassToStopAt, boolean includeStaticFields,
      boolean includeFinalFields) {
    return fieldNamesHelper(theClass, superclassToStopAt, fieldType,
        includeSuperclassToStopAt, includeStaticFields,
        includeFinalFields, null, true);

  }

  /**
   * get all field names from a class, including superclasses (if specified).
   * ignore a certain marker annotation
   * 
   * @param theClass
   *            to look for fields in
   * @param superclassToStopAt
   *            to go up to or null to go up to Object
   * @param fieldType
   *            is the type of the field to get
   * @param includeSuperclassToStopAt
   *            if we should include the superclass
   * @param includeStaticFields
   *            if include static fields
   * @param includeFinalFields
   *            if final fields should be included
   * @param markerAnnotationToIngore
   *            if this is not null, then if the field has this annotation,
   *            then do not include in list
   * @return the set of field names
   */
  public static Set&lt;String&gt; fieldNames(Class theClass,
      Class superclassToStopAt, Class&lt;?&gt; fieldType,
      boolean includeSuperclassToStopAt, boolean includeStaticFields,
      boolean includeFinalFields,
      Class&lt;? extends Annotation&gt; markerAnnotationToIngore) {
    return fieldNamesHelper(theClass, superclassToStopAt, fieldType,
        includeSuperclassToStopAt, includeStaticFields,
        includeFinalFields, markerAnnotationToIngore, false);

  }

  /**
   * get all field names from a class, including superclasses (if specified)
   * (up to and including the specified superclass). ignore a certain marker
   * annotation. Dont get static or final field, and get fields of all types
   * 
   * @param theClass
   *            to look for fields in
   * @param superclassToStopAt
   *            to go up to or null to go up to Object
   * @param markerAnnotationToIngore
   *            if this is not null, then if the field has this annotation,
   *            then do not include in list
   * @return the set of field names or empty set if none
   */
  public static Set&lt;String&gt; fieldNames(Class theClass,
      Class superclassToStopAt,
      Class&lt;? extends Annotation&gt; markerAnnotationToIngore) {
    return fieldNamesHelper(theClass, superclassToStopAt, null, true,
        false, false, markerAnnotationToIngore, false);
  }

  /**
   * get all field names from a class, including superclasses (if specified)
   * 
   * @param theClass
   *            to look for fields in
   * @param superclassToStopAt
   *            to go up to or null to go up to Object
   * @param fieldType
   *            is the type of the field to get
   * @param includeSuperclassToStopAt
   *            if we should include the superclass
   * @param includeStaticFields
   *            if include static fields
   * @param includeFinalFields
   *            true to include finals
   * @param markerAnnotation
   *            if this is not null, then if the field has this annotation,
   *            then do not include in list (if includeAnnotation is false)
   * @param includeAnnotation
   *            true if the attribute should be included if annotation is
   *            present, false if exclude
   * @return the set of field names or empty set if none
   */
  @SuppressWarnings(&quot;unchecked&quot;)
  static Set&lt;String&gt; fieldNamesHelper(Class theClass,
      Class superclassToStopAt, Class&lt;?&gt; fieldType,
      boolean includeSuperclassToStopAt, boolean includeStaticFields,
      boolean includeFinalFields,
      Class&lt;? extends Annotation&gt; markerAnnotation,
      boolean includeAnnotation) {
    Set&lt;Field&gt; fieldSet = fieldsHelper(theClass, superclassToStopAt,
        fieldType, includeSuperclassToStopAt, includeStaticFields,
        includeFinalFields, markerAnnotation, includeAnnotation);
    Set&lt;String&gt; fieldNameSet = new LinkedHashSet&lt;String&gt;();
    for (Field field : fieldSet) {
      fieldNameSet.add(field.getName());
    }
    return fieldNameSet;

  }

  /**
   * get all fields from a class, including superclasses (if specified)
   * 
   * @param theClass
   *            to look for fields in
   * @param superclassToStopAt
   *            to go up to or null to go up to Object
   * @param fieldType
   *            is the type of the field to get
   * @param includeSuperclassToStopAt
   *            if we should include the superclass
   * @param includeStaticFields
   *            if include static fields
   * @param includeFinalFields
   *            if final fields should be included
   * @param markerAnnotation
   *            if this is not null, then if the field has this annotation,
   *            then do not include in list (if includeAnnotation is false)
   * @param includeAnnotation
   *            true if the attribute should be included if annotation is
   *            present, false if exclude
   * @return the set of fields (wont return null)
   */
  @SuppressWarnings(&quot;unchecked&quot;)
  public static Set&lt;Field&gt; fields(Class theClass, Class superclassToStopAt,
      Class fieldType, boolean includeSuperclassToStopAt,
      boolean includeStaticFields, boolean includeFinalFields,
      Class&lt;? extends Annotation&gt; markerAnnotation,
      boolean includeAnnotation) {
    return fieldsHelper(theClass, superclassToStopAt, fieldType,
        includeSuperclassToStopAt, includeStaticFields,
        includeFinalFields, markerAnnotation, includeAnnotation);
  }

  /**
   * get all fields from a class, including superclasses (if specified) (up to
   * and including the specified superclass). ignore a certain marker
   * annotation, or only include it. Dont get static or final field, and get
   * fields of all types
   * 
   * @param theClass
   *            to look for fields in
   * @param superclassToStopAt
   *            to go up to or null to go up to Object
   * @param markerAnnotation
   *            if this is not null, then if the field has this annotation,
   *            then do not include in list (if includeAnnotation is false)
   * @param includeAnnotation
   *            true if the attribute should be included if annotation is
   *            present, false if exclude
   * @return the set of field names or empty set if none
   */
  @SuppressWarnings(&quot;unchecked&quot;)
  public static Set&lt;Field&gt; fields(Class theClass, Class superclassToStopAt,
      Class&lt;? extends Annotation&gt; markerAnnotation,
      boolean includeAnnotation) {
    return fieldsHelper(theClass, superclassToStopAt, null, true, false,
        false, markerAnnotation, includeAnnotation);
  }

  /**
   * get all fields from a class, including superclasses (if specified)
   * 
   * @param theClass
   *            to look for fields in
   * @param superclassToStopAt
   *            to go up to or null to go up to Object
   * @param fieldType
   *            is the type of the field to get
   * @param includeSuperclassToStopAt
   *            if we should include the superclass
   * @param includeStaticFields
   *            if include static fields
   * @param includeFinalFields
   *            if final fields should be included
   * @param markerAnnotation
   *            if this is not null, then if the field has this annotation,
   *            then do not include in list (if includeAnnotation is false)
   * @param includeAnnotation
   *            true if the attribute should be included if annotation is
   *            present, false if exclude
   * @return the set of fields (wont return null)
   */
  @SuppressWarnings(&quot;unchecked&quot;)
  static Set&lt;Field&gt; fieldsHelper(Class theClass, Class superclassToStopAt,
      Class&lt;?&gt; fieldType, boolean includeSuperclassToStopAt,
      boolean includeStaticFields, boolean includeFinalFields,
      Class&lt;? extends Annotation&gt; markerAnnotation,
      boolean includeAnnotation) {
    // MAKE SURE IF ANY MORE PARAMS ARE ADDED, THE CACHE KEY IS CHANGED!

    Set&lt;Field&gt; fieldNameSet = null;
    String cacheKey = theClass + CACHE_SEPARATOR + superclassToStopAt
        + CACHE_SEPARATOR + fieldType + CACHE_SEPARATOR
        + includeSuperclassToStopAt + CACHE_SEPARATOR
        + includeStaticFields + CACHE_SEPARATOR + includeFinalFields
        + CACHE_SEPARATOR + markerAnnotation + CACHE_SEPARATOR
        + includeAnnotation;
    fieldNameSet = fieldSetCache().get(cacheKey);
    if (fieldNameSet != null) {
      return fieldNameSet;
    }

    fieldNameSet = new LinkedHashSet&lt;Field&gt;();
    fieldsHelper(theClass, superclassToStopAt, fieldType,
        includeSuperclassToStopAt, includeStaticFields,
        includeFinalFields, markerAnnotation, fieldNameSet,
        includeAnnotation);

    // add to cache
    fieldSetCache().put(cacheKey, fieldNameSet);

    return fieldNameSet;

  }

  /**
   * compare two objects, compare primitives, Strings, maps of string attributes.
   * if both objects equal each others references, then return empty set.
   * then, if not, then if either is null, return all fields
   * @param first
   * @param second
   * @param fieldsToCompare
   * @param mapPrefix is the prefix for maps which are compared (e.g. attribute__)
   * @return the set of fields which are different.  never returns null
   */
  @SuppressWarnings(&quot;unchecked&quot;)
  public static Set&lt;String&gt; compareObjectFields(Object first, Object second, 
      Set&lt;String&gt; fieldsToCompare, String mapPrefix) {
    
    Set&lt;String&gt; differentFields = new LinkedHashSet&lt;String&gt;();
    
    if (first == second) {
      return differentFields;
    }
    
    //if either null, then all fields are different
    if (first == null || second == null) {
      differentFields.addAll(fieldsToCompare);
    }

    for (String fieldName : fieldsToCompare) {
      try {
        Object firstValue = fieldValue(first, fieldName);
        Object secondValue = fieldValue(second, fieldName);
        
        if (firstValue == secondValue) {
          continue;
        }
        if (firstValue instanceof Map || secondValue instanceof Map) {
          mapDifferences((Map)firstValue, (Map)secondValue, differentFields, mapPrefix);
          continue;
        }
        //compare things...
        //for strings, null is equal to empty
        if (firstValue instanceof String || secondValue instanceof String) {
          if (!equals(defaultString((String)firstValue),
              defaultString((String)secondValue))) {
            differentFields.add(fieldName);
          }
          continue;
        }
        //if one is null, that is not good
        if (firstValue == null || secondValue == null) {
          differentFields.add(fieldName);
          continue;
        }
        //everything (numbers, dates, etc) should work with equals method...
        if (!firstValue.equals(secondValue)) {
          differentFields.add(fieldName);
          continue;
        }
        
      } catch (RuntimeException re) {
        throw new RuntimeException(&quot;Problem comparing field &quot; + fieldName 
            + &quot; on objects: &quot; + className(first) + &quot;, &quot; + className(second));
      }
      
      
    }
    return differentFields;
  }
  
  /**
   * clone an object, assign primitives, Strings, maps of string attributes.  Clone GrouperCloneable fields.
   * @param &lt;T&gt; template
   * @param object
   * @param fieldsToClone
   * @return the cloned object or null if input is null
   */
  @SuppressWarnings(&quot;unchecked&quot;)
  public static &lt;T&gt; T clone(T object, Set&lt;String&gt; fieldsToClone) {
    
    //make a return object
    T result = (T)newInstance(object.getClass());
    
    cloneFields(object, result, fieldsToClone);
    
    return result;
  }
  
  /**
   * clone an object, assign primitives, Strings, maps of string attributes.  Clone GrouperCloneable fields.
   * @param &lt;T&gt; template
   * @param object
   * @param result 
   * @param fieldsToClone
   */
  public static &lt;T&gt; void cloneFields(T object, T result,
      Set&lt;String&gt; fieldsToClone) {
    
    if (object == result) {
      return;
    }
    
    //if either null, then all fields are different
    if (object == null || result == null) {
      throw new RuntimeException(&quot;Cant copy from or to null: &quot; + className(object) + &quot;, &quot; + className(result));
    }
    
    Class&lt;?&gt; fieldValueClass = null;
    
    for (String fieldName : nonNull(fieldsToClone)) {
      try {
        
        Object fieldValue = fieldValue(object, fieldName);
        fieldValueClass = fieldValue == null ? null : fieldValue.getClass();
        
        Object fieldValueToAssign = cloneValue(fieldValue);
        
        //assign the field to the clone
        assignField(result, fieldName, fieldValueToAssign);
        
      } catch (RuntimeException re) {
        throw new RuntimeException(&quot;Problem cloning field: &quot; + object.getClass() 
              + &quot;, &quot; + fieldName + &quot;, &quot; + fieldValueClass, re);
      }
    }
  }
  
  /**
   * helper method to clone the value of a field.  just returns the same
   * reference for primitives and immutables.  Will subclone GrouperCloneables, 
   * and will throw exception if not expecting the type.  Will clone sets, lists, maps.
   * @param &lt;T&gt; template
   * 
   * @param value
   * @return the cloned value
   */
  @SuppressWarnings(&quot;unchecked&quot;)
  public static &lt;T&gt; T cloneValue(T value) {

    Object clonedValue = value;
    
    if (value == null || value instanceof String 
        || value.getClass().isPrimitive() || value instanceof Number
        || value instanceof Boolean
        || value instanceof Date) {
      //clone things
      //for strings, and immutable classes, just assign
      //nothing to do, just assign the value
    } else if (value instanceof Map) {
      clonedValue = new LinkedHashMap();
      Map mapValue = (Map)value;
      Map clonedMapValue = (Map)clonedValue;
      for (Object key : mapValue.keySet()) {
        clonedMapValue.put(cloneValue(key), cloneValue(mapValue.get(key)));
      }
    } else if (value instanceof Set) {
        clonedValue = new LinkedHashSet();
        Set setValue = (Set)value;
        Set clonedSetValue = (Set)clonedValue;
        for (Object each : setValue) {
          clonedSetValue.add(cloneValue(each));
        }
    } else if (value instanceof List) {
      clonedValue = new ArrayList();
      List listValue = (List)value;
      List clonedListValue = (List)clonedValue;
      for (Object each : listValue) {
        clonedListValue.add(cloneValue(each));
      }
    } else if (value.getClass().isArray()) {
      clonedValue = Array.newInstance(value.getClass().getComponentType(), Array.getLength(value));
      for (int i=0;i&lt;Array.getLength(value);i++) {
        Array.set(clonedValue, i, cloneValue(Array.get(value, i)));
      }
      
      
    } else {

      //this means lets add support for a new type of object
      throw new RuntimeException(&quot;Unexpected class in clone method: &quot; + value.getClass());
    
    }
    return (T)clonedValue;
  }
  
  /**
   * simple method to get method names
   * @param theClass
   * @param superclassToStopAt 
   * @param includeSuperclassToStopAt 
   * @param includeStaticMethods 
   * @return the set of method names
   */
  public static Set&lt;String&gt; methodNames(Class&lt;?&gt; theClass, Class&lt;?&gt; superclassToStopAt, 
      boolean includeSuperclassToStopAt, boolean includeStaticMethods) {

    Set&lt;Method&gt; methods = new LinkedHashSet&lt;Method&gt;();
    methodsHelper(theClass, superclassToStopAt, includeSuperclassToStopAt, includeStaticMethods, 
        null, false, methods);
    Set&lt;String&gt; methodNames = new HashSet&lt;String&gt;();
    for (Method method : methods) {
      methodNames.add(method.getName());
    }
    return methodNames;
  }

  /**
   * get the set of methods
   * @param theClass
   * @param superclassToStopAt 
   * @param includeSuperclassToStopAt 
   * @param includeStaticMethods
   * @param markerAnnotation 
   * @param includeAnnotation 
   * @param methodSet
   */
  public static void methodsHelper(Class&lt;?&gt; theClass, Class&lt;?&gt; superclassToStopAt, 
      boolean includeSuperclassToStopAt,
      boolean includeStaticMethods, Class&lt;? extends Annotation&gt; markerAnnotation, 
      boolean includeAnnotation, Set&lt;Method&gt; methodSet) {
    Method[] methods = theClass.getDeclaredMethods();
    if (length(methods) != 0) {
      for (Method method : methods) {
        // if not static, then continue
        if (!includeStaticMethods
            &amp;&amp; Modifier.isStatic(method.getModifiers())) {
          continue;
        }
        // if checking for annotation
        if (markerAnnotation != null
            &amp;&amp; (includeAnnotation != method
                .isAnnotationPresent(markerAnnotation))) {
          continue;
        }
        // go for it
        methodSet.add(method);
      }
    }
    // see if done recursing (if superclassToStopAt is null, then stop at
    // Object
    if (theClass.equals(superclassToStopAt)
        || theClass.equals(Object.class)) {
      return;
    }
    Class superclass = theClass.getSuperclass();
    if (!includeSuperclassToStopAt &amp;&amp; superclass.equals(superclassToStopAt)) {
      return;
    }
    // recurse
    methodsHelper(superclass, superclassToStopAt,
        includeSuperclassToStopAt, includeStaticMethods,
        markerAnnotation, includeAnnotation, methodSet);
    
  }
  
  /**
   * get the set of methods
   * @param theClass
   * @param methodName 
   * @param paramTypesOrArrayOrList
   *            types of the params
   * @param superclassToStopAt 
   * @param includeSuperclassToStopAt 
   * @param isStaticOrInstance true if static
   * @param markerAnnotation 
   * @param includeAnnotation 
   * @return the method or null if not found
   *            
   */
  public static Method method(Class&lt;?&gt; theClass, 
      String methodName, Object paramTypesOrArrayOrList,
      Class&lt;?&gt; superclassToStopAt, 
      boolean includeSuperclassToStopAt,
      boolean isStaticOrInstance, Class&lt;? extends Annotation&gt; markerAnnotation, 
      boolean includeAnnotation) {

    Class[] paramTypesArray = (Class[]) toArray(paramTypesOrArrayOrList);

    Method method = null;
    
    try {
      method = theClass.getDeclaredMethod(methodName, paramTypesArray);
    } catch (NoSuchMethodException nsme) {
      //this is ok
    } catch (Exception e) {
      throw new RuntimeException(&quot;Problem retrieving method: &quot; + theClass.getSimpleName() + &quot;, &quot; + methodName, e);
    }
    
    if (method != null) {
      //we found a method, make sure it is valid
      // if not static, then return null (dont worry about superclass)
      if (!isStaticOrInstance
          &amp;&amp; Modifier.isStatic(method.getModifiers())) {
        return null;
      }
      // if checking for annotation, if not there, then recurse
      if (markerAnnotation == null
          || (includeAnnotation == method
              .isAnnotationPresent(markerAnnotation))) {
        return method;
      }
    }
    // see if done recursing (if superclassToStopAt is null, then stop at
    // Object
    if (theClass.equals(superclassToStopAt)
        || theClass.equals(Object.class)) {
      return null;
    }
    Class superclass = theClass.getSuperclass();
    if (!includeSuperclassToStopAt &amp;&amp; superclass.equals(superclassToStopAt)) {
      return null;
    }
    // recurse
    return method(superclass, methodName, paramTypesArray, superclassToStopAt,
        includeSuperclassToStopAt, isStaticOrInstance, markerAnnotation, includeAnnotation);
  }
  
  /**
   * get all field names from a class, including superclasses (if specified)
   * 
   * @param theClass
   *            to look for fields in
   * @param superclassToStopAt
   *            to go up to or null to go up to Object
   * @param fieldType
   *            is the type of the field to get
   * @param includeSuperclassToStopAt
   *            if we should include the superclass
   * @param includeStaticFields
   *            if include static fields
   * @param includeFinalFields
   *            if final fields should be included
   * @param markerAnnotation
   *            if this is not null, then if the field has this annotation,
   *            then do not include in list
   * @param fieldSet
   *            set to add fields to
   * @param includeAnnotation
   *            if include or exclude
   */
  @SuppressWarnings(&quot;unchecked&quot;)
  private static void fieldsHelper(Class theClass, Class superclassToStopAt,
      Class&lt;?&gt; fieldType, boolean includeSuperclassToStopAt,
      boolean includeStaticFields, boolean includeFinalFields,
      Class&lt;? extends Annotation&gt; markerAnnotation, Set&lt;Field&gt; fieldSet,
      boolean includeAnnotation) {
    Field[] fields = theClass.getDeclaredFields();
    if (length(fields) != 0) {
      for (Field field : fields) {
        // if checking for type, and not right type, continue
        if (fieldType != null
            &amp;&amp; !fieldType.isAssignableFrom(field.getType())) {
          continue;
        }
        // if not static, then continue
        if (!includeStaticFields
            &amp;&amp; Modifier.isStatic(field.getModifiers())) {
          continue;
        }
        // if not final constinue
        if (!includeFinalFields
            &amp;&amp; Modifier.isFinal(field.getModifiers())) {
          continue;
        }
        // if checking for annotation
        if (markerAnnotation != null
            &amp;&amp; (includeAnnotation != field
                .isAnnotationPresent(markerAnnotation))) {
          continue;
        }
        // go for it
        fieldSet.add(field);
      }
    }
    // see if done recursing (if superclassToStopAt is null, then stop at
    // Object
    if (theClass.equals(superclassToStopAt)
        || theClass.equals(Object.class)) {
      return;
    }
    Class superclass = theClass.getSuperclass();
    if (!includeSuperclassToStopAt &amp;&amp; superclass.equals(superclassToStopAt)) {
      return;
    }
    // recurse
    fieldsHelper(superclass, superclassToStopAt, fieldType,
        includeSuperclassToStopAt, includeStaticFields,
        includeFinalFields, markerAnnotation, fieldSet,
        includeAnnotation);
  }

  /**
   * find out a field value
   * 
   * @param theClass
   *            the class which has the method
   * @param invokeOn
   *            to call on or null for static
   * @param fieldName
   *            method name to call
   * @param callOnSupers
   *            if static and method not exists, try on supers
   * @param overrideSecurity
   *            true to call on protected or private etc methods
   * @return the current value
   */
  public static Object fieldValue(Class theClass, Object invokeOn,
      String fieldName, boolean callOnSupers, boolean overrideSecurity) {
    Field field = null;

    // only if the method exists, try to execute
    try {
      // ok if null
      if (theClass == null) {
        theClass = invokeOn.getClass();
      }
      field = field(theClass, fieldName, callOnSupers, true);
      return fieldValue(field, invokeOn, overrideSecurity);
    } catch (Exception e) {
      throw new RuntimeException(&quot;Cant execute reflection field: &quot;
          + fieldName + &quot;, on: &quot; + className(invokeOn), e);
    }
  }

  /**
   * get the value of a field, override security if needbe
   * 
   * @param field
   * @param invokeOn
   * @return the value of the field
   */
  public static Object fieldValue(Field field, Object invokeOn) {
    return fieldValue(field, invokeOn, true);
  }

  /**
   * get the value of a field
   * 
   * @param field
   * @param invokeOn
   * @param overrideSecurity
   * @return the value of the field
   */
  public static Object fieldValue(Field field, Object invokeOn,
      boolean overrideSecurity) {
    if (overrideSecurity) {
      field.setAccessible(true);
    }
    try {
      return field.get(invokeOn);
    } catch (Exception e) {
      throw new RuntimeException(&quot;Cant execute reflection field: &quot;
          + field.getName() + &quot;, on: &quot; + className(invokeOn), e);

    }

  }

  /**
   * find out a field value (invoke on supers, override security)
   * 
   * @param invokeOn
   *            to call on or null for static
   * @param fieldName
   *            method name to call
   * @return the current value
   */
  public static Object fieldValue(Object invokeOn, String fieldName) {
    return fieldValue(null, invokeOn, fieldName, true, true);
  }

  /**
   * get the decalred methods for a class, perhaps from cache
   * 
   * @param theClass
   * @return the declared methods
   */
  @SuppressWarnings(&quot;unused&quot;)
  private static Method[] retrieveDeclaredMethods(Class theClass) {
    Method[] methods = declaredMethodsCache().get(theClass);
    // get from cache if we can
    if (methods == null) {
      methods = theClass.getDeclaredMethods();
      declaredMethodsCache().put(theClass, methods);
    }
    return methods;
  }

  /**
   * helper method for calling a method with no params (could be in
   * superclass)
   * 
   * @param theClass
   *            the class which has the method
   * @param invokeOn
   *            to call on or null for static
   * @param methodName
   *            method name to call
   * @return the data
   */
  public static Object callMethod(Class theClass, Object invokeOn,
      String methodName) {
    return callMethod(theClass, invokeOn, methodName, null, null);
  }

  /**
   * helper method for calling a method (could be in superclass)
   * 
   * @param theClass
   *            the class which has the method
   * @param invokeOn
   *            to call on or null for static
   * @param methodName
   *            method name to call
   * @param paramTypesOrArrayOrList
   *            types of the params
   * @param paramsOrListOrArray
   *            data
   * @return the data
   */
  public static Object callMethod(Class theClass, Object invokeOn,
      String methodName, Object paramTypesOrArrayOrList,
      Object paramsOrListOrArray) {
    return callMethod(theClass, invokeOn, methodName,
        paramTypesOrArrayOrList, paramsOrListOrArray, true);
  }

  /**
   * helper method for calling a method
   * 
   * @param theClass
   *            the class which has the method
   * @param invokeOn
   *            to call on or null for static
   * @param methodName
   *            method name to call
   * @param paramTypesOrArrayOrList
   *            types of the params
   * @param paramsOrListOrArray
   *            data
   * @param callOnSupers
   *            if static and method not exists, try on supers
   * @return the data
   */
  public static Object callMethod(Class theClass, Object invokeOn,
      String methodName, Object paramTypesOrArrayOrList,
      Object paramsOrListOrArray, boolean callOnSupers) {
    return callMethod(theClass, invokeOn, methodName,
        paramTypesOrArrayOrList, paramsOrListOrArray, callOnSupers,
        false);
  }

  /**
   * construct an instance by reflection
   * @param &lt;T&gt;
   * @param theClass
   * @param args
   * @param types
   * @return the instance
   */
  public static &lt;T&gt; T construct(Class&lt;T&gt; theClass, Class[] types, Object[] args) {
    try {
      Constructor&lt;T&gt; constructor = theClass.getConstructor(types);
      
      return constructor.newInstance(args);
      
    } catch (Exception e) {
      throw new RuntimeException(&quot;Having trouble with constructor for class: &quot; + theClass.getSimpleName()
          + &quot; and args: &quot; + classesString(types), e);
     }
  }
  
  /**
   * helper method for calling a method
   * 
   * @param theClass
   *            the class which has the method
   * @param invokeOn
   *            to call on or null for static
   * @param methodName
   *            method name to call
   * @param paramTypesOrArrayOrList
   *            types of the params
   * @param paramsOrListOrArray
   *            data
   * @param callOnSupers
   *            if static and method not exists, try on supers
   * @param overrideSecurity
   *            true to call on protected or private etc methods
   * @return the data
   */
  public static Object callMethod(Class theClass, Object invokeOn,
      String methodName, Object paramTypesOrArrayOrList,
      Object paramsOrListOrArray, boolean callOnSupers,
      boolean overrideSecurity) {
    Method method = null;

    Class[] paramTypesArray = (Class[]) toArray(paramTypesOrArrayOrList);

    try {
      method = theClass.getDeclaredMethod(methodName, paramTypesArray);
      if (overrideSecurity) {
        method.setAccessible(true);
      }
    } catch (Exception e) {
      // if method not found
      if (e instanceof NoSuchMethodException) {
        // if traversing up, and not Object, and not instance method
        // CH 070425 not sure why invokeOn needs to be null, removing
        // this
        if (callOnSupers /* &amp;&amp; invokeOn == null */
            &amp;&amp; !theClass.equals(Object.class)) {
          return callMethod(theClass.getSuperclass(), invokeOn,
              methodName, paramTypesOrArrayOrList,
              paramsOrListOrArray, callOnSupers, overrideSecurity);
        }
      }
      throw new RuntimeException(&quot;Problem calling method &quot; + methodName
          + &quot; on &quot; + theClass.getName(), e);
    }

    return invokeMethod(method, invokeOn, paramsOrListOrArray);

  }
  
  /** pass this in the invokeOn to signify no params */
  private static final Object NO_PARAMS = new Object();
  
  /**
   * Safely invoke a reflection method that takes no args
   * 
   * @param method
   *            to invoke
   * @param invokeOn
   * if NO_PARAMS then will not pass in params.
   * @return the result
   */
  public static Object invokeMethod(Method method, Object invokeOn) {
    return invokeMethod(method, invokeOn, NO_PARAMS);
  }

  /**
   * Safely invoke a reflection method
   * 
   * @param method
   *            to invoke
   * @param invokeOn
   * @param paramsOrListOrArray must be an arg.  If null, will pass null.
   * if NO_PARAMS then will not pass in params.
   * @return the result
   */
  public static Object invokeMethod(Method method, Object invokeOn,
      Object paramsOrListOrArray) {

    Object[] args = paramsOrListOrArray == NO_PARAMS ? null : (Object[]) toArray(paramsOrListOrArray);

    //we want to make sure things are accessible
    method.setAccessible(true);

    //only if the method exists, try to execute
    Object result = null;
    Exception e = null;
    try {
      result = method.invoke(invokeOn, args);
    } catch (IllegalAccessException iae) {
      e = iae;
    } catch (IllegalArgumentException iae) {
      e = iae;
    } catch (InvocationTargetException ite) {
      //this means the underlying call caused exception... its ok if runtime
      if (ite.getCause() instanceof RuntimeException) {
        throw (RuntimeException)ite.getCause();
      }
      //else throw as invocation target...
      e = ite;
    }
    if (e != null) {
      throw new RuntimeException(&quot;Cant execute reflection method: &quot;
          + method.getName() + &quot;, on: &quot; + className(invokeOn)
          + &quot;, with args: &quot; + classNameCollection(args), e);
    }
    return result;
  }

  /**
   * Convert a list to an array with the type of the first element e.g. if it
   * is a list of Person objects, then the array is Person[]
   * 
   * @param objectOrArrayOrCollection
   *            is a list
   * @return the array of objects with type of the first element in the list
   */
  public static Object toArray(Object objectOrArrayOrCollection) {
    // do this before length since if array with null in it, we want ti get
    // it back
    if (objectOrArrayOrCollection != null
        &amp;&amp; objectOrArrayOrCollection.getClass().isArray()) {
      return objectOrArrayOrCollection;
    }
    int length = length(objectOrArrayOrCollection);
    if (length == 0) {
      return null;
    }

    if (objectOrArrayOrCollection instanceof Collection) {
      Collection collection = (Collection) objectOrArrayOrCollection;
      Object first = collection.iterator().next();
      return toArray(collection, first == null ? Object.class : first
          .getClass());
    }
    // make an array of the type of object passed in, size one
    Object array = Array.newInstance(objectOrArrayOrCollection.getClass(),
        1);
    Array.set(array, 0, objectOrArrayOrCollection);
    return array;
  }

  /**
   * convert a list into an array of type of theClass
   * @param &lt;T&gt; is the type of the array
   * @param collection list to convert
   * @param theClass type of array to return
   * @return array of type theClass[] filled with the objects from list
   */
  @SuppressWarnings(&quot;unchecked&quot;)
  public static &lt;T&gt; T[] toArray(Collection collection, Class&lt;T&gt; theClass) {
    if (collection == null || collection.size() == 0) {
      return null;
    }

    return (T[])collection.toArray((Object[]) Array.newInstance(theClass,
        collection.size()));

  }

  /**
   * helper method for calling a static method up the stack. method takes no
   * args (could be in superclass)
   * 
   * @param theClass
   *            the class which has the method
   * @param methodName
   *            method name to call
   * @return the data
   */
  public static Object callMethod(Class theClass, String methodName) {
    return callMethod(theClass, null, methodName, null, null);
  }

  /**
   * helper method for calling a static method with no params
   * 
   * @param theClass
   *            the class which has the method
   * @param methodName
   *            method name to call
   * @param callOnSupers
   *            if we should try the super classes if not exists in this class
   * @return the data
   */
  public static Object callMethod(Class theClass, String methodName,
      boolean callOnSupers) {
    return callMethod(theClass, null, methodName, null, null, callOnSupers);
  }

  /**
   * helper method for calling a static method up the stack
   * 
   * @param theClass
   *            the class which has the method
   * @param methodName
   *            method name to call
   * @param paramTypesOrArrayOrList
   *            types of the params
   * @param paramsOrListOrArray
   *            data
   * @return the data
   */
  public static Object callMethod(Class theClass, String methodName,
      Object paramTypesOrArrayOrList, Object paramsOrListOrArray) {
    return callMethod(theClass, null, methodName, paramTypesOrArrayOrList,
        paramsOrListOrArray);
  }

  /**
   * helper method for calling a method with no params (could be in
   * superclass), will override security
   * 
   * @param invokeOn
   *            instance to invoke on
   * @param methodName
   *            method name to call not exists in this class
   * @return the data
   */
  public static Object callMethod(Object invokeOn, String methodName) {
    if (invokeOn == null) {
      throw new NullPointerException(&quot;invokeOn is null: &quot; + methodName);
    }
    return callMethod(invokeOn.getClass(), invokeOn, methodName, null,
        null, true, true);
  }

  /**
   * replace a string or strings from a string, and put the output in a string
   * buffer. This does not recurse
   * 
   * @param text
   *            string to look in
   * @param searchFor
   *            string array to search for
   * @param replaceWith
   *            string array to replace with
   * @return the string
   */
  public static String replace(String text, Object searchFor,
      Object replaceWith) {
    return replace(null, null, text, searchFor, replaceWith, false, 0,
        false);
  }

  /**
   * replace a string or strings from a string, and put the output in a string
   * buffer
   * 
   * @param text
   *            string to look in
   * @param searchFor
   *            string array to search for
   * @param replaceWith
   *            string array to replace with
   * @param recurse
   *            if true then do multiple replaces (on the replacements)
   * @return the string
   */
  public static String replace(String text, Object searchFor,
      Object replaceWith, boolean recurse) {
    return replace(null, null, text, searchFor, replaceWith, recurse,
        recurse ? length(searchFor) : 0, false);
  }

  /**
   * replace a string or strings from a string, and put the output in a string
   * buffer
   * 
   * @param text
   *            string to look in
   * @param searchFor
   *            string array to search for
   * @param replaceWith
   *            string array to replace with
   * @param recurse
   *            if true then do multiple replaces (on the replacements)
   * @param removeIfFound
   *            true if removing from searchFor and replaceWith if found
   * @return the string
   */
  public static String replace(String text, Object searchFor,
      Object replaceWith, boolean recurse, boolean removeIfFound) {
    return replace(null, null, text, searchFor, replaceWith, recurse,
        recurse ? length(searchFor) : 0, removeIfFound);
  }

  /**
   * &lt;p&gt;
   * Replaces all occurrences of a String within another String.
   * &lt;/p&gt;
   * 
   * &lt;p&gt;
   * A &lt;code&gt;null&lt;/code&gt; reference passed to this method is a no-op.
   * &lt;/p&gt;
   * 
   * &lt;pre&gt;
   * replace(null, *, *)        = null
   * replace(&amp;quot;&amp;quot;, *, *)          = &amp;quot;&amp;quot;
   * replace(&amp;quot;any&amp;quot;, null, *)    = &amp;quot;any&amp;quot;
   * replace(&amp;quot;any&amp;quot;, *, null)    = &amp;quot;any&amp;quot;
   * replace(&amp;quot;any&amp;quot;, &amp;quot;&amp;quot;, *)      = &amp;quot;any&amp;quot;
   * replace(&amp;quot;aba&amp;quot;, &amp;quot;a&amp;quot;, null)  = &amp;quot;aba&amp;quot;
   * replace(&amp;quot;aba&amp;quot;, &amp;quot;a&amp;quot;, &amp;quot;&amp;quot;)    = &amp;quot;b&amp;quot;
   * replace(&amp;quot;aba&amp;quot;, &amp;quot;a&amp;quot;, &amp;quot;z&amp;quot;)   = &amp;quot;zbz&amp;quot;
   * &lt;/pre&gt;
   * 
   * @see #replace(String text, String repl, String with, int max)
   * @param text
   *            text to search and replace in, may be null
   * @param repl
   *            the String to search for, may be null
   * @param with
   *            the String to replace with, may be null
   * @return the text with any replacements processed, &lt;code&gt;null&lt;/code&gt; if
   *         null String input
   */
  public static String replace(String text, String repl, String with) {
    return replace(text, repl, with, -1);
  }

  /**
   * &lt;p&gt;
   * Replaces a String with another String inside a larger String, for the
   * first &lt;code&gt;max&lt;/code&gt; values of the search String.
   * &lt;/p&gt;
   * 
   * &lt;p&gt;
   * A &lt;code&gt;null&lt;/code&gt; reference passed to this method is a no-op.
   * &lt;/p&gt;
   * 
   * &lt;pre&gt;
   * replace(null, *, *, *)         = null
   * replace(&amp;quot;&amp;quot;, *, *, *)           = &amp;quot;&amp;quot;
   * replace(&amp;quot;any&amp;quot;, null, *, *)     = &amp;quot;any&amp;quot;
   * replace(&amp;quot;any&amp;quot;, *, null, *)     = &amp;quot;any&amp;quot;
   * replace(&amp;quot;any&amp;quot;, &amp;quot;&amp;quot;, *, *)       = &amp;quot;any&amp;quot;
   * replace(&amp;quot;any&amp;quot;, *, *, 0)        = &amp;quot;any&amp;quot;
   * replace(&amp;quot;abaa&amp;quot;, &amp;quot;a&amp;quot;, null, -1) = &amp;quot;abaa&amp;quot;
   * replace(&amp;quot;abaa&amp;quot;, &amp;quot;a&amp;quot;, &amp;quot;&amp;quot;, -1)   = &amp;quot;b&amp;quot;
   * replace(&amp;quot;abaa&amp;quot;, &amp;quot;a&amp;quot;, &amp;quot;z&amp;quot;, 0)   = &amp;quot;abaa&amp;quot;
   * replace(&amp;quot;abaa&amp;quot;, &amp;quot;a&amp;quot;, &amp;quot;z&amp;quot;, 1)   = &amp;quot;zbaa&amp;quot;
   * replace(&amp;quot;abaa&amp;quot;, &amp;quot;a&amp;quot;, &amp;quot;z&amp;quot;, 2)   = &amp;quot;zbza&amp;quot;
   * replace(&amp;quot;abaa&amp;quot;, &amp;quot;a&amp;quot;, &amp;quot;z&amp;quot;, -1)  = &amp;quot;zbzz&amp;quot;
   * &lt;/pre&gt;
   * 
   * @param text
   *            text to search and replace in, may be null
   * @param repl
   *            the String to search for, may be null
   * @param with
   *            the String to replace with, may be null
   * @param max
   *            maximum number of values to replace, or &lt;code&gt;-1&lt;/code&gt; if
   *            no maximum
   * @return the text with any replacements processed, &lt;code&gt;null&lt;/code&gt; if
   *         null String input
   */
  public static String replace(String text, String repl, String with, int max) {
    if (text == null || isEmpty(repl) || with == null || max == 0) {
      return text;
    }

    StringBuffer buf = new StringBuffer(text.length());
    int start = 0, end = 0;
    while ((end = text.indexOf(repl, start)) != -1) {
      buf.append(text.substring(start, end)).append(with);
      start = end + repl.length();

      if (--max == 0) {
        break;
      }
    }
    buf.append(text.substring(start));
    return buf.toString();
  }

  /**
   * &lt;p&gt;
   * Checks if a String is empty (&quot;&quot;) or null.
   * &lt;/p&gt;
   * 
   * &lt;pre&gt;
   * isEmpty(null)      = true
   * isEmpty(&amp;quot;&amp;quot;)        = true
   * isEmpty(&amp;quot; &amp;quot;)       = false
   * isEmpty(&amp;quot;bob&amp;quot;)     = false
   * isEmpty(&amp;quot;  bob  &amp;quot;) = false
   * &lt;/pre&gt;
   * 
   * &lt;p&gt;
   * NOTE: This method changed in Lang version 2.0. It no longer trims the
   * String. That functionality is available in isBlank().
   * &lt;/p&gt;
   * 
   * @param str
   *            the String to check, may be null
   * @return &lt;code&gt;true&lt;/code&gt; if the String is empty or null
   */
  public static boolean isEmpty(String str) {
    return str == null || str.length() == 0;
  }

  /**
   * replace a string or strings from a string, and put the output in a string
   * buffer. This does not recurse
   * 
   * @param outBuffer
   *            stringbuffer to write to
   * @param text
   *            string to look in
   * @param searchFor
   *            string array to search for
   * @param replaceWith
   *            string array to replace with
   */
  public static void replace(StringBuffer outBuffer, String text,
      Object searchFor, Object replaceWith) {
    replace(outBuffer, null, text, searchFor, replaceWith, false, 0, false);
  }

  /**
   * replace a string or strings from a string, and put the output in a string
   * buffer
   * 
   * @param outBuffer
   *            stringbuffer to write to
   * @param text
   *            string to look in
   * @param searchFor
   *            string array to search for
   * @param replaceWith
   *            string array to replace with
   * @param recurse
   *            if true then do multiple replaces (on the replacements)
   */
  public static void replace(StringBuffer outBuffer, String text,
      Object searchFor, Object replaceWith, boolean recurse) {
    replace(outBuffer, null, text, searchFor, replaceWith, recurse,
        recurse ? length(searchFor) : 0, false);
  }

  /**
   * replace a string with other strings, and either write to outWriter, or
   * StringBuffer, and if StringBuffer potentially return a string. If
   * outBuffer and outWriter are null, then return the String
   * 
   * @param outBuffer
   *            stringbuffer to write to, or null to not
   * @param outWriter
   *            Writer to write to, or null to not.
   * @param text
   *            string to look in
   * @param searchFor
   *            string array to search for, or string, or list
   * @param replaceWith
   *            string array to replace with, or string, or list
   * @param recurse
   *            if true then do multiple replaces (on the replacements)
   * @param timeToLive
   *            if recursing, prevent endless loops
   * @param removeIfFound
   *            true if removing from searchFor and replaceWith if found
   * @return the String if outBuffer and outWriter are null
   * @throws IndexOutOfBoundsException
   *             if the lengths of the arrays are not the same (null is ok,
   *             and/or size 0)
   * @throws IllegalArgumentException
   *             if the search is recursive and there is an endless loop due
   *             to outputs of one being inputs to another
   */
  private static String replace(StringBuffer outBuffer, Writer outWriter,
      String text, Object searchFor, Object replaceWith, boolean recurse,
      int timeToLive, boolean removeIfFound) {

    // if recursing, we need to get the string, then print to buffer (since
    // we need multiple passes)
    if (!recurse) {
      return replaceHelper(outBuffer, outWriter, text, searchFor,
          replaceWith, recurse, timeToLive, removeIfFound);
    }
    // get the string
    String result = replaceHelper(null, null, text, searchFor, replaceWith,
        recurse, timeToLive, removeIfFound);
    if (outBuffer != null) {
      outBuffer.append(result);
      return null;
    }

    if (outWriter != null) {
      try {
        outWriter.write(result);
      } catch (IOException ioe) {
        throw new RuntimeException(ioe);
      }
      return null;
    }

    return result;

  }

  /**
   * replace a string or strings from a string, and put the output in a string
   * buffer. This does not recurse
   * 
   * @param outWriter
   *            writer to write to
   * @param text
   *            string to look in
   * @param searchFor
   *            string array to search for
   * @param replaceWith
   *            string array to replace with
   */
  public static void replace(Writer outWriter, String text, Object searchFor,
      Object replaceWith) {
    replace(null, outWriter, text, searchFor, replaceWith, false, 0, false);
  }

  /**
   * replace a string or strings from a string, and put the output in a string
   * buffer
   * 
   * @param outWriter
   *            writer to write to
   * @param text
   *            string to look in
   * @param searchFor
   *            string array to search for
   * @param replaceWith
   *            string array to replace with
   * @param recurse
   *            if true then do multiple replaces (on the replacements)
   */
  public static void replace(Writer outWriter, String text, Object searchFor,
      Object replaceWith, boolean recurse) {
    replace(null, outWriter, text, searchFor, replaceWith, recurse,
        recurse ? length(searchFor) : 0, false);
  }

  /**
   * replace a string with other strings, and either write to outWriter, or
   * StringBuffer, and if StringBuffer potentially return a string. If
   * outBuffer and outWriter are null, then return the String
   * 
   * @param outBuffer
   *            stringbuffer to write to, or null to not
   * @param outWriter
   *            Writer to write to, or null to not.
   * @param text
   *            string to look in
   * @param searchFor
   *            string array to search for, or string, or list
   * @param replaceWith
   *            string array to replace with, or string, or list
   * @param recurse
   *            if true then do multiple replaces (on the replacements)
   * @param timeToLive
   *            if recursing, prevent endless loops
   * @param removeIfFound
   *            true if removing from searchFor and replaceWith if found
   * @return the String if outBuffer and outWriter are null
   * @throws IllegalArgumentException
   *             if the search is recursive and there is an endless loop due
   *             to outputs of one being inputs to another
   * @throws IndexOutOfBoundsException
   *             if the lengths of the arrays are not the same (null is ok,
   *             and/or size 0)
   */
  private static String replaceHelper(StringBuffer outBuffer,
      Writer outWriter, String text, Object searchFor,
      Object replaceWith, boolean recurse, int timeToLive,
      boolean removeIfFound) {

    try {
      // if recursing, this shouldnt be less than 0
      if (timeToLive &lt; 0) {
        throw new IllegalArgumentException(&quot;TimeToLive under 0: &quot;
            + timeToLive + &quot;, &quot; + text);
      }

      int searchForLength = length(searchFor);
      boolean done = false;
      // no need to do anything
      if (isEmpty(text)) {
        return text;
      }
      // need to write the input to output, later
      if (searchForLength == 0) {
        done = true;
      }

      boolean[] noMoreMatchesForReplIndex = null;
      int inputIndex = -1;
      int replaceIndex = -1;
      long resultPacked = -1;

      if (!done) {
        // make sure lengths are ok, these need to be equal
        if (searchForLength != length(replaceWith)) {
          throw new IndexOutOfBoundsException(&quot;Lengths dont match: &quot;
              + searchForLength + &quot;, &quot; + length(replaceWith));
        }

        // keep track of which still have matches
        noMoreMatchesForReplIndex = new boolean[searchForLength];

        // index of replace array that will replace the search string
        // found
        

        resultPacked = findNextIndexHelper(searchForLength, searchFor,
            replaceWith, 
            noMoreMatchesForReplIndex, text, 0);

        inputIndex = unpackInt(resultPacked, true);
        replaceIndex = unpackInt(resultPacked, false);
      }

      // get a good guess on the size of the result buffer so it doesnt
      // have to double if it
      // goes over a bit
      boolean writeToWriter = outWriter != null;

      // no search strings found, we are done
      if (done || inputIndex == -1) {
        if (writeToWriter) {
          outWriter.write(text, 0, text.length());
          return null;
        }
        if (outBuffer != null) {
          appendSubstring(outBuffer, text, 0, text.length());
          return null;
        }
        return text;
      }

      // no buffer if writing to writer
      StringBuffer bufferToWriteTo = outBuffer != null ? outBuffer
          : (writeToWriter ? null : new StringBuffer(text.length()
              + replaceStringsBufferIncrease(text, searchFor,
                  replaceWith)));

      String searchString = null;
      String replaceString = null;

      int start = 0;

      while (inputIndex != -1) {

        searchString = (String) get(searchFor, replaceIndex);
        replaceString = (String) get(replaceWith, replaceIndex);
        if (writeToWriter) {
          outWriter.write(text, start, inputIndex - start);
          outWriter.write(replaceString);
        } else {
          appendSubstring(bufferToWriteTo, text, start, inputIndex)
              .append(replaceString);
        }

        if (removeIfFound) {
          // better be an iterator based find replace
          searchFor = remove(searchFor, replaceIndex);
          replaceWith = remove(replaceWith, replaceIndex);
          noMoreMatchesForReplIndex = (boolean[])remove(noMoreMatchesForReplIndex, replaceIndex);
          // we now have a lesser size if we removed one
          searchForLength--;
        }

        start = inputIndex + searchString.length();

        resultPacked = findNextIndexHelper(searchForLength, searchFor,
            replaceWith, 
            noMoreMatchesForReplIndex, text, start);
        inputIndex = unpackInt(resultPacked, true);
        replaceIndex = unpackInt(resultPacked, false);
      }
      if (writeToWriter) {
        outWriter.write(text, start, text.length() - start);

      } else {
        appendSubstring(bufferToWriteTo, text, start, text.length());
      }

      // no need to convert to string if incoming buffer or writer
      if (writeToWriter || outBuffer != null) {
        if (recurse) {
          throw new IllegalArgumentException(
              &quot;Cannot recurse and write to existing buffer or writer!&quot;);
        }
        return null;
      }
      String resultString = bufferToWriteTo.toString();

      if (recurse) {
        return replaceHelper(outBuffer, outWriter, resultString,
            searchFor, replaceWith, recurse, timeToLive - 1, false);
      }
      // this might be null for writer
      return resultString;
    } catch (IOException ioe) {
      throw new RuntimeException(ioe);
    }
  }

  /**
   * give a best guess on buffer increase for String[] replace get a good
   * guess on the size of the result buffer so it doesnt have to double if it
   * goes over a bit
   * 
   * @param text
   * @param repl
   * @param with
   * @return the increase, with 20% cap
   */
  static int replaceStringsBufferIncrease(String text, Object repl,
      Object with) {
    // count the greaters
    int increase = 0;
    Iterator iteratorReplace = iterator(repl);
    Iterator iteratorWith = iterator(with);
    int replLength = length(repl);
    String currentRepl = null;
    String currentWith = null;
    for (int i = 0; i &lt; replLength; i++) {
      currentRepl = (String) next(repl, iteratorReplace, i);
      currentWith = (String) next(with, iteratorWith, i);
      if (currentRepl == null || currentWith == null) {
        throw new NullPointerException(&quot;Replace string is null: &quot;
            + text + &quot;, &quot; + currentRepl + &quot;, &quot; + currentWith);
      }
      int greater = currentWith.length() - currentRepl.length();
      increase += greater &gt; 0 ? 3 * greater : 0; // assume 3 matches
    }
    // have upper-bound at 20% increase, then let Java take over
    increase = Math.min(increase, text.length() / 5);
    return increase;
  }

  /**
   * Helper method to find the next match in an array of strings replace
   * 
   * @param searchForLength
   * @param searchFor
   * @param replaceWith
   * @param noMoreMatchesForReplIndex
   * @param input
   * @param start
   *            is where to start looking
   * @return result packed into a long, inputIndex first, then replaceIndex
   */
  private static long findNextIndexHelper(int searchForLength,
      Object searchFor, Object replaceWith, boolean[] noMoreMatchesForReplIndex,
      String input, int start) {

    int inputIndex = -1;
    int replaceIndex = -1;

    Iterator iteratorSearchFor = iterator(searchFor);
    Iterator iteratorReplaceWith = iterator(replaceWith);

    String currentSearchFor = null;
    String currentReplaceWith = null;
    int tempIndex = -1;
    for (int i = 0; i &lt; searchForLength; i++) {
      currentSearchFor = (String) next(searchFor, iteratorSearchFor, i);
      currentReplaceWith = (String) next(replaceWith,
          iteratorReplaceWith, i);
      if (noMoreMatchesForReplIndex[i] || isEmpty(currentSearchFor)
          || currentReplaceWith == null) {
        continue;
      }
      tempIndex = input.indexOf(currentSearchFor, start);

      // see if we need to keep searching for this
      noMoreMatchesForReplIndex[i] = tempIndex == -1;

      if (tempIndex != -1 &amp;&amp; (inputIndex == -1 || tempIndex &lt; inputIndex)) {
        inputIndex = tempIndex;
        replaceIndex = i;
      }

    }
    // dont create an array, no more objects
    long resultPacked = packInts(inputIndex, replaceIndex);
    return resultPacked;
  }

  /**
   * pack two ints into a long. Note: the first is held in the left bits, the
   * second is held in the right bits
   * 
   * @param first
   *            is first int
   * @param second
   *            is second int
   * @return the long which has two ints in there
   */
  public static long packInts(int first, int second) {
    long result = first;
    result &lt;&lt;= 32;
    result |= second;
    return result;
  }

  /**
   * take a long
   * 
   * @param theLong
   *            to unpack
   * @param isFirst
   *            true for first, false for second
   * @return one of the packed ints, first or second
   */
  public static int unpackInt(long theLong, boolean isFirst) {

    int result = 0;
    // put this in the position of the second one
    if (isFirst) {
      theLong &gt;&gt;= 32;
    }
    // only look at right part
    result = (int) (theLong &amp; 0xffffffff);
    return result;
  }

  /**
   * append a substring to a stringbuffer. removes dependency on substring
   * which creates objects
   * 
   * @param buf
   *            stringbuffer
   * @param string
   *            source string
   * @param start
   *            start index of source string
   * @param end
   *            end index of source string
   * @return the string buffer for chaining
   */
  private static StringBuffer appendSubstring(StringBuffer buf,
      String string, int start, int end) {
    for (int i = start; i &lt; end; i++) {
      buf.append(string.charAt(i));
    }
    return buf;
  }

  /**
   * Get a specific index of an array or collection (note for collections and
   * iterating, it is more efficient to get an iterator and iterate
   * 
   * @param arrayOrCollection
   * @param index
   * @return the object at that index
   */
  public static Object get(Object arrayOrCollection, int index) {

    if (arrayOrCollection == null) {
      if (index == 0) {
        return null;
      }
      throw new RuntimeException(&quot;Trying to access index &quot; + index
          + &quot; of null&quot;);
    }

    // no need to iterator on list (e.g. FastProxyList has no iterator
    if (arrayOrCollection instanceof List) {
      return ((List) arrayOrCollection).get(index);
    }
    if (arrayOrCollection instanceof Collection) {
      Iterator iterator = iterator(arrayOrCollection);
      for (int i = 0; i &lt; index; i++) {
        next(arrayOrCollection, iterator, i);
      }
      return next(arrayOrCollection, iterator, index);
    }

    if (arrayOrCollection.getClass().isArray()) {
      return Array.get(arrayOrCollection, index);
    }

    if (index == 0) {
      return arrayOrCollection;
    }

    throw new RuntimeException(&quot;Trying to access index &quot; + index
        + &quot; of and object: &quot; + arrayOrCollection);
  }


  
  /**
   * fail safe toString for Exception blocks, and include the stack
   * if there is a problem with toString()
   * @param object
   * @return the toStringSafe string
   */
  @SuppressWarnings(&quot;unchecked&quot;)
  public static String toStringSafe(Object object) {
    if (object == null) {
      return null;
    }
    
    try {
      //give size and type if collection
      if (object instanceof Collection) {
        Collection&lt;Object&gt; collection = (Collection&lt;Object&gt;) object;
        int collectionSize = collection.size();
        if (collectionSize == 0) {
          return &quot;Empty &quot; + object.getClass().getSimpleName();
        }
        Object first = collection.iterator().next();
        return object.getClass().getSimpleName() + &quot; of size &quot; 
          + collectionSize + &quot; with first type: &quot; + 
          (first == null ? null : first.getClass());
      }
    
      return object.toString();
    } catch (Exception e) {
      return &quot;&lt;&lt;exception&gt;&gt; &quot; + object.getClass() + &quot;:\n&quot; + getFullStackTrace(e) + &quot;\n&quot;;
    }
  }

  /**
   * get the boolean value for an object, cant be null or blank
   * 
   * @param object
   * @return the boolean
   */
  public static boolean booleanValue(Object object) {
    // first handle blanks
    if (nullOrBlank(object)) {
      throw new RuntimeException(
          &quot;Expecting something which can be converted to boolean, but is null or blank: '&quot;
              + object + &quot;'&quot;);
    }
    // its not blank, just convert
    if (object instanceof Boolean) {
      return (Boolean) object;
    }
    if (object instanceof String) {
      String string = (String) object;
      if (equalsIgnoreCase(string, &quot;true&quot;)
          || equalsIgnoreCase(string, &quot;t&quot;)
          || equalsIgnoreCase(string, &quot;yes&quot;)
          || equalsIgnoreCase(string, &quot;y&quot;)) {
        return true;
      }
      if (equalsIgnoreCase(string, &quot;false&quot;)
          || equalsIgnoreCase(string, &quot;f&quot;)
          || equalsIgnoreCase(string, &quot;no&quot;)
          || equalsIgnoreCase(string, &quot;n&quot;)) {
        return false;
      }
      throw new RuntimeException(
          &quot;Invalid string to boolean conversion: '&quot; + string
              + &quot;' expecting true|false or t|f or yes|no or y|n case insensitive&quot;);
  
    }
    throw new RuntimeException(&quot;Cant convert object to boolean: &quot;
        + object.getClass());
  
  }

  /**
   * get the boolean value for an object
   * 
   * @param object
   * @param defaultBoolean
   *            if object is null or empty
   * @return the boolean
   */
  public static boolean booleanValue(Object object, boolean defaultBoolean) {
    if (nullOrBlank(object)) {
      return defaultBoolean;
    }
    return booleanValue(object);
  }

  /**
   * get the Boolean value for an object
   * 
   * @param object
   * @return the Boolean or null if null or empty
   */
  public static Boolean booleanObjectValue(Object object) {
    if (nullOrBlank(object)) {
      return null;
    }
    return booleanValue(object);
  }

  /**
   * is an object null or blank
   * 
   * @param object
   * @return true if null or blank
   */
  public static boolean nullOrBlank(Object object) {
    // first handle blanks and nulls
    if (object == null) {
      return true;
    }
    if (object instanceof String &amp;&amp; isBlank(((String) object))) {
      return true;
    }
    return false;
  
  }

  /**
   * get a getter method object for a class, potentially in superclasses
   * @param theClass
   * @param fieldName
   * @param callOnSupers true if superclasses should be looked in for the getter
   * @param throwExceptionIfNotFound will throw runtime exception if not found
   * @return the getter object or null if not found (or exception if param is set)
   */
  public static Method getter(Class theClass, String fieldName, boolean callOnSupers, 
      boolean throwExceptionIfNotFound) {
    String getterName = getterNameFromPropertyName(fieldName);
    return getterHelper(theClass, fieldName, getterName, callOnSupers, throwExceptionIfNotFound);
  }

  /**
   * get a setter method object for a class, potentially in superclasses
   * @param theClass
   * @param fieldName
   * @param getterName name of setter
   * @param callOnSupers true if superclasses should be looked in for the setter
   * @param throwExceptionIfNotFound will throw runtime exception if not found
   * @return the setter object or null if not found (or exception if param is set)
   */
  public static Method getterHelper(Class theClass, String fieldName, String getterName, 
      boolean callOnSupers, boolean throwExceptionIfNotFound) {
    Method[] methods = retrieveDeclaredMethods(theClass);
    if (methods != null) {
      for (Method method : methods) {
        if (equals(getterName, method.getName()) &amp;&amp; isGetter(method)) {
          return method;
        }
      }
    }
    //if method not found
    //if traversing up, and not Object, and not instance method
    if (callOnSupers &amp;&amp; !theClass.equals(Object.class)) {
      return getterHelper(theClass.getSuperclass(), fieldName, getterName, 
          callOnSupers, throwExceptionIfNotFound);
    }
    //maybe throw an exception
    if (throwExceptionIfNotFound) {
      throw new RuntimeException(&quot;Cant find getter: &quot;
          + getterName + &quot;, in: &quot; + theClass
          + &quot;, callOnSupers: &quot; + callOnSupers);
    }
    return null;
  }

  /**
   * generate getBb from bb
   * @param propertyName
   * @return the getter 
   */
  public static String getterNameFromPropertyName(String propertyName) {
    return &quot;get&quot; + capitalize(propertyName);
  }

  /**
   * get all getters from a class, including superclasses (if specified) (up to and including the specified superclass).  
   * ignore a certain marker annotation, or only include it.
   * Dont get static or final getters, and get getters of all types
   * @param theClass to look for fields in
   * @param superclassToStopAt to go up to or null to go up to Object
   * @param markerAnnotation if this is not null, then if the field has this annotation, then do not
   * include in list (if includeAnnotation is false)
   * @param includeAnnotation true if the attribute should be included if annotation is present, false if exclude
   * @return the set of field names or empty set if none
   */
  @SuppressWarnings(&quot;unchecked&quot;)
  public static Set&lt;Method&gt; getters(Class theClass, Class superclassToStopAt,
      Class&lt;? extends Annotation&gt; markerAnnotation, Boolean includeAnnotation) {
    return gettersHelper(theClass, superclassToStopAt, null, true, 
        markerAnnotation, includeAnnotation);
  }

  /**
   * get all getters from a class, including superclasses (if specified)
   * @param theClass to look for fields in
   * @param superclassToStopAt to go up to or null to go up to Object
   * @param fieldType is the type of the field to get
   * @param includeSuperclassToStopAt if we should include the superclass
   * @param markerAnnotation if this is not null, then if the field has this annotation, then do not
   * include in list (if includeAnnotation is false)
   * @param includeAnnotation true if the attribute should be included if annotation is present, false if exclude
   * @return the set of fields (wont return null)
   */
  @SuppressWarnings(&quot;unchecked&quot;)
  static Set&lt;Method&gt; gettersHelper(Class theClass, Class superclassToStopAt, Class&lt;?&gt; fieldType,
      boolean includeSuperclassToStopAt, 
      Class&lt;? extends Annotation&gt; markerAnnotation, Boolean includeAnnotation) {
    //MAKE SURE IF ANY MORE PARAMS ARE ADDED, THE CACHE KEY IS CHANGED!
    
    Set&lt;Method&gt; getterSet = null;
    String cacheKey = theClass + CACHE_SEPARATOR + superclassToStopAt + CACHE_SEPARATOR + fieldType + CACHE_SEPARATOR
      + includeSuperclassToStopAt + CACHE_SEPARATOR + markerAnnotation + CACHE_SEPARATOR + includeAnnotation;
    getterSet = getterSetCache().get(cacheKey);
    if (getterSet != null) {
      return getterSet;
    }
    
    getterSet = new LinkedHashSet&lt;Method&gt;();
    gettersHelper(theClass, superclassToStopAt, fieldType, includeSuperclassToStopAt, 
        markerAnnotation, getterSet, includeAnnotation);
  
    //add to cache
    getterSetCache().put(cacheKey, getterSet);
    
    return getterSet;
    
  }

  /**
   * get all getters from a class, including superclasses (if specified)
   * @param theClass to look for fields in
   * @param superclassToStopAt to go up to or null to go up to Object
   * @param propertyType is the type of the field to get
   * @param includeSuperclassToStopAt if we should include the superclass
   * @param markerAnnotation if this is not null, then if the field has this annotation, then do not
   * include in list
   * @param getterSet set to add fields to
   * @param includeAnnotation if include or exclude
   */
  @SuppressWarnings(&quot;unchecked&quot;)
  private static void gettersHelper(Class theClass, Class superclassToStopAt, Class&lt;?&gt; propertyType,
      boolean includeSuperclassToStopAt,  
      Class&lt;? extends Annotation&gt; markerAnnotation, Set&lt;Method&gt; getterSet, Boolean includeAnnotation) {

    Method[] methods = retrieveDeclaredMethods(theClass);
    if (length(methods) != 0) {
      for (Method method: methods) {
        //must be a getter
        if (!isGetter(method)) {
          continue;
        }
        //if checking for annotation
        if (markerAnnotation != null
            &amp;&amp; (includeAnnotation != method.isAnnotationPresent(markerAnnotation))) {
          continue;
        }
        //if checking for type, and not right type, continue
        if (propertyType != null &amp;&amp; !propertyType.isAssignableFrom(method.getReturnType())) {
          continue;
        }
        
        //go for it
        getterSet.add(method);
      }
    }
    //see if done recursing (if superclassToStopAt is null, then stop at Object
    if (theClass.equals(superclassToStopAt) || theClass.equals(Object.class)) {
      return;
    }
    Class superclass = theClass.getSuperclass();
    if (!includeSuperclassToStopAt &amp;&amp; superclass.equals(superclassToStopAt)) {
      return;
    }
    //recurse
    gettersHelper(superclass, superclassToStopAt, propertyType, 
        includeSuperclassToStopAt, markerAnnotation, getterSet,
        includeAnnotation);
  }

  /**
   * if the method name starts with get, and takes no args, and returns something, 
   * then getter
   * @param method 
   * @return true if getter
   */
  public static boolean isGetter(Method method) {
    
    //must start with get
    String methodName = method.getName();
    if (!methodName.startsWith(&quot;get&quot;) &amp;&amp; !methodName.startsWith(&quot;is&quot;)) {
      return false;
    }
  
    //must not be void
    if (method.getReturnType() == Void.TYPE) {
      return false;
    }
    
    //must not take args
    if (length(method.getParameterTypes()) != 0) {
      return false;
    }
    
    //must not be static
    if (Modifier.isStatic(method.getModifiers())) {
      return false;
    }
    
    return true;
  }

  /**
   * assign data to a setter.  Will find the field in superclasses, will typecast, 
   * and will override security (private, protected, etc)
   * @param invokeOn to call on or null for static
   * @param fieldName method name to call
   * @param dataToAssign data  
   * @param typeCast will typecast if true
   * @throws RuntimeException if not there
   */
  public static void assignSetter(Object invokeOn, 
      String fieldName, Object dataToAssign, boolean typeCast) {
    Class invokeOnClass = invokeOn.getClass();
    try {
      Method setter = setter(invokeOnClass, fieldName, true, true);
      setter.setAccessible(true);
      if (typeCast) {
        dataToAssign = typeCast(dataToAssign, setter.getParameterTypes()[0]);
      }
      setter.invoke(invokeOn, new Object[]{dataToAssign});
    } catch (Exception e) {
      throw new RuntimeException(&quot;Problem assigning setter: &quot; + fieldName
          + &quot; on class: &quot; + invokeOnClass + &quot;, type of data is: &quot; + className(dataToAssign), e);
    }
  }

  /**
   * if the method name starts with get, and takes no args, and returns something, 
   * then getter
   * @param method 
   * @return true if getter
   */
  public static boolean isSetter(Method method) {
    
    //must start with get
    if (!method.getName().startsWith(&quot;set&quot;)) {
      return false;
    }
  
    //must be void
    if (method.getReturnType() != Void.TYPE) {
      return false;
    }
    
    //must take one arg
    if (length(method.getParameterTypes()) != 1) {
      return false;
    }
    
    //must not be static
    if (Modifier.isStatic(method.getModifiers())) {
      return false;
    }
    
    return true;
  }

  /**
   * get a setter method object for a class, potentially in superclasses
   * @param theClass
   * @param fieldName
   * @param callOnSupers true if superclasses should be looked in for the setter
   * @param throwExceptionIfNotFound will throw runtime exception if not found
   * @return the setter object or null if not found (or exception if param is set)
   */
  public static Method setter(Class theClass, String fieldName, boolean callOnSupers, 
      boolean throwExceptionIfNotFound) {
    String setterName = setterNameFromPropertyName(fieldName);
    return setterHelper(theClass, fieldName, setterName, callOnSupers, throwExceptionIfNotFound);
  }

  /**
   * get a setter method object for a class, potentially in superclasses
   * @param theClass
   * @param fieldName
   * @param setterName name of setter
   * @param callOnSupers true if superclasses should be looked in for the setter
   * @param throwExceptionIfNotFound will throw runtime exception if not found
   * @return the setter object or null if not found (or exception if param is set)
   */
  public static Method setterHelper(Class theClass, String fieldName, String setterName, 
      boolean callOnSupers, boolean throwExceptionIfNotFound) {
    Method[] methods = retrieveDeclaredMethods(theClass);
    if (methods != null) {
      for (Method method : methods) {
        if (equals(setterName, method.getName()) &amp;&amp; isSetter(method)) {
          return method;
        }
      }
    }
    //if method not found
    //if traversing up, and not Object, and not instance method
    if (callOnSupers &amp;&amp; !theClass.equals(Object.class)) {
      return setterHelper(theClass.getSuperclass(), fieldName, setterName, 
          callOnSupers, throwExceptionIfNotFound);
    }
    //maybe throw an exception
    if (throwExceptionIfNotFound) {
      throw new RuntimeException(&quot;Cant find setter: &quot;
          + setterName + &quot;, in: &quot; + theClass
          + &quot;, callOnSupers: &quot; + callOnSupers);
    }
    return null;
  }

  /**
   * generate setBb from bb
   * @param propertyName
   * @return the setter 
   */
  public static String setterNameFromPropertyName(String propertyName) {
    return &quot;set&quot; + capitalize(propertyName);
  }

  /**
   * get all setters from a class, including superclasses (if specified)
   * @param theClass to look for fields in
   * @param superclassToStopAt to go up to or null to go up to Object
   * @param fieldType is the type of the field to get
   * @param includeSuperclassToStopAt if we should include the superclass
   * @param markerAnnotation if this is not null, then if the field has this annotation, then do not
   * include in list (if includeAnnotation is false)
   * @param includeAnnotation true if the attribute should be included if annotation is present, false if exclude
   * @return the set of fields (wont return null)
   */
  @SuppressWarnings(&quot;unchecked&quot;)
  public static Set&lt;Method&gt; setters(Class theClass, Class superclassToStopAt, Class&lt;?&gt; fieldType,
      boolean includeSuperclassToStopAt, 
      Class&lt;? extends Annotation&gt; markerAnnotation, boolean includeAnnotation) {
    return settersHelper(theClass, superclassToStopAt, fieldType, 
        includeSuperclassToStopAt, markerAnnotation, includeAnnotation);
  }

  /**
   * get all setters from a class, including superclasses (if specified)
   * @param theClass to look for fields in
   * @param superclassToStopAt to go up to or null to go up to Object
   * @param fieldType is the type of the field to get
   * @param includeSuperclassToStopAt if we should include the superclass
   * @param markerAnnotation if this is not null, then if the field has this annotation, then do not
   * include in list (if includeAnnotation is false)
   * @param includeAnnotation true if the attribute should be included if annotation is present, false if exclude
   * @return the set of fields (wont return null)
   */
  @SuppressWarnings(&quot;unchecked&quot;)
  static Set&lt;Method&gt; settersHelper(Class theClass, Class superclassToStopAt, Class&lt;?&gt; fieldType,
      boolean includeSuperclassToStopAt, 
      Class&lt;? extends Annotation&gt; markerAnnotation, boolean includeAnnotation) {
    //MAKE SURE IF ANY MORE PARAMS ARE ADDED, THE CACHE KEY IS CHANGED!
    
    Set&lt;Method&gt; setterSet = null;
    String cacheKey = theClass + CACHE_SEPARATOR + superclassToStopAt + CACHE_SEPARATOR + fieldType + CACHE_SEPARATOR
      + includeSuperclassToStopAt + CACHE_SEPARATOR + markerAnnotation + CACHE_SEPARATOR + includeAnnotation;
    setterSet = setterSetCache().get(cacheKey);
    if (setterSet != null) {
      return setterSet;
    }
    
    setterSet = new LinkedHashSet&lt;Method&gt;();
    settersHelper(theClass, superclassToStopAt, fieldType, includeSuperclassToStopAt, 
        markerAnnotation, setterSet, includeAnnotation);
  
    //add to cache
    setterSetCache().put(cacheKey, setterSet);
    
    return setterSet;
    
  }

  /**
   * get all setters from a class, including superclasses (if specified)
   * @param theClass to look for fields in
   * @param superclassToStopAt to go up to or null to go up to Object
   * @param propertyType is the type of the field to get
   * @param includeSuperclassToStopAt if we should include the superclass
   * @param markerAnnotation if this is not null, then if the field has this annotation, then do not
   * include in list
   * @param setterSet set to add fields to
   * @param includeAnnotation if include or exclude (or null if not looking for annotations)
   */
  @SuppressWarnings(&quot;unchecked&quot;)
  private static void settersHelper(Class theClass, Class superclassToStopAt, Class&lt;?&gt; propertyType,
      boolean includeSuperclassToStopAt,  
      Class&lt;? extends Annotation&gt; markerAnnotation, Set&lt;Method&gt; setterSet, Boolean includeAnnotation) {

    Method[] methods = retrieveDeclaredMethods(theClass);
    if (length(methods) != 0) {
      for (Method method: methods) {
        //must be a getter
        if (!isSetter(method)) {
          continue;
        }
        //if checking for annotation
        if (markerAnnotation != null
            &amp;&amp; (includeAnnotation != method.isAnnotationPresent(markerAnnotation))) {
          continue;
        }
        //if checking for type, and not right type, continue
        if (propertyType != null &amp;&amp; !propertyType.isAssignableFrom(method.getParameterTypes()[0])) {
          continue;
        }
        
        //go for it
        setterSet.add(method);
      }
    }
    //see if done recursing (if superclassToStopAt is null, then stop at Object
    if (theClass.equals(superclassToStopAt) || theClass.equals(Object.class)) {
      return;
    }
    Class superclass = theClass.getSuperclass();
    if (!includeSuperclassToStopAt &amp;&amp; superclass.equals(superclassToStopAt)) {
      return;
    }
    //recurse
    settersHelper(superclass, superclassToStopAt, propertyType, 
        includeSuperclassToStopAt, markerAnnotation, setterSet,
        includeAnnotation);
  }

  /**
   * If this is a getter or setter, then get the property name
   * @param method
   * @return the property name
   */
  public static String propertyName(Method method) {
    String methodName = method.getName();
    boolean isGetter = methodName.startsWith(&quot;get&quot;);
    boolean isSetter = methodName.startsWith(&quot;set&quot;);
    boolean isIsser = methodName.startsWith(&quot;is&quot;);
    int expectedLength = isIsser ? 2 : 3; 
    int length = methodName.length();
    if ((!(isGetter || isSetter || isIsser)) || (length &lt;= expectedLength)) {
      throw new RuntimeException(&quot;Not a getter or setter: &quot; + methodName);
    }
    char fourthCharLower = Character.toLowerCase(methodName.charAt(expectedLength));
    //if size 4, then return the string
    if (length == expectedLength +1) {
      return Character.toString(fourthCharLower);
    }
    //return the lower appended with the rest
    return fourthCharLower + methodName.substring(expectedLength+1, length);
  }

  /**
   * use reflection to get a property type based on getter or setter or field
   * @param theClass
   * @param propertyName
   * @return the property type
   */
  public static Class propertyType(Class theClass, String propertyName) {
    Method method = getter(theClass, propertyName, true, false);
    if (method != null) {
      return method.getReturnType();
    }
    //use setter
    method = setter(theClass, propertyName, true, false);
    if (method != null) {
      return method.getParameterTypes()[0];
    }
    //no setter or getter, use field
    Field field = field(theClass, propertyName, true, true);
    return field.getType();
  }

  /**
   * If necessary, convert an object to another type.  if type is Object.class, just return the input.
   * Do not convert null to an empty primitive
   * @param &lt;T&gt; is template type
   * @param value
   * @param theClass
   * @return the object of that instance converted into something else
   */
  public static &lt;T&gt; T typeCast(Object value, Class&lt;T&gt; theClass) {
    //default behavior is not to convert null to empty primitive
    return typeCast(value, theClass, false, false);
  }

  /**
   * &lt;pre&gt;
   * make a new file in the name prefix dir.  If parent dir name is c:\temp
   * and namePrefix is grouperDdl and nameSuffix is sql, then the file will be:
   * 
   * c:\temp\grouperDdl_20080721_13_45_43_123.sql
   *  
   * If the file exists, it will make a new filename, and create the empty file, and return it
   * &lt;/pre&gt;
   *  
   * @param parentDirName can be blank for current dir
   * @param namePrefix the part before the date part
   * @param nameSuffix the last part of file name (can contain dot or will be the extension
   * @param createFile true to create the file
   * @return the created file
   */
  public static File newFileUniqueName(String parentDirName, String namePrefix, String nameSuffix, boolean createFile) {
    DateFormat fileNameFormat = new SimpleDateFormat(&quot;yyyyMMdd_HH_mm_ss_SSS&quot;);
    if (!isBlank(parentDirName)) {

      if (!parentDirName.endsWith(&quot;/&quot;) &amp;&amp; !parentDirName.endsWith(&quot;\\&quot;)) {
        parentDirName += File.separator;
      }
      
      //make sure it exists and is a dir
      File parentDir = new File(parentDirName);
      if (!parentDir.exists()) {
        if (!parentDir.mkdirs()) {
          throw new RuntimeException(&quot;Cant make dir: &quot; + parentDir.getAbsolutePath());
        }
      } else {
        if (!parentDir.isDirectory()) {
          throw new RuntimeException(&quot;Parent dir is not a directory: &quot; + parentDir.getAbsolutePath());
        } 
      }
      
    } else {
      //make it empty string so it will concatenate well
      parentDirName = &quot;&quot;;
    }
    //make sure suffix has a dot in it
    if (!nameSuffix.contains(&quot;.&quot;)) {
      nameSuffix = &quot;.&quot; + nameSuffix;
    }
    
    String fileName = parentDirName + namePrefix + &quot;_&quot; + fileNameFormat.format(new Date()) + nameSuffix;
    int dotLocation = fileName.lastIndexOf('.');
    String fileNamePre = fileName.substring(0,dotLocation);
    String fileNamePost = fileName.substring(dotLocation);
    File theFile = new File(fileName);

    int i;
    
    for (i=0;i&lt;1000;i++) {
      
      if (!theFile.exists()) {
        break;
      }
      
      fileName = fileNamePre + &quot;_&quot; + i + fileNamePost;
      theFile = new File(fileName);
      
    }
    
    if (i&gt;=1000) {
      throw new RuntimeException(&quot;Cant find filename to create: &quot; + fileName);
    }
    
    if (createFile) {
      try {
        if (!theFile.createNewFile()) {
          throw new RuntimeException(&quot;Cant create file, it returned false&quot;);
        }
      } catch (Exception e) {
        throw new RuntimeException(&quot;Cant create file: &quot; + fileName + &quot;, make sure &quot; +
            &quot;permissions and such are ok, or change file location in grouper.properties if applicable&quot;, e);
      }
    }
    return theFile;
  }
  
  /**
   * &lt;pre&gt;
   * Convert an object to a java.util.Date.  allows, dates, null, blank, 
   * yyyymmdd or yyyymmdd hh24:mm:ss
   * or yyyy/MM/dd HH:mm:ss.SSS
   * &lt;/pre&gt;
   * @param inputObject
   *          is the String or Date to convert
   * 
   * @return the Date
   */
  public static Date dateValue(Object inputObject) {
    if (inputObject == null) {
      return null;
    } 

    if (inputObject instanceof java.util.Date) {
      return (Date)inputObject;
    }

    if (inputObject instanceof String) {
      String input = (String)inputObject;
      //trim and handle null and empty
      if (isBlank(input)) {
        return null;
      }

      try {
        if (input.length() == 8) {
          
          return dateFormat().parse(input);
        }
        if (!contains(input, '.')) {
          if (contains(input, '/')) {
            return dateMinutesSecondsFormat.parse(input);
          }
          //else no slash
          return dateMinutesSecondsNoSlashFormat.parse(input);
        }
        if (contains(input, '/')) {
          //see if the period is 6 back
          int lastDotIndex = input.lastIndexOf('.');
          if (lastDotIndex == input.length() - 7) {
            String nonNanoInput = input.substring(0,input.length()-3);
            Date date = timestampFormat.parse(nonNanoInput);
            //get the last 3
            String lastThree = input.substring(input.length()-3,input.length());
            int lastThreeInt = Integer.parseInt(lastThree);
            Timestamp timestamp = new Timestamp(date.getTime());
            timestamp.setNanos(timestamp.getNanos() + (lastThreeInt * 1000));
            return timestamp;
          }
          return timestampFormat.parse(input);
        }
        //else no slash
        return timestampNoSlashFormat.parse(input);
      } catch (ParseException pe) {
        throw new RuntimeException(errorStart + toStringForLog(input));
      }
    }
    
    throw new RuntimeException(&quot;Cannot convert Object to date : &quot; + toStringForLog(inputObject));
  }

  /**
   * See if the input is null or if string, if it is empty or blank (whitespace)
   * @param input
   * @return true if blank
   */
  public static boolean isBlank(Object input) {
    if (null == input) {
      return true;
    }
    return (input instanceof String &amp;&amp; isBlank((String)input));
  }

  /**
   * If necessary, convert an object to another type.  if type is Object.class, just return the input
   * @param &lt;T&gt; is the type to return
   * @param value
   * @param theClass
   * @param convertNullToDefaultPrimitive if the value is null, and theClass is primitive, should we
   * convert the null to a primitive default value
   * @param useNewInstanceHooks if theClass is not recognized, then honor the string &quot;null&quot;, &quot;newInstance&quot;,
   * or get a constructor with one param, and call it
   * @return the object of that instance converted into something else
   */
  @SuppressWarnings({ &quot;unchecked&quot;, &quot;cast&quot; })
  public static &lt;T&gt; T typeCast(Object value, Class&lt;T&gt; theClass, 
      boolean convertNullToDefaultPrimitive, boolean useNewInstanceHooks) {
    
    if (Object.class.equals(theClass)) {
      return (T)value;
    }
    
    if (value==null) {
      if (convertNullToDefaultPrimitive &amp;&amp; theClass.isPrimitive()) {
        if ( theClass == boolean.class ) {
          return (T)Boolean.FALSE;
        }
        if ( theClass == char.class ) {
          return (T)(Object)0;
        }
        //convert 0 to the type
        return typeCast(0, theClass, false, false);
      }
      return null;
    }
  
    if (theClass.isInstance(value)) {
      return (T)value;
    }
    
    //if array, get the base class
    if (theClass.isArray() &amp;&amp; theClass.getComponentType() != null) {
      theClass = (Class&lt;T&gt;)theClass.getComponentType();
    }
    Object resultValue = null;
    //loop through and see the primitive types etc
    if (theClass.equals(Date.class)) {
      resultValue = dateValue(value);
    } else if (theClass.equals(String.class)) {
      resultValue = stringValue(value);
    } else if (theClass.equals(Timestamp.class)) {
      resultValue = toTimestamp(value);
    } else if (theClass.equals(Boolean.class) || theClass.equals(boolean.class)) {
      resultValue = booleanObjectValue(value);
    } else if (theClass.equals(Integer.class) || theClass.equals(int.class)) {
      resultValue = intObjectValue(value, true);
    } else if (theClass.equals(Double.class) || theClass.equals(double.class)) {
      resultValue = doubleObjectValue(value, true);
    } else if (theClass.equals(Float.class) || theClass.equals(float.class)) {
      resultValue = floatObjectValue(value, true);
    } else if (theClass.equals(Long.class) || theClass.equals(long.class)) {
      resultValue = longObjectValue(value, true);
    } else if (theClass.equals(Byte.class) || theClass.equals(byte.class)) {
      resultValue = byteObjectValue(value);
    } else if (theClass.equals(Character.class) || theClass.equals(char.class)) {
      resultValue = charObjectValue(value);
    } else if (theClass.equals(Short.class) || theClass.equals(short.class)) {
      resultValue = shortObjectValue(value);
    } else if ( theClass.isEnum() &amp;&amp; (value instanceof String) ) {
      resultValue = Enum.valueOf((Class)theClass, (String) value);
    } else if ( theClass.equals(Class.class) &amp;&amp; (value instanceof String) ) {
      resultValue = forName((String)value);
    } else if (useNewInstanceHooks &amp;&amp; value instanceof String) {
      String stringValue = (String)value;
      if ( equals(&quot;null&quot;, stringValue)) {
        resultValue = null;
      } else if (equals(&quot;newInstance&quot;, stringValue)) {
        resultValue = newInstance(theClass);
      } else { // instantiate using string
        //note, we could typecast this to fit whatever is there... right now this is used for annotation
        try {
          Constructor constructor = theClass.getConstructor(new Class[] {String.class} );
          resultValue = constructor.newInstance(new Object[] {stringValue} );            
        } catch (Exception e) {
          throw new RuntimeException(&quot;Cant find constructor with string for class: &quot; + theClass);
        }
      }
    } else {
      throw new RuntimeException(&quot;Cannot convert from type: &quot; + value.getClass() + &quot; to type: &quot; + theClass);
    }
  
    return (T)resultValue;
  }
  
  /**
   * see if a class is a scalar (not bean, not array or list, etc)
   * @param type
   * @return true if scalar
   */
  public static boolean isScalar(Class&lt;?&gt; type) {
    
    if (type.isArray()) {
      return false;
    }
    
    //definitely all primitives
    if (type.isPrimitive()) {
      return true;
    }
    //Integer, Float, etc
    if (Number.class.isAssignableFrom(type)) {
      return true;
    }
    //Date, Timestamp
    if (Date.class.isAssignableFrom(type)) {
      return true;
    }
    if (Character.class.equals(type)) {
      return true;
    }
    //handles strings and string builders
    if (CharSequence.class.equals(type) || CharSequence.class.isAssignableFrom(type)) {
      return true;
    }
    if (Class.class == type || Boolean.class == type || type.isEnum()) {
      return true;
    }
    //appears not to be a scalar
    return false;
  }
  
  
  /**
   * &lt;pre&gt;
   * Convert a string or object to a timestamp (could be string, date, timestamp, etc)
   * yyyymmdd
   * or
   * yyyy/MM/dd HH:mm:ss
   * or
   * yyyy/MM/dd HH:mm:ss.SSS
   * or
   * yyyy/MM/dd HH:mm:ss.SSSSSS
   * 
   * &lt;/pre&gt;
   * 
   * @param input
   * @return the timestamp 
   * @throws RuntimeException if invalid format
   */
  public static Timestamp toTimestamp(Object input) {

    if (null == input) {
      return null;
    } else if (input instanceof java.sql.Timestamp) {
      return (Timestamp) input;
    } else if (input instanceof String) {
      return stringToTimestamp((String) input);
    } else if (input instanceof Date) {
      return new Timestamp(((Date)input).getTime());
    } else if (input instanceof java.sql.Date) {
      return new Timestamp(((java.sql.Date)input).getTime());
    } else {
      throw new RuntimeException(&quot;Cannot convert Object to timestamp : &quot; + input);
    }

  }

  /**
   * convert an object to a string
   * 
   * @param input
   *          is the object to convert
   * 
   * @return the String conversion of the object
   */
  public static String stringValue(Object input) {
    //this isnt needed
    if (input == null) {
      return (String) input;
    }

    if (input instanceof Timestamp) {
      //convert to yyyy/MM/dd HH:mm:ss.SSS
      return timestampToString((Timestamp) input);
    }

    if (input instanceof Date) {
      //convert to yyyymmdd
      return stringValue((Date) input);
    }

    if (input instanceof Number) {
      DecimalFormat decimalFormat = new DecimalFormat(
          &quot;###################.###############&quot;);
      return decimalFormat.format(((Number) input).doubleValue());

    }

    return input.toString();
  }

  /**
   * Convert a timestamp into a string: yyyy/MM/dd HH:mm:ss.SSS
   * @param timestamp
   * @return the string representation
   */
  public synchronized static String timestampToString(Date timestamp) {
    if (timestamp == null) {
      return null;
    }
    return timestampFormat.format(timestamp);
  }

  /**
   * get the timestamp format for this thread
   * if you call this make sure to synchronize on FastDateUtils.class
   * @return the timestamp format
   */
  synchronized static SimpleDateFormat dateFormat() {
    return dateFormat;
  }

  /**
   * convert a date to the standard string yyyymmdd
   * @param date 
   * @return the string value
   */
  public static String stringValue(java.util.Date date) {
    synchronized (ConfigPropertiesCascadeCommonUtils.class) {</pre></div></td></tr></table>
<table border="0" class="bodyTable">
<tr class="a">
<th>File</th>
<th>Line</th></tr>
<tr class="b">
<td>edu\internet2\middleware\grouperClient\config\ConfigPropertiesCascadeCommonUtils.java</td>
<td><a href="./xref/edu/internet2/middleware/grouperClient/config/ConfigPropertiesCascadeCommonUtils.html#L5328">5328</a></td></tr>
<tr class="a">
<td>edu\internet2\middleware\grouperClient\util\GrouperClientCommonUtils.java</td>
<td><a href="./xref/edu/internet2/middleware/grouperClient/util/GrouperClientCommonUtils.html#L5405">5405</a></td></tr>
<tr class="b"><td colspan='2'>
<div>
<pre>        }
        if (!success) {
          properties = null;
          if (exceptionIfNotExist) {
            throw new RuntimeException(&quot;Problem with resource: '&quot; + resourceName + &quot;'&quot;, e);
          }
        }
      } finally {
        closeQuietly(inputStream);
        
        if (useCache &amp;&amp; properties != null &amp;&amp; properties.size() &gt; 0) {
          resourcePropertiesCache.put(resourceName, properties);
        }
      }
    }
    
    return properties;
  }

  /**
   * do a case-insensitive matching
   * @param theEnumClass class of the enum
   * @param &lt;E&gt; generic type
   * 
   * @param string
   * @param exceptionOnNotFound true if exception should be thrown on not found
   * @return the enum or null or exception if not found
   * @throws RuntimeException if there is a problem
   */
  public static &lt;E extends Enum&lt;?&gt;&gt; E enumValueOfIgnoreCase(Class&lt;E&gt; theEnumClass, String string, 
      boolean exceptionOnNotFound) throws RuntimeException {
    
    if (!exceptionOnNotFound &amp;&amp; isBlank(string)) {
      return null;
    }
    for (E e : theEnumClass.getEnumConstants()) {
      if (equalsIgnoreCase(string, e.name())) {
        return e;
      }
    }
    StringBuilder error = new StringBuilder(
        &quot;Cant find &quot; + theEnumClass.getSimpleName() + &quot; from string: '&quot;).append(string);
    error.append(&quot;', expecting one of: &quot;);
    for (E e : theEnumClass.getEnumConstants()) {
      error.append(e.name()).append(&quot;, &quot;);
    }
    throw new RuntimeException(error.toString());
  
  }


  /**
   * this assumes the property exists, and is a simple property
   * @param object
   * @param property
   * @return the value
   */
  public static Object propertyValue(Object object, String property)  {
    Method getter = getter(object.getClass(), property, true, true);
    Object result = invokeMethod(getter, object);
    return result;
  }

  /**
   * get a value (trimmed to e) from a property file
   * @param properties
   * @param key
   * @return the property value
   */
  public static String propertiesValue(Properties properties, String key) {
    return propertiesValue(properties, null, key);
  }
  
  /**
   * get a value (trimmed to e) from a property file
   * @param properties
   * @param overrideMap for testing, to override some properties values
   * @param key
   * @return the property value
   */
  public static String propertiesValue(Properties properties, Map&lt;String, String&gt; overrideMap, String key) {
    return propertiesValue(properties, overrideMap, null, key);
  }

  /**
   * get a value (trimmed to e) from a property file
   * @param properties
   * @param overrideMap for testing or threadlocal, to override some properties values
   * @param overrideMap2 for testing, to provide some properties values
   * @param key
   * @return the property value
   */
  public static String propertiesValue(Properties properties, Map&lt;String, String&gt; overrideMap, Map&lt;String, String&gt; overrideMap2, String key) {
    String value = overrideMap == null ? null : overrideMap.get(key);
    if (isBlank(value)) {
      value = overrideMap2 == null ? null : overrideMap2.get(key);
    }
    if (isBlank(value)) {
      value = properties.getProperty(key);
    }
    value = trim(value);
    value = substituteCommonVars(value);
    return value;
  }
  
  /**
   * substitute common vars like $space$ and $newline$
   * @param string
   * @return the string
   */
  public static String substituteCommonVars(String string) {
    if (string == null) {
      return string;
    }
    //short circuit
    if (string.indexOf('$') &lt; 0) {
      return string;
    }
    //might have $space$
    string = replace(string, &quot;$space$&quot;, &quot; &quot;);
    
    //note, at some point we could be OS specific
    string = replace(string, &quot;$newline$&quot;, &quot;\n&quot;); 
    return string;
  }
  
  /**
   * get a boolean property, or the default if cant find
   * @param properties
   * @param propertyName
   * @param defaultValue 
   * @return the boolean
   */
  public static boolean propertiesValueBoolean(Properties properties,
      String propertyName, boolean defaultValue) {
    return propertiesValueBoolean(properties, null, propertyName, defaultValue);
  }
  
  /**
   * get a boolean property, or the default if cant find.  Validate also with a descriptive exception if problem
   * @param resourceName 
   * @param properties
   * @param overrideMap for testing to override properties
   * @param propertyName
   * @param defaultValue 
   * @param required 
   * @return the boolean
   */
  public static boolean propertiesValueBoolean(String resourceName, Properties properties, 
      Map&lt;String, String&gt; overrideMap, String propertyName, boolean defaultValue, boolean required) {
    propertyValidateValueBoolean(resourceName, properties, overrideMap, propertyName, required, true);

    Map&lt;String, String&gt; threadLocalMap = propertiesThreadLocalOverrideMap(resourceName);
    
    return propertiesValueBoolean(properties, threadLocalMap, overrideMap, propertyName, defaultValue);
  }
  
  /**
   * get an int property, or the default if cant find.  Validate also with a descriptive exception if problem
   * @param resourceName 
   * @param properties
   * @param overrideMap for testing to override properties
   * @param propertyName
   * @param defaultValue 
   * @param required 
   * @return the int
   */
  public static int propertiesValueInt(String resourceName, Properties properties, 
      Map&lt;String, String&gt; overrideMap, String propertyName, int defaultValue, boolean required) {
    
    propertyValidateValueInt(resourceName, properties, overrideMap, propertyName, required, true);

    Map&lt;String, String&gt; threadLocalMap = propertiesThreadLocalOverrideMap(resourceName);

    return propertiesValueInt(properties, threadLocalMap, overrideMap, propertyName, defaultValue);
  }

  /**
   * get a boolean property, or the default if cant find.  Validate also with a descriptive exception if problem
   * @param resourceName 
   * @param properties
   * @param overrideMap for threadlocal or testing to override properties
   * @param propertyName
   * @param required 
   * @return the string
   */
  public static String propertiesValue(String resourceName, Properties properties, 
      Map&lt;String, String&gt; overrideMap, String propertyName, boolean required) {

    if (required) {
      propertyValidateValueRequired(resourceName, properties, overrideMap, propertyName, true);
    }
    Map&lt;String, String&gt; threadLocalMap = propertiesThreadLocalOverrideMap(resourceName);

    return propertiesValue(properties, threadLocalMap, overrideMap, propertyName);
  }

  /**
   * get a int property, or the default if cant find
   * @param properties
   * @param overrideMap for testing to override properties
   * @param propertyName
   * @param defaultValue 
   * @return the int
   */
  public static int propertiesValueInt(Properties properties, 
      Map&lt;String, String&gt; overrideMap, String propertyName, int defaultValue) {
    return propertiesValueInt(properties, overrideMap, null, propertyName, defaultValue);
  }


  /**
   * get a int property, or the default if cant find
   * @param properties
   * @param overrideMap for testing to override properties
   * @param overrideMap2 
   * @param propertyName
   * @param defaultValue 
   * @return the int
   */
  public static int propertiesValueInt(Properties properties, 
      Map&lt;String, String&gt; overrideMap, Map&lt;String, String&gt; overrideMap2, String propertyName, int defaultValue) {

    String value = propertiesValue(properties, overrideMap, overrideMap2, propertyName);
    if (isBlank(value)) {
      return defaultValue;
    }

    try {
      return intValue(value);
    } catch (Exception e) {}
    
    throw new RuntimeException(&quot;Invalid int value: '&quot; + value + &quot;' for property: &quot; + propertyName + &quot; in grouper.properties&quot;);

  }
  
  /**
   * get a boolean property, or the default if cant find
   * @param properties
   * @param overrideMap for testing to override properties
   * @param propertyName
   * @param defaultValue 
   * @return the boolean
   */
  public static boolean propertiesValueBoolean(Properties properties, 
      Map&lt;String, String&gt; overrideMap, String propertyName, boolean defaultValue) {
    return propertiesValueBoolean(properties, overrideMap, null, propertyName, defaultValue);
  }

  /**
   * get a boolean property, or the default if cant find
   * @param properties
   * @param overrideMap for testing or threadlocal to override properties
   * @param overrideMap2 for testing or threadlocal to override properties
   * @param propertyName
   * @param defaultValue 
   * @return the boolean
   */
  public static boolean propertiesValueBoolean(Properties properties, 
      Map&lt;String, String&gt; overrideMap, Map&lt;String, String&gt; overrideMap2, String propertyName, boolean defaultValue) {
    
      
    String value = propertiesValue(properties, overrideMap, overrideMap2, propertyName);
    if (isBlank(value)) {
      return defaultValue;
    }
    
    if (&quot;true&quot;.equalsIgnoreCase(value)) {
      return true;
    }
    if (&quot;false&quot;.equalsIgnoreCase(value)) {
      return false;
    }
    if (&quot;t&quot;.equalsIgnoreCase(value)) {
      return true;
    }
    if (&quot;f&quot;.equalsIgnoreCase(value)) {
      return false;
    }
    throw new RuntimeException(&quot;Invalid boolean value: '&quot; + value + &quot;' for property: &quot; + propertyName + &quot; in properties file&quot;);

  }
  
  /**
   * close a connection null safe and dont throw exception
   * @param connection
   */
  public static void closeQuietly(Connection connection) {
    if (connection != null) {
      try {
        connection.close();
      } catch (Exception e) {
        //ignore
      }
    }
  }

  /**
   * close a statement null safe and dont throw exception
   * @param statement
   */
  public static void closeQuietly(Statement statement) {
    if (statement != null) {
      try {
        statement.close();
      } catch (Exception e) {
        //ignore
      }
    }
  }

  /**
   * close a resultSet null safe and dont throw exception
   * @param resultSet
   */
  public static void closeQuietly(ResultSet resultSet) {
    if (resultSet != null) {
      try {
        resultSet.close();
      } catch (Exception e) {
        //ignore
      }
    }
  }

  /** cache the hostname, it wont change */
  private static String hostname = null;

  /**
   * get the hostname of this machine
   * @return the hostname
   */
  public static String hostname() {
  
    if (isBlank(hostname)) {
  
      //get the hostname
      hostname = &quot;unknown&quot;;
      try {
        InetAddress addr = InetAddress.getLocalHost();
  
        // Get hostname
        hostname = addr.getHostName();
      } catch (Exception e) {
        System.err.println(&quot;Cant find servers hostname: &quot;);
        e.printStackTrace();
      }
    }
  
    return hostname;
  }

  /**
   * is ascii char
   * @param input
   * @return true if ascii
   */
  public static boolean isAscii(char input) {
    return input &lt; 128;
  }

  /**
   * find the length of ascii chars (non ascii are counted as two)
   * @param input
   * @return the length of ascii chars
   */
  public static int lengthAscii(String input) {
    if (input == null) {
      return 0;
    }
    //see what real length is
    int utfLength = input.length();
    //count how many non asciis
    int extras = 0;
    for (int i=0;i&lt;utfLength;i++) {
      //keep count of non ascii chars
      if (!isAscii(input.charAt(i))) {
        extras++;
      }
    }
    return utfLength + extras;
  }

  /**
   * rollback a connection quietly
   * @param connection
   */
  public static void rollbackQuietly(Connection connection) {
    if (connection != null) {
      try {
        connection.rollback();
      } catch (Exception e) {
        //ignore
      }
    }
  }

  /**
   * find the length of ascii chars (non ascii are counted as two)
   * @param input is the string to operate on
   * @param requiredLength length we need the string to be
   * @return the length of ascii chars
   */
  public static String truncateAscii(String input, int requiredLength) {
    if (input == null) {
      return input;
    }
    //see what real length is
    int utfLength = input.length();
    
    //see if not worth checking
    if (utfLength * 2 &lt; requiredLength) {
      return input;
    }
    
    //count how many non asciis
    int asciiLength = 0;
    for (int i=0;i&lt;utfLength;i++) {
      
      asciiLength++;
      
      //keep count of non ascii chars
      if (!isAscii(input.charAt(i))) {
        asciiLength++;
      }
      
      //see if we are over 
      if (asciiLength &gt; requiredLength) {
        //do not include the current char
        return input.substring(0,i);
      }
    }
    //must have fit
    return input;
  }
  
  /**
   * if the input is a file, read string from file.  if not, or if disabled from grouper.properties, return the input
   * @param in
   * @param disableExternalFileLookup 
   * @return the result
   */
  public static String readFromFileIfFile(String in, boolean disableExternalFileLookup) {
    
    String theIn = in;
    //convert both slashes to file slashes
    if (File.separatorChar == '/') {
      theIn = replace(theIn, &quot;\\&quot;, &quot;/&quot;);
    } else {
      theIn = replace(theIn, &quot;/&quot;, &quot;\\&quot;);
    }
    
    //see if it is a file reference
    if (theIn.indexOf(File.separatorChar) != -1 &amp;&amp; !disableExternalFileLookup) {
      //read the contents of the file into a string
      theIn = readFileIntoString(new File(theIn));
      return theIn;
    }
    return in;
  
  }

  /**
   * Create directories, throw exception if not possible.
   * This is will be ok if the directory already exists (will not delete it)
   * @param dir
   */
  public static void mkdirs(File dir) {
    if (!dir.exists()) {
      if (!dir.mkdirs()) {
        throw new RuntimeException(&quot;Could not create directory : &quot; + dir.getParentFile());
      }
      return;
    }
    if (!dir.isDirectory()) {
      throw new RuntimeException(&quot;Should be a directory but is not: &quot; + dir);
    }
  }
  

  /**
   * null safe string compare
   * @param first
   * @param second
   * @return true if equal
   */
  public static boolean equals(String first, String second) {
    if (first == second) {
      return true;
    }
    if (first == null || second == null) {
      return false;
    }
    return first.equals(second);
  }

  /**
   * &lt;p&gt;Checks if a String is whitespace, empty (&quot;&quot;) or null.&lt;/p&gt;
   *
   * &lt;pre&gt;
   * isBlank(null)      = true
   * isBlank(&quot;&quot;)        = true
   * isBlank(&quot; &quot;)       = true
   * isBlank(&quot;bob&quot;)     = false
   * isBlank(&quot;  bob  &quot;) = false
   * &lt;/pre&gt;
   *
   * @param str  the String to check, may be null
   * @return &lt;code&gt;true&lt;/code&gt; if the String is null, empty or whitespace
   * @since 2.0
   */
  public static boolean isBlank(String str) {
    int strLen;
    if (str == null || (strLen = str.length()) == 0) {
      return true;
    }
    for (int i = 0; i &lt; strLen; i++) {
      if ((Character.isWhitespace(str.charAt(i)) == false)) {
        return false;
      }
    }
    return true;
  }

  /**
   * 
   * @param str
   * @return true if not blank
   */
  public static boolean isNotBlank(String str) {
    return !isBlank(str);
  }

  /**
   * trim whitespace from string
   * @param str
   * @return trimmed string
   */
  public static String trim(String str) {
    return str == null ? null : str.trim();
  }

  /**
   * equalsignorecase
   * @param str1
   * @param str2
   * @return true if the strings are equal ignore case
   */
  public static boolean equalsIgnoreCase(String str1, String str2) {
    return str1 == null ? str2 == null : str1.equalsIgnoreCase(str2);
  }

  /**
   * trim to empty, convert null to empty
   * @param str
   * @return trimmed
   */
  public static String trimToEmpty(String str) {
    return str == null ? &quot;&quot; : str.trim();
  }

  /**
   * &lt;p&gt;Abbreviates a String using ellipses. This will turn
   * &quot;Now is the time for all good men&quot; into &quot;Now is the time for...&quot;&lt;/p&gt;
   *
   * &lt;p&gt;Specifically:
   * &lt;ul&gt;
   *   &lt;li&gt;If &lt;code&gt;str&lt;/code&gt; is less than &lt;code&gt;maxWidth&lt;/code&gt; characters
   *       long, return it.&lt;/li&gt;
   *   &lt;li&gt;Else abbreviate it to &lt;code&gt;(substring(str, 0, max-3) + &quot;...&quot;)&lt;/code&gt;.&lt;/li&gt;
   *   &lt;li&gt;If &lt;code&gt;maxWidth&lt;/code&gt; is less than &lt;code&gt;4&lt;/code&gt;, throw an
   *       &lt;code&gt;IllegalArgumentException&lt;/code&gt;.&lt;/li&gt;
   *   &lt;li&gt;In no case will it return a String of length greater than
   *       &lt;code&gt;maxWidth&lt;/code&gt;.&lt;/li&gt;
   * &lt;/ul&gt;
   * &lt;/p&gt;
   *
   * &lt;pre&gt;
   * StringUtils.abbreviate(null, *)      = null
   * StringUtils.abbreviate(&quot;&quot;, 4)        = &quot;&quot;
   * StringUtils.abbreviate(&quot;abcdefg&quot;, 6) = &quot;abc...&quot;
   * StringUtils.abbreviate(&quot;abcdefg&quot;, 7) = &quot;abcdefg&quot;
   * StringUtils.abbreviate(&quot;abcdefg&quot;, 8) = &quot;abcdefg&quot;
   * StringUtils.abbreviate(&quot;abcdefg&quot;, 4) = &quot;a...&quot;
   * StringUtils.abbreviate(&quot;abcdefg&quot;, 3) = IllegalArgumentException
   * &lt;/pre&gt;
   *
   * @param str  the String to check, may be null
   * @param maxWidth  maximum length of result String, must be at least 4
   * @return abbreviated String, &lt;code&gt;null&lt;/code&gt; if null String input
   * @throws IllegalArgumentException if the width is too small
   * @since 2.0
   */
  public static String abbreviate(String str, int maxWidth) {
    return abbreviate(str, 0, maxWidth);
  }

  /**
   * &lt;p&gt;Abbreviates a String using ellipses. This will turn
   * &quot;Now is the time for all good men&quot; into &quot;...is the time for...&quot;&lt;/p&gt;
   *
   * &lt;p&gt;Works like &lt;code&gt;abbreviate(String, int)&lt;/code&gt;, but allows you to specify
   * a &quot;left edge&quot; offset.  Note that this left edge is not necessarily going to
   * be the leftmost character in the result, or the first character following the
   * ellipses, but it will appear somewhere in the result.
   *
   * &lt;p&gt;In no case will it return a String of length greater than
   * &lt;code&gt;maxWidth&lt;/code&gt;.&lt;/p&gt;
   *
   * &lt;pre&gt;
   * StringUtils.abbreviate(null, *, *)                = null
   * StringUtils.abbreviate(&quot;&quot;, 0, 4)                  = &quot;&quot;
   * StringUtils.abbreviate(&quot;abcdefghijklmno&quot;, -1, 10) = &quot;abcdefg...&quot;
   * StringUtils.abbreviate(&quot;abcdefghijklmno&quot;, 0, 10)  = &quot;abcdefg...&quot;
   * StringUtils.abbreviate(&quot;abcdefghijklmno&quot;, 1, 10)  = &quot;abcdefg...&quot;
   * StringUtils.abbreviate(&quot;abcdefghijklmno&quot;, 4, 10)  = &quot;abcdefg...&quot;
   * StringUtils.abbreviate(&quot;abcdefghijklmno&quot;, 5, 10)  = &quot;...fghi...&quot;
   * StringUtils.abbreviate(&quot;abcdefghijklmno&quot;, 6, 10)  = &quot;...ghij...&quot;
   * StringUtils.abbreviate(&quot;abcdefghijklmno&quot;, 8, 10)  = &quot;...ijklmno&quot;
   * StringUtils.abbreviate(&quot;abcdefghijklmno&quot;, 10, 10) = &quot;...ijklmno&quot;
   * StringUtils.abbreviate(&quot;abcdefghijklmno&quot;, 12, 10) = &quot;...ijklmno&quot;
   * StringUtils.abbreviate(&quot;abcdefghij&quot;, 0, 3)        = IllegalArgumentException
   * StringUtils.abbreviate(&quot;abcdefghij&quot;, 5, 6)        = IllegalArgumentException
   * &lt;/pre&gt;
   *
   * @param str  the String to check, may be null
   * @param offset  left edge of source String
   * @param maxWidth  maximum length of result String, must be at least 4
   * @return abbreviated String, &lt;code&gt;null&lt;/code&gt; if null String input
   * @throws IllegalArgumentException if the width is too small
   * @since 2.0
   */
  public static String abbreviate(String str, int offset, int maxWidth) {
    if (str == null) {
      return null;
    }
    if (maxWidth &lt; 4) {
      throw new IllegalArgumentException(&quot;Minimum abbreviation width is 4&quot;);
    }
    if (str.length() &lt;= maxWidth) {
      return str;
    }
    if (offset &gt; str.length()) {
      offset = str.length();
    }
    if ((str.length() - offset) &lt; (maxWidth - 3)) {
      offset = str.length() - (maxWidth - 3);
    }
    if (offset &lt;= 4) {
      return str.substring(0, maxWidth - 3) + &quot;...&quot;;
    }
    if (maxWidth &lt; 7) {
      throw new IllegalArgumentException(&quot;Minimum abbreviation width with offset is 7&quot;);
    }
    if ((offset + (maxWidth - 3)) &lt; str.length()) {
      return &quot;...&quot; + abbreviate(str.substring(offset), maxWidth - 3);
    }
    return &quot;...&quot; + str.substring(str.length() - (maxWidth - 3));
  }

  // Splitting
  //-----------------------------------------------------------------------
  /**
   * &lt;p&gt;Splits the provided text into an array, using whitespace as the
   * separator.
   * Whitespace is defined by {@link Character#isWhitespace(char)}.&lt;/p&gt;
   *
   * &lt;p&gt;The separator is not included in the returned String array.
   * Adjacent separators are treated as one separator.
   * For more control over the split use the StrTokenizer class.&lt;/p&gt;
   *
   * &lt;p&gt;A &lt;code&gt;null&lt;/code&gt; input String returns &lt;code&gt;null&lt;/code&gt;.&lt;/p&gt;
   *
   * &lt;pre&gt;
   * StringUtils.split(null)       = null
   * StringUtils.split(&quot;&quot;)         = []
   * StringUtils.split(&quot;abc def&quot;)  = [&quot;abc&quot;, &quot;def&quot;]
   * StringUtils.split(&quot;abc  def&quot;) = [&quot;abc&quot;, &quot;def&quot;]
   * StringUtils.split(&quot; abc &quot;)    = [&quot;abc&quot;]
   * &lt;/pre&gt;
   *
   * @param str  the String to parse, may be null
   * @return an array of parsed Strings, &lt;code&gt;null&lt;/code&gt; if null String input
   */
  public static String[] split(String str) {
    return split(str, null, -1);
  }

  /**
   * &lt;p&gt;Splits the provided text into an array, separator specified.
   * This is an alternative to using StringTokenizer.&lt;/p&gt;
   *
   * &lt;p&gt;The separator is not included in the returned String array.
   * Adjacent separators are treated as one separator.
   * For more control over the split use the StrTokenizer class.&lt;/p&gt;
   *
   * &lt;p&gt;A &lt;code&gt;null&lt;/code&gt; input String returns &lt;code&gt;null&lt;/code&gt;.&lt;/p&gt;
   *
   * &lt;pre&gt;
   * StringUtils.split(null, *)         = null
   * StringUtils.split(&quot;&quot;, *)           = []
   * StringUtils.split(&quot;a.b.c&quot;, '.')    = [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;]
   * StringUtils.split(&quot;a..b.c&quot;, '.')   = [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;]
   * StringUtils.split(&quot;a:b:c&quot;, '.')    = [&quot;a:b:c&quot;]
   * StringUtils.split(&quot;a\tb\nc&quot;, null) = [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;]
   * StringUtils.split(&quot;a b c&quot;, ' ')    = [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;]
   * &lt;/pre&gt;
   *
   * @param str  the String to parse, may be null
   * @param separatorChar  the character used as the delimiter,
   *  &lt;code&gt;null&lt;/code&gt; splits on whitespace
   * @return an array of parsed Strings, &lt;code&gt;null&lt;/code&gt; if null String input
   * @since 2.0
   */
  public static String[] split(String str, char separatorChar) {
    return splitWorker(str, separatorChar, false);
  }

  /**
   * &lt;p&gt;Splits the provided text into an array, separators specified.
   * This is an alternative to using StringTokenizer.&lt;/p&gt;
   *
   * &lt;p&gt;The separator is not included in the returned String array.
   * Adjacent separators are treated as one separator.
   * For more control over the split use the StrTokenizer class.&lt;/p&gt;
   *
   * &lt;p&gt;A &lt;code&gt;null&lt;/code&gt; input String returns &lt;code&gt;null&lt;/code&gt;.
   * A &lt;code&gt;null&lt;/code&gt; separatorChars splits on whitespace.&lt;/p&gt;
   *
   * &lt;pre&gt;
   * StringUtils.split(null, *)         = null
   * StringUtils.split(&quot;&quot;, *)           = []
   * StringUtils.split(&quot;abc def&quot;, null) = [&quot;abc&quot;, &quot;def&quot;]
   * StringUtils.split(&quot;abc def&quot;, &quot; &quot;)  = [&quot;abc&quot;, &quot;def&quot;]
   * StringUtils.split(&quot;abc  def&quot;, &quot; &quot;) = [&quot;abc&quot;, &quot;def&quot;]
   * StringUtils.split(&quot;ab:cd:ef&quot;, &quot;:&quot;) = [&quot;ab&quot;, &quot;cd&quot;, &quot;ef&quot;]
   * &lt;/pre&gt;
   *
   * @param str  the String to parse, may be null
   * @param separatorChars  the characters used as the delimiters,
   *  &lt;code&gt;null&lt;/code&gt; splits on whitespace
   * @return an array of parsed Strings, &lt;code&gt;null&lt;/code&gt; if null String input
   */
  public static String[] split(String str, String separatorChars) {
    return splitWorker(str, separatorChars, -1, false);
  }

  /**
   * &lt;p&gt;Splits the provided text into an array with a maximum length,
   * separators specified.&lt;/p&gt;
   *
   * &lt;p&gt;The separator is not included in the returned String array.
   * Adjacent separators are treated as one separator.&lt;/p&gt;
   *
   * &lt;p&gt;A &lt;code&gt;null&lt;/code&gt; input String returns &lt;code&gt;null&lt;/code&gt;.
   * A &lt;code&gt;null&lt;/code&gt; separatorChars splits on whitespace.&lt;/p&gt;
   *
   * &lt;p&gt;If more than &lt;code&gt;max&lt;/code&gt; delimited substrings are found, the last
   * returned string includes all characters after the first &lt;code&gt;max - 1&lt;/code&gt;
   * returned strings (including separator characters).&lt;/p&gt;
   *
   * &lt;pre&gt;
   * StringUtils.split(null, *, *)            = null
   * StringUtils.split(&quot;&quot;, *, *)              = []
   * StringUtils.split(&quot;ab de fg&quot;, null, 0)   = [&quot;ab&quot;, &quot;cd&quot;, &quot;ef&quot;]
   * StringUtils.split(&quot;ab   de fg&quot;, null, 0) = [&quot;ab&quot;, &quot;cd&quot;, &quot;ef&quot;]
   * StringUtils.split(&quot;ab:cd:ef&quot;, &quot;:&quot;, 0)    = [&quot;ab&quot;, &quot;cd&quot;, &quot;ef&quot;]
   * StringUtils.split(&quot;ab:cd:ef&quot;, &quot;:&quot;, 2)    = [&quot;ab&quot;, &quot;cd:ef&quot;]
   * &lt;/pre&gt;
   *
   * @param str  the String to parse, may be null
   * @param separatorChars  the characters used as the delimiters,
   *  &lt;code&gt;null&lt;/code&gt; splits on whitespace
   * @param max  the maximum number of elements to include in the
   *  array. A zero or negative value implies no limit
   * @return an array of parsed Strings, &lt;code&gt;null&lt;/code&gt; if null String input
   */
  public static String[] split(String str, String separatorChars, int max) {
    return splitWorker(str, separatorChars, max, false);
  }

  /**
   * &lt;p&gt;Splits the provided text into an array, separator string specified.&lt;/p&gt;
   *
   * &lt;p&gt;The separator(s) will not be included in the returned String array.
   * Adjacent separators are treated as one separator.&lt;/p&gt;
   *
   * &lt;p&gt;A &lt;code&gt;null&lt;/code&gt; input String returns &lt;code&gt;null&lt;/code&gt;.
   * A &lt;code&gt;null&lt;/code&gt; separator splits on whitespace.&lt;/p&gt;
   *
   * &lt;pre&gt;
   * StringUtils.split(null, *)            = null
   * StringUtils.split(&quot;&quot;, *)              = []
   * StringUtils.split(&quot;ab de fg&quot;, null)   = [&quot;ab&quot;, &quot;de&quot;, &quot;fg&quot;]
   * StringUtils.split(&quot;ab   de fg&quot;, null) = [&quot;ab&quot;, &quot;de&quot;, &quot;fg&quot;]
   * StringUtils.split(&quot;ab:cd:ef&quot;, &quot;:&quot;)    = [&quot;ab&quot;, &quot;cd&quot;, &quot;ef&quot;]
   * StringUtils.split(&quot;abstemiouslyaeiouyabstemiously&quot;, &quot;aeiouy&quot;)  = [&quot;bst&quot;, &quot;m&quot;, &quot;sl&quot;, &quot;bst&quot;, &quot;m&quot;, &quot;sl&quot;]
   * StringUtils.split(&quot;abstemiouslyaeiouyabstemiously&quot;, &quot;aeiouy&quot;)  = [&quot;abstemiously&quot;, &quot;abstemiously&quot;]
   * &lt;/pre&gt;
   *
   * @param str  the String to parse, may be null
   * @param separator  String containing the String to be used as a delimiter,
   *  &lt;code&gt;null&lt;/code&gt; splits on whitespace
   * @return an array of parsed Strings, &lt;code&gt;null&lt;/code&gt; if null String was input
   */
  public static String[] splitByWholeSeparator(String str, String separator) {
    return splitByWholeSeparator(str, separator, -1);
  }

  /**
   * &lt;p&gt;Splits the provided text into an array, separator string specified.
   * Returns a maximum of &lt;code&gt;max&lt;/code&gt; substrings.&lt;/p&gt;
   *
   * &lt;p&gt;The separator(s) will not be included in the returned String array.
   * Adjacent separators are treated as one separator.&lt;/p&gt;
   *
   * &lt;p&gt;A &lt;code&gt;null&lt;/code&gt; input String returns &lt;code&gt;null&lt;/code&gt;.
   * A &lt;code&gt;null&lt;/code&gt; separator splits on whitespace.&lt;/p&gt;
   *
   * &lt;pre&gt;
   * StringUtils.splitByWholeSeparator(null, *, *)               = null
   * StringUtils.splitByWholeSeparator(&quot;&quot;, *, *)                 = []
   * StringUtils.splitByWholeSeparator(&quot;ab de fg&quot;, null, 0)      = [&quot;ab&quot;, &quot;de&quot;, &quot;fg&quot;]
   * StringUtils.splitByWholeSeparator(&quot;ab   de fg&quot;, null, 0)    = [&quot;ab&quot;, &quot;de&quot;, &quot;fg&quot;]
   * StringUtils.splitByWholeSeparator(&quot;ab:cd:ef&quot;, &quot;:&quot;, 2)       = [&quot;ab&quot;, &quot;cd&quot;]
   * StringUtils.splitByWholeSeparator(&quot;abstemiouslyaeiouyabstemiously&quot;, &quot;aeiouy&quot;, 2) = [&quot;bst&quot;, &quot;m&quot;]
   * StringUtils.splitByWholeSeparator(&quot;abstemiouslyaeiouyabstemiously&quot;, &quot;aeiouy&quot;, 2)  = [&quot;abstemiously&quot;, &quot;abstemiously&quot;]
   * &lt;/pre&gt;
   *
   * @param str  the String to parse, may be null
   * @param separator  String containing the String to be used as a delimiter,
   *  &lt;code&gt;null&lt;/code&gt; splits on whitespace
   * @param max  the maximum number of elements to include in the returned
   *  array. A zero or negative value implies no limit.
   * @return an array of parsed Strings, &lt;code&gt;null&lt;/code&gt; if null String was input
   */
  @SuppressWarnings(&quot;unchecked&quot;)
  public static String[] splitByWholeSeparator(String str, String separator, int max) {
    if (str == null) {
      return null;
    }

    int len = str.length();

    if (len == 0) {
      return EMPTY_STRING_ARRAY;
    }

    if ((separator == null) || (&quot;&quot;.equals(separator))) {
      // Split on whitespace.
      return split(str, null, max);
    }

    int separatorLength = separator.length();

    ArrayList substrings = new ArrayList();
    int numberOfSubstrings = 0;
    int beg = 0;
    int end = 0;
    while (end &lt; len) {
      end = str.indexOf(separator, beg);

      if (end &gt; -1) {
        if (end &gt; beg) {
          numberOfSubstrings += 1;

          if (numberOfSubstrings == max) {
            end = len;
            substrings.add(str.substring(beg));
          } else {
            // The following is OK, because String.substring( beg, end ) excludes
            // the character at the position 'end'.
            substrings.add(str.substring(beg, end));

            // Set the starting point for the next search.
            // The following is equivalent to beg = end + (separatorLength - 1) + 1,
            // which is the right calculation:
            beg = end + separatorLength;
          }
        } else {
          // We found a consecutive occurrence of the separator, so skip it.
          beg = end + separatorLength;
        }
      } else {
        // String.substring( beg ) goes from 'beg' to the end of the String.
        substrings.add(str.substring(beg));
        end = len;
      }
    }

    return (String[]) substrings.toArray(new String[substrings.size()]);
  }

  //-----------------------------------------------------------------------
  /**
   * &lt;p&gt;Splits the provided text into an array, using whitespace as the
   * separator, preserving all tokens, including empty tokens created by 
   * adjacent separators. This is an alternative to using StringTokenizer.
   * Whitespace is defined by {@link Character#isWhitespace(char)}.&lt;/p&gt;
   *
   * &lt;p&gt;The separator is not included in the returned String array.
   * Adjacent separators are treated as separators for empty tokens.
   * For more control over the split use the StrTokenizer class.&lt;/p&gt;
   *
   * &lt;p&gt;A &lt;code&gt;null&lt;/code&gt; input String returns &lt;code&gt;null&lt;/code&gt;.&lt;/p&gt;
   *
   * &lt;pre&gt;
   * StringUtils.splitPreserveAllTokens(null)       = null
   * StringUtils.splitPreserveAllTokens(&quot;&quot;)         = []
   * StringUtils.splitPreserveAllTokens(&quot;abc def&quot;)  = [&quot;abc&quot;, &quot;def&quot;]
   * StringUtils.splitPreserveAllTokens(&quot;abc  def&quot;) = [&quot;abc&quot;, &quot;&quot;, &quot;def&quot;]
   * StringUtils.splitPreserveAllTokens(&quot; abc &quot;)    = [&quot;&quot;, &quot;abc&quot;, &quot;&quot;]
   * &lt;/pre&gt;
   *
   * @param str  the String to parse, may be &lt;code&gt;null&lt;/code&gt;
   * @return an array of parsed Strings, &lt;code&gt;null&lt;/code&gt; if null String input
   * @since 2.1
   */
  public static String[] splitPreserveAllTokens(String str) {
    return splitWorker(str, null, -1, true);
  }

  /**
   * &lt;p&gt;Splits the provided text into an array, separator specified,
   * preserving all tokens, including empty tokens created by adjacent
   * separators. This is an alternative to using StringTokenizer.&lt;/p&gt;
   *
   * &lt;p&gt;The separator is not included in the returned String array.
   * Adjacent separators are treated as separators for empty tokens.
   * For more control over the split use the StrTokenizer class.&lt;/p&gt;
   *
   * &lt;p&gt;A &lt;code&gt;null&lt;/code&gt; input String returns &lt;code&gt;null&lt;/code&gt;.&lt;/p&gt;
   *
   * &lt;pre&gt;
   * StringUtils.splitPreserveAllTokens(null, *)         = null
   * StringUtils.splitPreserveAllTokens(&quot;&quot;, *)           = []
   * StringUtils.splitPreserveAllTokens(&quot;a.b.c&quot;, '.')    = [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;]
   * StringUtils.splitPreserveAllTokens(&quot;a..b.c&quot;, '.')   = [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;]
   * StringUtils.splitPreserveAllTokens(&quot;a:b:c&quot;, '.')    = [&quot;a:b:c&quot;]
   * StringUtils.splitPreserveAllTokens(&quot;a\tb\nc&quot;, null) = [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;]
   * StringUtils.splitPreserveAllTokens(&quot;a b c&quot;, ' ')    = [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;]
   * StringUtils.splitPreserveAllTokens(&quot;a b c &quot;, ' ')   = [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;&quot;]
   * StringUtils.splitPreserveAllTokens(&quot;a b c &quot;, ' ')   = [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;&quot;, &quot;&quot;]
   * StringUtils.splitPreserveAllTokens(&quot; a b c&quot;, ' ')   = [&quot;&quot;, a&quot;, &quot;b&quot;, &quot;c&quot;]
   * StringUtils.splitPreserveAllTokens(&quot;  a b c&quot;, ' ')  = [&quot;&quot;, &quot;&quot;, a&quot;, &quot;b&quot;, &quot;c&quot;]
   * StringUtils.splitPreserveAllTokens(&quot; a b c &quot;, ' ')  = [&quot;&quot;, a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;&quot;]
   * &lt;/pre&gt;
   *
   * @param str  the String to parse, may be &lt;code&gt;null&lt;/code&gt;
   * @param separatorChar  the character used as the delimiter,
   *  &lt;code&gt;null&lt;/code&gt; splits on whitespace
   * @return an array of parsed Strings, &lt;code&gt;null&lt;/code&gt; if null String input
   * @since 2.1
   */
  public static String[] splitPreserveAllTokens(String str, char separatorChar) {
    return splitWorker(str, separatorChar, true);
  }

  /**
   * Performs the logic for the &lt;code&gt;split&lt;/code&gt; and 
   * &lt;code&gt;splitPreserveAllTokens&lt;/code&gt; methods that do not return a
   * maximum array length.
   *
   * @param str  the String to parse, may be &lt;code&gt;null&lt;/code&gt;
   * @param separatorChar the separate character
   * @param preserveAllTokens if &lt;code&gt;true&lt;/code&gt;, adjacent separators are
   * treated as empty token separators; if &lt;code&gt;false&lt;/code&gt;, adjacent
   * separators are treated as one separator.
   * @return an array of parsed Strings, &lt;code&gt;null&lt;/code&gt; if null String input
   */
  @SuppressWarnings(&quot;unchecked&quot;)
  private static String[] splitWorker(String str, char separatorChar,
      boolean preserveAllTokens) {
    // Performance tuned for 2.0 (JDK1.4)

    if (str == null) {
      return null;
    }
    int len = str.length();
    if (len == 0) {
      return EMPTY_STRING_ARRAY;
    }
    List list = new ArrayList();
    int i = 0, start = 0;
    boolean match = false;
    boolean lastMatch = false;
    while (i &lt; len) {
      if (str.charAt(i) == separatorChar) {
        if (match || preserveAllTokens) {
          list.add(str.substring(start, i));
          match = false;
          lastMatch = true;
        }
        start = ++i;
        continue;
      }
      lastMatch = false;
      match = true;
      i++;
    }
    if (match || (preserveAllTokens &amp;&amp; lastMatch)) {
      list.add(str.substring(start, i));
    }
    return (String[]) list.toArray(new String[list.size()]);
  }

  /**
   * &lt;p&gt;Splits the provided text into an array, separators specified, 
   * preserving all tokens, including empty tokens created by adjacent
   * separators. This is an alternative to using StringTokenizer.&lt;/p&gt;
   *
   * &lt;p&gt;The separator is not included in the returned String array.
   * Adjacent separators are treated as separators for empty tokens.
   * For more control over the split use the StrTokenizer class.&lt;/p&gt;
   *
   * &lt;p&gt;A &lt;code&gt;null&lt;/code&gt; input String returns &lt;code&gt;null&lt;/code&gt;.
   * A &lt;code&gt;null&lt;/code&gt; separatorChars splits on whitespace.&lt;/p&gt;
   *
   * &lt;pre&gt;
   * StringUtils.splitPreserveAllTokens(null, *)           = null
   * StringUtils.splitPreserveAllTokens(&quot;&quot;, *)             = []
   * StringUtils.splitPreserveAllTokens(&quot;abc def&quot;, null)   = [&quot;abc&quot;, &quot;def&quot;]
   * StringUtils.splitPreserveAllTokens(&quot;abc def&quot;, &quot; &quot;)    = [&quot;abc&quot;, &quot;def&quot;]
   * StringUtils.splitPreserveAllTokens(&quot;abc  def&quot;, &quot; &quot;)   = [&quot;abc&quot;, &quot;&quot;, def&quot;]
   * StringUtils.splitPreserveAllTokens(&quot;ab:cd:ef&quot;, &quot;:&quot;)   = [&quot;ab&quot;, &quot;cd&quot;, &quot;ef&quot;]
   * StringUtils.splitPreserveAllTokens(&quot;ab:cd:ef:&quot;, &quot;:&quot;)  = [&quot;ab&quot;, &quot;cd&quot;, &quot;ef&quot;, &quot;&quot;]
   * StringUtils.splitPreserveAllTokens(&quot;ab:cd:ef::&quot;, &quot;:&quot;) = [&quot;ab&quot;, &quot;cd&quot;, &quot;ef&quot;, &quot;&quot;, &quot;&quot;]
   * StringUtils.splitPreserveAllTokens(&quot;ab::cd:ef&quot;, &quot;:&quot;)  = [&quot;ab&quot;, &quot;&quot;, cd&quot;, &quot;ef&quot;]
   * StringUtils.splitPreserveAllTokens(&quot;:cd:ef&quot;, &quot;:&quot;)     = [&quot;&quot;, cd&quot;, &quot;ef&quot;]
   * StringUtils.splitPreserveAllTokens(&quot;::cd:ef&quot;, &quot;:&quot;)    = [&quot;&quot;, &quot;&quot;, cd&quot;, &quot;ef&quot;]
   * StringUtils.splitPreserveAllTokens(&quot;:cd:ef:&quot;, &quot;:&quot;)    = [&quot;&quot;, cd&quot;, &quot;ef&quot;, &quot;&quot;]
   * &lt;/pre&gt;
   *
   * @param str  the String to parse, may be &lt;code&gt;null&lt;/code&gt;
   * @param separatorChars  the characters used as the delimiters,
   *  &lt;code&gt;null&lt;/code&gt; splits on whitespace
   * @return an array of parsed Strings, &lt;code&gt;null&lt;/code&gt; if null String input
   * @since 2.1
   */
  public static String[] splitPreserveAllTokens(String str, String separatorChars) {
    return splitWorker(str, separatorChars, -1, true);
  }

  /**
   * &lt;p&gt;Splits the provided text into an array with a maximum length,
   * separators specified, preserving all tokens, including empty tokens 
   * created by adjacent separators.&lt;/p&gt;
   *
   * &lt;p&gt;The separator is not included in the returned String array.
   * Adjacent separators are treated as separators for empty tokens.
   * Adjacent separators are treated as one separator.&lt;/p&gt;
   *
   * &lt;p&gt;A &lt;code&gt;null&lt;/code&gt; input String returns &lt;code&gt;null&lt;/code&gt;.
   * A &lt;code&gt;null&lt;/code&gt; separatorChars splits on whitespace.&lt;/p&gt;
   *
   * &lt;p&gt;If more than &lt;code&gt;max&lt;/code&gt; delimited substrings are found, the last
   * returned string includes all characters after the first &lt;code&gt;max - 1&lt;/code&gt;
   * returned strings (including separator characters).&lt;/p&gt;
   *
   * &lt;pre&gt;
   * StringUtils.splitPreserveAllTokens(null, *, *)            = null
   * StringUtils.splitPreserveAllTokens(&quot;&quot;, *, *)              = []
   * StringUtils.splitPreserveAllTokens(&quot;ab de fg&quot;, null, 0)   = [&quot;ab&quot;, &quot;cd&quot;, &quot;ef&quot;]
   * StringUtils.splitPreserveAllTokens(&quot;ab   de fg&quot;, null, 0) = [&quot;ab&quot;, &quot;cd&quot;, &quot;ef&quot;]
   * StringUtils.splitPreserveAllTokens(&quot;ab:cd:ef&quot;, &quot;:&quot;, 0)    = [&quot;ab&quot;, &quot;cd&quot;, &quot;ef&quot;]
   * StringUtils.splitPreserveAllTokens(&quot;ab:cd:ef&quot;, &quot;:&quot;, 2)    = [&quot;ab&quot;, &quot;cd:ef&quot;]
   * StringUtils.splitPreserveAllTokens(&quot;ab   de fg&quot;, null, 2) = [&quot;ab&quot;, &quot;  de fg&quot;]
   * StringUtils.splitPreserveAllTokens(&quot;ab   de fg&quot;, null, 3) = [&quot;ab&quot;, &quot;&quot;, &quot; de fg&quot;]
   * StringUtils.splitPreserveAllTokens(&quot;ab   de fg&quot;, null, 4) = [&quot;ab&quot;, &quot;&quot;, &quot;&quot;, &quot;de fg&quot;]
   * &lt;/pre&gt;
   *
   * @param str  the String to parse, may be &lt;code&gt;null&lt;/code&gt;
   * @param separatorChars  the characters used as the delimiters,
   *  &lt;code&gt;null&lt;/code&gt; splits on whitespace
   * @param max  the maximum number of elements to include in the
   *  array. A zero or negative value implies no limit
   * @return an array of parsed Strings, &lt;code&gt;null&lt;/code&gt; if null String input
   * @since 2.1
   */
  public static String[] splitPreserveAllTokens(String str, String separatorChars, int max) {
    return splitWorker(str, separatorChars, max, true);
  }

  /**
   * Performs the logic for the &lt;code&gt;split&lt;/code&gt; and 
   * &lt;code&gt;splitPreserveAllTokens&lt;/code&gt; methods that return a maximum array 
   * length.
   *
   * @param str  the String to parse, may be &lt;code&gt;null&lt;/code&gt;
   * @param separatorChars the separate character
   * @param max  the maximum number of elements to include in the
   *  array. A zero or negative value implies no limit.
   * @param preserveAllTokens if &lt;code&gt;true&lt;/code&gt;, adjacent separators are
   * treated as empty token separators; if &lt;code&gt;false&lt;/code&gt;, adjacent
   * separators are treated as one separator.
   * @return an array of parsed Strings, &lt;code&gt;null&lt;/code&gt; if null String input
   */
  @SuppressWarnings(&quot;unchecked&quot;)
  private static String[] splitWorker(String str, String separatorChars, int max,
      boolean preserveAllTokens) {
    // Performance tuned for 2.0 (JDK1.4)
    // Direct code is quicker than StringTokenizer.
    // Also, StringTokenizer uses isSpace() not isWhitespace()

    if (str == null) {
      return null;
    }
    int len = str.length();
    if (len == 0) {
      return EMPTY_STRING_ARRAY;
    }
    List list = new ArrayList();
    int sizePlus1 = 1;
    int i = 0, start = 0;
    boolean match = false;
    boolean lastMatch = false;
    if (separatorChars == null) {
      // Null separator means use whitespace
      while (i &lt; len) {
        if (Character.isWhitespace(str.charAt(i))) {
          if (match || preserveAllTokens) {
            lastMatch = true;
            if (sizePlus1++ == max) {
              i = len;
              lastMatch = false;
            }
            list.add(str.substring(start, i));
            match = false;
          }
          start = ++i;
          continue;
        }
        lastMatch = false;
        match = true;
        i++;
      }
    } else if (separatorChars.length() == 1) {
      // Optimise 1 character case
      char sep = separatorChars.charAt(0);
      while (i &lt; len) {
        if (str.charAt(i) == sep) {
          if (match || preserveAllTokens) {
            lastMatch = true;
            if (sizePlus1++ == max) {
              i = len;
              lastMatch = false;
            }
            list.add(str.substring(start, i));
            match = false;
          }
          start = ++i;
          continue;
        }
        lastMatch = false;
        match = true;
        i++;
      }
    } else {
      // standard case
      while (i &lt; len) {
        if (separatorChars.indexOf(str.charAt(i)) &gt;= 0) {
          if (match || preserveAllTokens) {
            lastMatch = true;
            if (sizePlus1++ == max) {
              i = len;
              lastMatch = false;
            }
            list.add(str.substring(start, i));
            match = false;
          }
          start = ++i;
          continue;
        }
        lastMatch = false;
        match = true;
        i++;
      }
    }
    if (match || (preserveAllTokens &amp;&amp; lastMatch)) {
      list.add(str.substring(start, i));
    }
    return (String[]) list.toArray(new String[list.size()]);
  }

  // Joining
  //-----------------------------------------------------------------------

  /**
   * &lt;p&gt;Joins the elements of the provided array into a single String
   * containing the provided list of elements.&lt;/p&gt;
   *
   * &lt;p&gt;No separator is added to the joined String.
   * Null objects or empty strings within the array are represented by
   * empty strings.&lt;/p&gt;
   *
   * &lt;pre&gt;
   * StringUtils.join(null)            = null
   * StringUtils.join([])              = &quot;&quot;
   * StringUtils.join([null])          = &quot;&quot;
   * StringUtils.join([&quot;a&quot;, &quot;b&quot;, &quot;c&quot;]) = &quot;abc&quot;
   * StringUtils.join([null, &quot;&quot;, &quot;a&quot;]) = &quot;a&quot;
   * &lt;/pre&gt;
   *
   * @param array  the array of values to join together, may be null
   * @return the joined String, &lt;code&gt;null&lt;/code&gt; if null array input
   * @since 2.0
   */
  public static String join(Object[] array) {
    return join(array, null);
  }

  /**
   * &lt;p&gt;Joins the elements of the provided array into a single String
   * containing the provided list of elements.&lt;/p&gt;
   *
   * &lt;p&gt;No delimiter is added before or after the list.
   * Null objects or empty strings within the array are represented by
   * empty strings.&lt;/p&gt;
   *
   * &lt;pre&gt;
   * StringUtils.join(null, *)               = null
   * StringUtils.join([], *)                 = &quot;&quot;
   * StringUtils.join([null], *)             = &quot;&quot;
   * StringUtils.join([&quot;a&quot;, &quot;b&quot;, &quot;c&quot;], ';')  = &quot;a;b;c&quot;
   * StringUtils.join([&quot;a&quot;, &quot;b&quot;, &quot;c&quot;], null) = &quot;abc&quot;
   * StringUtils.join([null, &quot;&quot;, &quot;a&quot;], ';')  = &quot;;;a&quot;
   * &lt;/pre&gt;
   *
   * @param array  the array of values to join together, may be null
   * @param separator  the separator character to use
   * @return the joined String, &lt;code&gt;null&lt;/code&gt; if null array input
   * @since 2.0
   */
  public static String join(Object[] array, char separator) {
    if (array == null) {
      return null;
    }
    int arraySize = array.length;
    int bufSize = (arraySize == 0 ? 0 : ((array[0] == null ? 16 : array[0].toString()
        .length()) + 1)
        * arraySize);
    StringBuffer buf = new StringBuffer(bufSize);

    for (int i = 0; i &lt; arraySize; i++) {
      if (i &gt; 0) {
        buf.append(separator);
      }
      if (array[i] != null) {
        buf.append(array[i]);
      }
    }
    return buf.toString();
  }

  /**
   * &lt;p&gt;Joins the elements of the provided array into a single String
   * containing the provided list of elements.&lt;/p&gt;
   *
   * &lt;p&gt;No delimiter is added before or after the list.
   * A &lt;code&gt;null&lt;/code&gt; separator is the same as an empty String (&quot;&quot;).
   * Null objects or empty strings within the array are represented by
   * empty strings.&lt;/p&gt;
   *
   * &lt;pre&gt;
   * StringUtils.join(null, *)                = null
   * StringUtils.join([], *)                  = &quot;&quot;
   * StringUtils.join([null], *)              = &quot;&quot;
   * StringUtils.join([&quot;a&quot;, &quot;b&quot;, &quot;c&quot;], &quot;--&quot;)  = &quot;a--b--c&quot;
   * StringUtils.join([&quot;a&quot;, &quot;b&quot;, &quot;c&quot;], null)  = &quot;abc&quot;
   * StringUtils.join([&quot;a&quot;, &quot;b&quot;, &quot;c&quot;], &quot;&quot;)    = &quot;abc&quot;
   * StringUtils.join([null, &quot;&quot;, &quot;a&quot;], ',')   = &quot;,,a&quot;
   * &lt;/pre&gt;
   *
   * @param array  the array of values to join together, may be null
   * @param separator  the separator character to use, null treated as &quot;&quot;
   * @return the joined String, &lt;code&gt;null&lt;/code&gt; if null array input
   */
  public static String join(Object[] array, String separator) {
    if (array == null) {
      return null;
    }
    if (separator == null) {
      separator = &quot;&quot;;
    }
    int arraySize = array.length;

    // ArraySize ==  0: Len = 0
    // ArraySize &gt; 0:   Len = NofStrings *(len(firstString) + len(separator))
    //           (Assuming that all Strings are roughly equally long)
    int bufSize = ((arraySize == 0) ? 0 : arraySize
        * ((array[0] == null ? 16 : array[0].toString().length()) + separator.length()));

    StringBuffer buf = new StringBuffer(bufSize);

    for (int i = 0; i &lt; arraySize; i++) {
      if (i &gt; 0) {
        buf.append(separator);
      }
      if (array[i] != null) {
        buf.append(array[i]);
      }
    }
    return buf.toString();
  }

  /**
   * &lt;p&gt;Joins the elements of the provided &lt;code&gt;Iterator&lt;/code&gt; into
   * a single String containing the provided elements.&lt;/p&gt;
   *
   * &lt;p&gt;No delimiter is added before or after the list. Null objects or empty
   * strings within the iteration are represented by empty strings.&lt;/p&gt;
   *
   * &lt;p&gt;See the examples here: {@link #join(Object[],char)}. &lt;/p&gt;
   *
   * @param iterator  the &lt;code&gt;Iterator&lt;/code&gt; of values to join together, may be null
   * @param separator  the separator character to use
   * @return the joined String, &lt;code&gt;null&lt;/code&gt; if null iterator input
   * @since 2.0
   */
  public static String join(Iterator iterator, char separator) {
    if (iterator == null) {
      return null;
    }
    StringBuffer buf = new StringBuffer(256); // Java default is 16, probably too small
    while (iterator.hasNext()) {
      Object obj = iterator.next();
      if (obj != null) {
        buf.append(obj);
      }
      if (iterator.hasNext()) {
        buf.append(separator);
      }
    }
    return buf.toString();
  }

  /**
   * &lt;p&gt;Joins the elements of the provided &lt;code&gt;Iterator&lt;/code&gt; into
   * a single String containing the provided elements.&lt;/p&gt;
   *
   * &lt;p&gt;No delimiter is added before or after the list.
   * A &lt;code&gt;null&lt;/code&gt; separator is the same as an empty String (&quot;&quot;).&lt;/p&gt;
   *
   * &lt;p&gt;See the examples here: {@link #join(Object[],String)}. &lt;/p&gt;
   *
   * @param iterator  the &lt;code&gt;Iterator&lt;/code&gt; of values to join together, may be null
   * @param separator  the separator character to use, null treated as &quot;&quot;
   * @return the joined String, &lt;code&gt;null&lt;/code&gt; if null iterator input
   */
  public static String join(Iterator iterator, String separator) {
    if (iterator == null) {
      return null;
    }
    StringBuffer buf = new StringBuffer(256); // Java default is 16, probably too small
    while (iterator.hasNext()) {
      Object obj = iterator.next();
      if (obj != null) {
        buf.append(obj);
      }
      if ((separator != null) &amp;&amp; iterator.hasNext()) {
        buf.append(separator);
      }
    }
    return buf.toString();
  }

  /**
   * &lt;p&gt;Returns either the passed in String,
   * or if the String is &lt;code&gt;null&lt;/code&gt;, an empty String (&quot;&quot;).&lt;/p&gt;
   *
   * &lt;pre&gt;
   * StringUtils.defaultString(null)  = &quot;&quot;
   * StringUtils.defaultString(&quot;&quot;)    = &quot;&quot;
   * StringUtils.defaultString(&quot;bat&quot;) = &quot;bat&quot;
   * &lt;/pre&gt;
   *
   * @see String#valueOf(Object)
   * @param str  the String to check, may be null
   * @return the passed in String, or the empty String if it
   *  was &lt;code&gt;null&lt;/code&gt;
   */
  public static String defaultString(String str) {
    return str == null ? &quot;&quot; : str;
  }

  /**
   * &lt;p&gt;Returns either the passed in String, or if the String is
   * &lt;code&gt;null&lt;/code&gt;, the value of &lt;code&gt;defaultStr&lt;/code&gt;.&lt;/p&gt;
   *
   * &lt;pre&gt;
   * StringUtils.defaultString(null, &quot;NULL&quot;)  = &quot;NULL&quot;
   * StringUtils.defaultString(&quot;&quot;, &quot;NULL&quot;)    = &quot;&quot;
   * StringUtils.defaultString(&quot;bat&quot;, &quot;NULL&quot;) = &quot;bat&quot;
   * &lt;/pre&gt;
   *
   * @see String#valueOf(Object)
   * @param str  the String to check, may be null
   * @param defaultStr  the default String to return
   *  if the input is &lt;code&gt;null&lt;/code&gt;, may be null
   * @return the passed in String, or the default if it was &lt;code&gt;null&lt;/code&gt;
   */
  public static String defaultString(String str, String defaultStr) {
    return str == null ? defaultStr : str;
  }

  /**
   * &lt;p&gt;Returns either the passed in String, or if the String is
   * empty or &lt;code&gt;null&lt;/code&gt;, the value of &lt;code&gt;defaultStr&lt;/code&gt;.&lt;/p&gt;
   *
   * &lt;pre&gt;
   * StringUtils.defaultIfEmpty(null, &quot;NULL&quot;)  = &quot;NULL&quot;
   * StringUtils.defaultIfEmpty(&quot;&quot;, &quot;NULL&quot;)    = &quot;NULL&quot;
   * StringUtils.defaultIfEmpty(&quot;bat&quot;, &quot;NULL&quot;) = &quot;bat&quot;
   * &lt;/pre&gt;
   *
   * @param str  the String to check, may be null
   * @param defaultStr  the default String to return
   *  if the input is empty (&quot;&quot;) or &lt;code&gt;null&lt;/code&gt;, may be null
   * @return the passed in String, or the default
   */
  public static String defaultIfEmpty(String str, String defaultStr) {
    return isEmpty(str) ? defaultStr : str;
  }

  /**
   * &lt;p&gt;Capitalizes a String changing the first letter to title case as
   * per {@link Character#toTitleCase(char)}. No other letters are changed.&lt;/p&gt;
   *
   * A &lt;code&gt;null&lt;/code&gt; input String returns &lt;code&gt;null&lt;/code&gt;.&lt;/p&gt;
   *
   * &lt;pre&gt;
   * StringUtils.capitalize(null)  = null
   * StringUtils.capitalize(&quot;&quot;)    = &quot;&quot;
   * StringUtils.capitalize(&quot;cat&quot;) = &quot;Cat&quot;
   * StringUtils.capitalize(&quot;cAt&quot;) = &quot;CAt&quot;
   * &lt;/pre&gt;
   *
   * @param str  the String to capitalize, may be null
   * @return the capitalized String, &lt;code&gt;null&lt;/code&gt; if null String input
   * @since 2.0
   */
  public static String capitalize(String str) {
    int strLen;
    if (str == null || (strLen = str.length()) == 0) {
      return str;
    }
    return new StringBuffer(strLen).append(Character.toTitleCase(str.charAt(0))).append(
        str.substring(1)).toString();
  }

  /**
   * &lt;p&gt;Checks if String contains a search character, handling &lt;code&gt;null&lt;/code&gt;.
   * This method uses {@link String#indexOf(int)}.&lt;/p&gt;
   *
   * &lt;p&gt;A &lt;code&gt;null&lt;/code&gt; or empty (&quot;&quot;) String will return &lt;code&gt;false&lt;/code&gt;.&lt;/p&gt;
   *
   * &lt;pre&gt;
   * StringUtils.contains(null, *)    = false
   * StringUtils.contains(&quot;&quot;, *)      = false
   * StringUtils.contains(&quot;abc&quot;, 'a') = true
   * StringUtils.contains(&quot;abc&quot;, 'z') = false
   * &lt;/pre&gt;
   *
   * @param str  the String to check, may be null
   * @param searchChar  the character to find
   * @return true if the String contains the search character,
   *  false if not or &lt;code&gt;null&lt;/code&gt; string input
   * @since 2.0
   */
  public static boolean contains(String str, char searchChar) {
    if (isEmpty(str)) {
      return false;
    }
    return str.indexOf(searchChar) &gt;= 0;
  }

  /**
   * &lt;p&gt;Checks if String contains a search String, handling &lt;code&gt;null&lt;/code&gt;.
   * This method uses {@link String#indexOf(int)}.&lt;/p&gt;
   *
   * &lt;p&gt;A &lt;code&gt;null&lt;/code&gt; String will return &lt;code&gt;false&lt;/code&gt;.&lt;/p&gt;
   *
   * &lt;pre&gt;
   * StringUtils.contains(null, *)     = false
   * StringUtils.contains(*, null)     = false
   * StringUtils.contains(&quot;&quot;, &quot;&quot;)      = true
   * StringUtils.contains(&quot;abc&quot;, &quot;&quot;)   = true
   * StringUtils.contains(&quot;abc&quot;, &quot;a&quot;)  = true
   * StringUtils.contains(&quot;abc&quot;, &quot;z&quot;)  = false
   * &lt;/pre&gt;
   *
   * @param str  the String to check, may be null
   * @param searchStr  the String to find, may be null
   * @return true if the String contains the search String,
   *  false if not or &lt;code&gt;null&lt;/code&gt; string input
   * @since 2.0
   */
  public static boolean contains(String str, String searchStr) {
    if (str == null || searchStr == null) {
      return false;
    }
    return str.indexOf(searchStr) &gt;= 0;
  }
  
  /**
   * An empty immutable &lt;code&gt;String&lt;/code&gt; array.
   */
  public static final String[] EMPTY_STRING_ARRAY = new String[0];

  /**
   * &lt;p&gt;Compares two objects for equality, where either one or both
   * objects may be &lt;code&gt;null&lt;/code&gt;.&lt;/p&gt;
   *
   * &lt;pre&gt;
   * ObjectUtils.equals(null, null)                  = true
   * ObjectUtils.equals(null, &quot;&quot;)                    = false
   * ObjectUtils.equals(&quot;&quot;, null)                    = false
   * ObjectUtils.equals(&quot;&quot;, &quot;&quot;)                      = true
   * ObjectUtils.equals(Boolean.TRUE, null)          = false
   * ObjectUtils.equals(Boolean.TRUE, &quot;true&quot;)        = false
   * ObjectUtils.equals(Boolean.TRUE, Boolean.TRUE)  = true
   * ObjectUtils.equals(Boolean.TRUE, Boolean.FALSE) = false
   * &lt;/pre&gt;
   *
   * @param object1  the first object, may be &lt;code&gt;null&lt;/code&gt;
   * @param object2  the second object, may be &lt;code&gt;null&lt;/code&gt;
   * @return &lt;code&gt;true&lt;/code&gt; if the values of both objects are the same
   */
  public static boolean equals(Object object1, Object object2) {
      if (object1 == object2) {
          return true;
      }
      if ((object1 == null) || (object2 == null)) {
          return false;
      }
      return object1.equals(object2);
  }

  /**
   * &lt;p&gt;A way to get the entire nested stack-trace of an throwable.&lt;/p&gt;
   *
   * @param throwable  the &lt;code&gt;Throwable&lt;/code&gt; to be examined
   * @return the nested stack trace, with the root cause first
   * @since 2.0
   */
  public static String getFullStackTrace(Throwable throwable) {
      StringWriter sw = new StringWriter();
      PrintWriter pw = new PrintWriter(sw, true);
      Throwable[] ts = getThrowables(throwable);
      for (int i = 0; i &lt; ts.length; i++) {
          ts[i].printStackTrace(pw);
          if (isNestedThrowable(ts[i])) {
              break;
          }
      }
      return sw.getBuffer().toString();
  }
  /**
   * &lt;p&gt;Returns the list of &lt;code&gt;Throwable&lt;/code&gt; objects in the
   * exception chain.&lt;/p&gt;
   * 
   * &lt;p&gt;A throwable without cause will return an array containing
   * one element - the input throwable.
   * A throwable with one cause will return an array containing
   * two elements. - the input throwable and the cause throwable.
   * A &lt;code&gt;null&lt;/code&gt; throwable will return an array size zero.&lt;/p&gt;
   *
   * @param throwable  the throwable to inspect, may be null
   * @return the array of throwables, never null
   */
  @SuppressWarnings(&quot;unchecked&quot;)
  public static Throwable[] getThrowables(Throwable throwable) {
      List list = new ArrayList();
      while (throwable != null) {
          list.add(throwable);
          throwable = getCause(throwable);
      }
      return (Throwable[]) list.toArray(new Throwable[list.size()]);
  }
  
  /**
   * &lt;p&gt;The names of methods commonly used to access a wrapped exception.&lt;/p&gt;
   */
  private static String[] CAUSE_METHOD_NAMES = {
      &quot;getCause&quot;,
      &quot;getNextException&quot;,
      &quot;getTargetException&quot;,
      &quot;getException&quot;,
      &quot;getSourceException&quot;,
      &quot;getRootCause&quot;,
      &quot;getCausedByException&quot;,
      &quot;getNested&quot;,
      &quot;getLinkedException&quot;,
      &quot;getNestedException&quot;,
      &quot;getLinkedCause&quot;,
      &quot;getThrowable&quot;,
  };

  /**
   * &lt;p&gt;Checks whether this &lt;code&gt;Throwable&lt;/code&gt; class can store a cause.&lt;/p&gt;
   * 
   * &lt;p&gt;This method does &lt;b&gt;not&lt;/b&gt; check whether it actually does store a cause.&lt;p&gt;
   *
   * @param throwable  the &lt;code&gt;Throwable&lt;/code&gt; to examine, may be null
   * @return boolean &lt;code&gt;true&lt;/code&gt; if nested otherwise &lt;code&gt;false&lt;/code&gt;
   * @since 2.0
   */
  public static boolean isNestedThrowable(Throwable throwable) {
      if (throwable == null) {
          return false;
      }

      if (throwable instanceof SQLException) {
          return true;
      } else if (throwable instanceof InvocationTargetException) {
          return true;
      } else if (isThrowableNested()) {
          return true;
      }

      Class cls = throwable.getClass();
      for (int i = 0, isize = CAUSE_METHOD_NAMES.length; i &lt; isize; i++) {
          try {
              Method method = cls.getMethod(CAUSE_METHOD_NAMES[i], (Class[])null);
              if (method != null &amp;&amp; Throwable.class.isAssignableFrom(method.getReturnType())) {
                  return true;
              }
          } catch (NoSuchMethodException ignored) {
          } catch (SecurityException ignored) {
          }
      }

      try {
          Field field = cls.getField(&quot;detail&quot;);
          if (field != null) {
              return true;
          }
      } catch (NoSuchFieldException ignored) {
      } catch (SecurityException ignored) {
      }

      return false;
  }

  /**
   * &lt;p&gt;The Method object for JDK1.4 getCause.&lt;/p&gt;
   */
  private static final Method THROWABLE_CAUSE_METHOD;
  static {
      Method getCauseMethod;
      try {
          getCauseMethod = Throwable.class.getMethod(&quot;getCause&quot;, (Class[])null);
      } catch (Exception e) {
          getCauseMethod = null;
      }
      THROWABLE_CAUSE_METHOD = getCauseMethod;
  }
  
  /**
   * &lt;p&gt;Checks if the Throwable class has a &lt;code&gt;getCause&lt;/code&gt; method.&lt;/p&gt;
   * 
   * &lt;p&gt;This is true for JDK 1.4 and above.&lt;/p&gt;
   * 
   * @return true if Throwable is nestable
   * @since 2.0
   */
  public static boolean isThrowableNested() {
      return THROWABLE_CAUSE_METHOD != null;
  }

  /**
   * &lt;p&gt;Introspects the &lt;code&gt;Throwable&lt;/code&gt; to obtain the cause.&lt;/p&gt;
   * 
   * &lt;p&gt;The method searches for methods with specific names that return a 
   * &lt;code&gt;Throwable&lt;/code&gt; object. This will pick up most wrapping exceptions,
   * including those from JDK 1.4, and&lt;/p&gt;
   *
   * &lt;p&gt;The default list searched for are:&lt;/p&gt;
   * &lt;ul&gt;
   *  &lt;li&gt;&lt;code&gt;getCause()&lt;/code&gt;&lt;/li&gt;
   *  &lt;li&gt;&lt;code&gt;getNextException()&lt;/code&gt;&lt;/li&gt;
   *  &lt;li&gt;&lt;code&gt;getTargetException()&lt;/code&gt;&lt;/li&gt;
   *  &lt;li&gt;&lt;code&gt;getException()&lt;/code&gt;&lt;/li&gt;
   *  &lt;li&gt;&lt;code&gt;getSourceException()&lt;/code&gt;&lt;/li&gt;
   *  &lt;li&gt;&lt;code&gt;getRootCause()&lt;/code&gt;&lt;/li&gt;
   *  &lt;li&gt;&lt;code&gt;getCausedByException()&lt;/code&gt;&lt;/li&gt;
   *  &lt;li&gt;&lt;code&gt;getNested()&lt;/code&gt;&lt;/li&gt;
   * &lt;/ul&gt;
   * 
   * &lt;p&gt;In the absence of any such method, the object is inspected for a
   * &lt;code&gt;detail&lt;/code&gt; field assignable to a &lt;code&gt;Throwable&lt;/code&gt;.&lt;/p&gt;
   * 
   * &lt;p&gt;If none of the above is found, returns &lt;code&gt;null&lt;/code&gt;.&lt;/p&gt;
   *
   * @param throwable  the throwable to introspect for a cause, may be null
   * @return the cause of the &lt;code&gt;Throwable&lt;/code&gt;,
   *  &lt;code&gt;null&lt;/code&gt; if none found or null throwable input
   * @since 1.0
   */
  public static Throwable getCause(Throwable throwable) {
      return getCause(throwable, CAUSE_METHOD_NAMES);
  }

  /**
   * &lt;p&gt;Introspects the &lt;code&gt;Throwable&lt;/code&gt; to obtain the cause.&lt;/p&gt;
   * 
   * &lt;ol&gt;
   * &lt;li&gt;Try known exception types.&lt;/li&gt;
   * &lt;li&gt;Try the supplied array of method names.&lt;/li&gt;
   * &lt;li&gt;Try the field 'detail'.&lt;/li&gt;
   * &lt;/ol&gt;
   * 
   * &lt;p&gt;A &lt;code&gt;null&lt;/code&gt; set of method names means use the default set.
   * A &lt;code&gt;null&lt;/code&gt; in the set of method names will be ignored.&lt;/p&gt;
   *
   * @param throwable  the throwable to introspect for a cause, may be null
   * @param methodNames  the method names, null treated as default set
   * @return the cause of the &lt;code&gt;Throwable&lt;/code&gt;,
   *  &lt;code&gt;null&lt;/code&gt; if none found or null throwable input
   * @since 1.0
   */
  public static Throwable getCause(Throwable throwable, String[] methodNames) {
      if (throwable == null) {
          return null;
      }
      Throwable cause = getCauseUsingWellKnownTypes(throwable);
      if (cause == null) {
          if (methodNames == null) {
              methodNames = CAUSE_METHOD_NAMES;
          }
          for (int i = 0; i &lt; methodNames.length; i++) {
              String methodName = methodNames[i];
              if (methodName != null) {
                  cause = getCauseUsingMethodName(throwable, methodName);
                  if (cause != null) {
                      break;
                  }
              }
          }

          if (cause == null) {
              cause = getCauseUsingFieldName(throwable, &quot;detail&quot;);
          }
      }
      return cause;
  }

  /**
   * &lt;p&gt;Finds a &lt;code&gt;Throwable&lt;/code&gt; by method name.&lt;/p&gt;
   * 
   * @param throwable  the exception to examine
   * @param methodName  the name of the method to find and invoke
   * @return the wrapped exception, or &lt;code&gt;null&lt;/code&gt; if not found
   */
  private static Throwable getCauseUsingMethodName(Throwable throwable, String methodName) {
      Method method = null;
      try {
          method = throwable.getClass().getMethod(methodName, (Class[])null);
      } catch (NoSuchMethodException ignored) {
      } catch (SecurityException ignored) {
      }

      if (method != null &amp;&amp; Throwable.class.isAssignableFrom(method.getReturnType())) {
          try {
              return (Throwable) method.invoke(throwable, EMPTY_OBJECT_ARRAY);
          } catch (IllegalAccessException ignored) {
          } catch (IllegalArgumentException ignored) {
          } catch (InvocationTargetException ignored) {
          }
      }
      return null;
  }

  /**
   * &lt;p&gt;Finds a &lt;code&gt;Throwable&lt;/code&gt; by field name.&lt;/p&gt;
   * 
   * @param throwable  the exception to examine
   * @param fieldName  the name of the attribute to examine
   * @return the wrapped exception, or &lt;code&gt;null&lt;/code&gt; if not found
   */
  private static Throwable getCauseUsingFieldName(Throwable throwable, String fieldName) {
      Field field = null;
      try {
          field = throwable.getClass().getField(fieldName);
      } catch (NoSuchFieldException ignored) {
      } catch (SecurityException ignored) {
      }

      if (field != null &amp;&amp; Throwable.class.isAssignableFrom(field.getType())) {
          try {
              return (Throwable) field.get(throwable);
          } catch (IllegalAccessException ignored) {
          } catch (IllegalArgumentException ignored) {
          }
      }
      return null;
  }

  /**
   * &lt;p&gt;Finds a &lt;code&gt;Throwable&lt;/code&gt; for known types.&lt;/p&gt;
   * 
   * &lt;p&gt;Uses &lt;code&gt;instanceof&lt;/code&gt; checks to examine the exception,
   * looking for well known types which could contain chained or
   * wrapped exceptions.&lt;/p&gt;
   *
   * @param throwable  the exception to examine
   * @return the wrapped exception, or &lt;code&gt;null&lt;/code&gt; if not found
   */
  private static Throwable getCauseUsingWellKnownTypes(Throwable throwable) {
      if (throwable instanceof SQLException) {
          return ((SQLException) throwable).getNextException();
      } else if (throwable instanceof InvocationTargetException) {
          return ((InvocationTargetException) throwable).getTargetException();
      } else {
          return null;
      }
  }

  /**
   * An empty immutable &lt;code&gt;Object&lt;/code&gt; array.
   */
  public static final Object[] EMPTY_OBJECT_ARRAY = new Object[0];
  
  /** 
   * from a command line arg, get the key.  e.g. if input is --whatever=something
   * then key is whatever, value is something 
   * @param option 
   * @return the key */
  public static String argKey(String option) {
    int equalsIndex = option.indexOf(&quot;=&quot;);
    if (equalsIndex == -1) {
      throw new RuntimeException(&quot;Invalid option: &quot; + option + &quot;, it should look like: --someOption=someValue&quot;);
    }
    String key = option.substring(0,equalsIndex);
    if (!key.startsWith(&quot;--&quot;)) {
      throw new RuntimeException(&quot;Invalid option: &quot; + option + &quot;, it should look like: --someOption=someValue&quot;);
    }
    key = key.substring(2);
    return key;
  }

  /** 
   * from a command line arg, get the key.  e.g. if input is --whatever=something
   * then key is whatever, value is something 
   * @param option 
   * @return the value
   */
  public static String argValue(String option) {
    int equalsIndex = option.indexOf(&quot;=&quot;);
    if (equalsIndex == -1) {
      throw new RuntimeException(&quot;Invalid option: &quot; + option + &quot;, it should look like: --someOption=someValue&quot;);
    }
    String value = option.substring(equalsIndex+1, option.length());
    return value;
  }
  
  /** add an option: --whatever=val   to a map of options where --whatever is key, and val is value 
   * @param args 
   * @return the map
   */
  public static Map&lt;String, String&gt; argMap(String[] args) {
    
    Map&lt;String, String&gt; result = new LinkedHashMap&lt;String, String&gt;();

    for (String arg : nonNull(args,String.class)) {
      String key = argKey(arg);
      String value = argValue(arg);
      if (result.containsKey(key)) {
        throw new RuntimeException(&quot;Passing key twice: &quot; + key);
      }
      result.put(key, value);
    }
    
    return result;
  }
  
  /**
   * get the value from the argMap, throw exception if not there and required
   * @param argMap
   * @param argMapNotUsed 
   * @param key
   * @param required
   * @return the value or null or exception
   */
  public static String argMapString(Map&lt;String, String&gt; argMap, Map&lt;String, String&gt; argMapNotUsed, 
      String key, boolean required) {

    if (argMap.containsKey(key)) {
      
      //keep track that this is gone
      argMapNotUsed.remove(key);
      
      return argMap.get(key);
    }
    if (required) {
      throw new RuntimeException(&quot;Argument '--&quot; + key + &quot;' is required, but not specified.  e.g. --&quot; + key + &quot;=value&quot;);
    }
    return null;

  }
  
  /**
   * get the value from the argMap, throw exception if not there and required
   * @param argMap
   * @param argMapNotUsed 
   * @param key
   * @param required
   * @param defaultValue 
   * @return the value or null or exception
   */
  public static boolean argMapBoolean(Map&lt;String, String&gt; argMap, Map&lt;String, String&gt; argMapNotUsed, 
      String key, boolean required, boolean defaultValue) {
    String argString = argMapString(argMap, argMapNotUsed, key, required);

    if (isBlank(argString) &amp;&amp; required) {
      throw new RuntimeException(&quot;Argument '--&quot; + key + &quot;' is required, but not specified.  e.g. --&quot; + key + &quot;=true&quot;);
    }
    return booleanValue(argString, defaultValue);
  }
  
  /**
   * get the value from the argMap, throw exception if not there and required
   * @param argMap
   * @param argMapNotUsed 
   * @param key
   * @return the value or null or exception
   */
  public static Timestamp argMapTimestamp(Map&lt;String, String&gt; argMap, Map&lt;String, String&gt; argMapNotUsed, 
      String key) {
    String argString = argMapString(argMap, argMapNotUsed, key, false);
    if (isBlank(argString)) {
      return null;
    }
    Date date = stringToDate2(argString);
    return new Timestamp(date.getTime());
  }
  
  /**
   * get the value from the argMap
   * @param argMap
   * @param argMapNotUsed 
   * @param key
   * @return the value or null or exception
   */
  public static Boolean argMapBoolean(Map&lt;String, String&gt; argMap, Map&lt;String, String&gt; argMapNotUsed, 
      String key) {
    String argString = argMapString(argMap, argMapNotUsed, key, false);

    return booleanObjectValue(argString);
  }
  
  /**
   * get the set from comma separated from the argMap, throw exception if not there and required
   * @param argMap
   * @param argMapNotUsed 
   * @param key
   * @param required
   * @return the value or null or exception
   */
  public static Set&lt;String&gt; argMapSet(Map&lt;String, String&gt; argMap, Map&lt;String, String&gt; argMapNotUsed, 
      String key, boolean required) {
    List&lt;String&gt; list = argMapList(argMap, argMapNotUsed, key, required);
    return list == null ? null : new LinkedHashSet(list);
  }
  
  /**
   * get the list from comma separated from the argMap, throw exception if not there and required
   * @param argMap
   * @param argMapNotUsed 
   * @param key
   * @param required
   * @return the value or null or exception
   */
  public static List&lt;String&gt; argMapList(Map&lt;String, String&gt; argMap, Map&lt;String, String&gt; argMapNotUsed, 
      String key, boolean required) {
    String argString = argMapString(argMap, argMapNotUsed, key, required);
    if (isBlank(argString)) {
      return null;
    }
    return splitTrimToList(argString, &quot;,&quot;);
  }
  
  /**
   * get the list from comma separated from the argMap, throw exception if not there and required
   * @param argMap
   * @param argMapNotUsed 
   * @param key
   * @param required
   * @return the value or null or exception
   */
  public static List&lt;String&gt; argMapFileList(Map&lt;String, String&gt; argMap, Map&lt;String, String&gt; argMapNotUsed, 
      String key, boolean required) {
    String argString = argMapString(argMap, argMapNotUsed, key, required);
    if (isBlank(argString)) {
      return null;
    }
    //read from file
    File file = new File(argString);
    try {
      //do this by regex, since we dont know what platform we are on
      String listString = readFileIntoString(file);
      String[] array = listString.split(&quot;\\s+&quot;);
      List&lt;String&gt; list = new ArrayList&lt;String&gt;();
      for (String string : array) {
        //dont know if any here will be blank or whatnot
        if (!isBlank(string)) {
          //should already be trimmed, but just in case
          list.add(trim(string));
        }
      }
      return list;
    } catch (Exception e) {
      throw new RuntimeException(&quot;Error reading file: '&quot; 
          + fileCanonicalPath(file) + &quot;' from command line arg: &quot; + key, e );
    }
  }
  
  /**
   * Copy bytes from an &lt;code&gt;InputStream&lt;/code&gt; to chars on a
   * &lt;code&gt;Writer&lt;/code&gt; using the default character encoding of the platform.
   * &lt;p&gt;
   * This method buffers the input internally, so there is no need to use a
   * &lt;code&gt;BufferedInputStream&lt;/code&gt;.
   * &lt;p&gt;
   * This method uses {@link InputStreamReader}.
   *
   * @param input  the &lt;code&gt;InputStream&lt;/code&gt; to read from
   * @param output  the &lt;code&gt;Writer&lt;/code&gt; to write to
   * @throws NullPointerException if the input or output is null
   * @throws IOException if an I/O error occurs
   * @since Commons IO 1.1
   */
  public static void copy(InputStream input, Writer output)</pre></div></td></tr></table>
<table border="0" class="bodyTable">
<tr class="a">
<th>File</th>
<th>Line</th></tr>
<tr class="b">
<td>edu\internet2\middleware\grouperClient\config\ConfigPropertiesCascadeCommonUtils.java</td>
<td><a href="./xref/edu/internet2/middleware/grouperClient/config/ConfigPropertiesCascadeCommonUtils.html#L7782">7782</a></td></tr>
<tr class="a">
<td>edu\internet2\middleware\grouperClient\util\GrouperClientCommonUtils.java</td>
<td><a href="./xref/edu/internet2/middleware/grouperClient/util/GrouperClientCommonUtils.html#L7885">7885</a></td></tr>
<tr class="b"><td colspan='2'>
<div>
<pre>    System.err.println(&quot;Grouper error: &quot; + error);
    return false;

  }

  /**
   * &lt;p&gt;Strips any of a set of characters from the start of a String.&lt;/p&gt;
   *
   * &lt;p&gt;A &lt;code&gt;null&lt;/code&gt; input String returns &lt;code&gt;null&lt;/code&gt;.
   * An empty string (&quot;&quot;) input returns the empty string.&lt;/p&gt;
   *
   * &lt;p&gt;If the stripChars String is &lt;code&gt;null&lt;/code&gt;, whitespace is
   * stripped as defined by {@link Character#isWhitespace(char)}.&lt;/p&gt;
   *
   * &lt;pre&gt;
   * StringUtils.stripStart(null, *)          = null
   * StringUtils.stripStart(&quot;&quot;, *)            = &quot;&quot;
   * StringUtils.stripStart(&quot;abc&quot;, &quot;&quot;)        = &quot;abc&quot;
   * StringUtils.stripStart(&quot;abc&quot;, null)      = &quot;abc&quot;
   * StringUtils.stripStart(&quot;  abc&quot;, null)    = &quot;abc&quot;
   * StringUtils.stripStart(&quot;abc  &quot;, null)    = &quot;abc  &quot;
   * StringUtils.stripStart(&quot; abc &quot;, null)    = &quot;abc &quot;
   * StringUtils.stripStart(&quot;yxabc  &quot;, &quot;xyz&quot;) = &quot;abc  &quot;
   * &lt;/pre&gt;
   *
   * @param str  the String to remove characters from, may be null
   * @param stripChars  the characters to remove, null treated as whitespace
   * @return the stripped String, &lt;code&gt;null&lt;/code&gt; if null String input
   */
  public static String stripStart(String str, String stripChars) {
    int strLen;
    if (str == null || (strLen = str.length()) == 0) {
      return str;
    }
    int start = 0;
    if (stripChars == null) {
      while ((start != strLen) &amp;&amp; Character.isWhitespace(str.charAt(start))) {
        start++;
      }
    } else if (stripChars.length() == 0) {
      return str;
    } else {
      while ((start != strLen) &amp;&amp; (stripChars.indexOf(str.charAt(start)) != -1)) {
        start++;
      }
    }
    return str.substring(start);
  }

  /**
   * &lt;p&gt;Strips any of a set of characters from the end of a String.&lt;/p&gt;
   *
   * &lt;p&gt;A &lt;code&gt;null&lt;/code&gt; input String returns &lt;code&gt;null&lt;/code&gt;.
   * An empty string (&quot;&quot;) input returns the empty string.&lt;/p&gt;
   *
   * &lt;p&gt;If the stripChars String is &lt;code&gt;null&lt;/code&gt;, whitespace is
   * stripped as defined by {@link Character#isWhitespace(char)}.&lt;/p&gt;
   *
   * &lt;pre&gt;
   * StringUtils.stripEnd(null, *)          = null
   * StringUtils.stripEnd(&quot;&quot;, *)            = &quot;&quot;
   * StringUtils.stripEnd(&quot;abc&quot;, &quot;&quot;)        = &quot;abc&quot;
   * StringUtils.stripEnd(&quot;abc&quot;, null)      = &quot;abc&quot;
   * StringUtils.stripEnd(&quot;  abc&quot;, null)    = &quot;  abc&quot;
   * StringUtils.stripEnd(&quot;abc  &quot;, null)    = &quot;abc&quot;
   * StringUtils.stripEnd(&quot; abc &quot;, null)    = &quot; abc&quot;
   * StringUtils.stripEnd(&quot;  abcyx&quot;, &quot;xyz&quot;) = &quot;  abc&quot;
   * &lt;/pre&gt;
   *
   * @param str  the String to remove characters from, may be null
   * @param stripChars  the characters to remove, null treated as whitespace
   * @return the stripped String, &lt;code&gt;null&lt;/code&gt; if null String input
   */
  public static String stripEnd(String str, String stripChars) {
    int end;
    if (str == null || (end = str.length()) == 0) {
      return str;
    }

    if (stripChars == null) {
      while ((end != 0) &amp;&amp; Character.isWhitespace(str.charAt(end - 1))) {
        end--;
      }
    } else if (stripChars.length() == 0) {
      return str;
    } else {
      while ((end != 0) &amp;&amp; (stripChars.indexOf(str.charAt(end - 1)) != -1)) {
        end--;
      }
    }
    return str.substring(0, end);
  }

  /**
   * The empty String &lt;code&gt;&quot;&quot;&lt;/code&gt;.
   * @since 2.0
   */
  public static final String EMPTY = &quot;&quot;;

  /**
   * Represents a failed index search.
   * @since 2.1
   */
  public static final int INDEX_NOT_FOUND = -1;

  /**
   * &lt;p&gt;The maximum size to which the padding constant(s) can expand.&lt;/p&gt;
   */
  private static final int PAD_LIMIT = 8192;

  /**
   * &lt;p&gt;An array of &lt;code&gt;String&lt;/code&gt;s used for padding.&lt;/p&gt;
   *
   * &lt;p&gt;Used for efficient space padding. The length of each String expands as needed.&lt;/p&gt;
   */
  private static final String[] PADDING = new String[Character.MAX_VALUE];

  static {
    // space padding is most common, start with 64 chars
    PADDING[32] = &quot;                                                                &quot;;
  }

  /**
   * &lt;p&gt;Repeat a String &lt;code&gt;repeat&lt;/code&gt; times to form a
   * new String.&lt;/p&gt;
   *
   * &lt;pre&gt;
   * StringUtils.repeat(null, 2) = null
   * StringUtils.repeat(&quot;&quot;, 0)   = &quot;&quot;
   * StringUtils.repeat(&quot;&quot;, 2)   = &quot;&quot;
   * StringUtils.repeat(&quot;a&quot;, 3)  = &quot;aaa&quot;
   * StringUtils.repeat(&quot;ab&quot;, 2) = &quot;abab&quot;
   * StringUtils.repeat(&quot;a&quot;, -2) = &quot;&quot;
   * &lt;/pre&gt;
   *
   * @param str  the String to repeat, may be null
   * @param repeat  number of times to repeat str, negative treated as zero
   * @return a new String consisting of the original String repeated,
   *  &lt;code&gt;null&lt;/code&gt; if null String input
   */
  public static String repeat(String str, int repeat) {
    // Performance tuned for 2.0 (JDK1.4)

    if (str == null) {
      return null;
    }
    if (repeat &lt;= 0) {
      return EMPTY;
    }
    int inputLength = str.length();
    if (repeat == 1 || inputLength == 0) {
      return str;
    }
    if (inputLength == 1 &amp;&amp; repeat &lt;= PAD_LIMIT) {
      return padding(repeat, str.charAt(0));
    }

    int outputLength = inputLength * repeat;
    switch (inputLength) {
      case 1:
        char ch = str.charAt(0);
        char[] output1 = new char[outputLength];
        for (int i = repeat - 1; i &gt;= 0; i--) {
          output1[i] = ch;
        }
        return new String(output1);
      case 2:
        char ch0 = str.charAt(0);
        char ch1 = str.charAt(1);
        char[] output2 = new char[outputLength];
        for (int i = repeat * 2 - 2; i &gt;= 0; i--, i--) {
          output2[i] = ch0;
          output2[i + 1] = ch1;
        }
        return new String(output2);
      default:
        StringBuffer buf = new StringBuffer(outputLength);
        for (int i = 0; i &lt; repeat; i++) {
          buf.append(str);
        }
        return buf.toString();
    }
  }

  /**
   * &lt;p&gt;Returns padding using the specified delimiter repeated
   * to a given length.&lt;/p&gt;
   *
   * &lt;pre&gt;
   * StringUtils.padding(0, 'e')  = &quot;&quot;
   * StringUtils.padding(3, 'e')  = &quot;eee&quot;
   * StringUtils.padding(-2, 'e') = IndexOutOfBoundsException
   * &lt;/pre&gt;
   *
   * @param repeat  number of times to repeat delim
   * @param padChar  character to repeat
   * @return String with repeated character
   * @throws IndexOutOfBoundsException if &lt;code&gt;repeat &amp;lt; 0&lt;/code&gt;
   */
  private static String padding(int repeat, char padChar) {
    // be careful of synchronization in this method
    // we are assuming that get and set from an array index is atomic
    String pad = PADDING[padChar];
    if (pad == null) {
      pad = String.valueOf(padChar);
    }
    while (pad.length() &lt; repeat) {
      pad = pad.concat(pad);
    }
    PADDING[padChar] = pad;
    return pad.substring(0, repeat);
  }

  /**
   * &lt;p&gt;Right pad a String with spaces (' ').&lt;/p&gt;
   *
   * &lt;p&gt;The String is padded to the size of &lt;code&gt;size&lt;/code&gt;.&lt;/p&gt;
   *
   * &lt;pre&gt;
   * StringUtils.rightPad(null, *)   = null
   * StringUtils.rightPad(&quot;&quot;, 3)     = &quot;   &quot;
   * StringUtils.rightPad(&quot;bat&quot;, 3)  = &quot;bat&quot;
   * StringUtils.rightPad(&quot;bat&quot;, 5)  = &quot;bat  &quot;
   * StringUtils.rightPad(&quot;bat&quot;, 1)  = &quot;bat&quot;
   * StringUtils.rightPad(&quot;bat&quot;, -1) = &quot;bat&quot;
   * &lt;/pre&gt;
   *
   * @param str  the String to pad out, may be null
   * @param size  the size to pad to
   * @return right padded String or original String if no padding is necessary,
   *  &lt;code&gt;null&lt;/code&gt; if null String input
   */
  public static String rightPad(String str, int size) {
    return rightPad(str, size, ' ');
  }

  /**
   * &lt;p&gt;Right pad a String with a specified character.&lt;/p&gt;
   *
   * &lt;p&gt;The String is padded to the size of &lt;code&gt;size&lt;/code&gt;.&lt;/p&gt;
   *
   * &lt;pre&gt;
   * StringUtils.rightPad(null, *, *)     = null
   * StringUtils.rightPad(&quot;&quot;, 3, 'z')     = &quot;zzz&quot;
   * StringUtils.rightPad(&quot;bat&quot;, 3, 'z')  = &quot;bat&quot;
   * StringUtils.rightPad(&quot;bat&quot;, 5, 'z')  = &quot;batzz&quot;
   * StringUtils.rightPad(&quot;bat&quot;, 1, 'z')  = &quot;bat&quot;
   * StringUtils.rightPad(&quot;bat&quot;, -1, 'z') = &quot;bat&quot;
   * &lt;/pre&gt;
   *
   * @param str  the String to pad out, may be null
   * @param size  the size to pad to
   * @param padChar  the character to pad with
   * @return right padded String or original String if no padding is necessary,
   *  &lt;code&gt;null&lt;/code&gt; if null String input
   * @since 2.0
   */
  public static String rightPad(String str, int size, char padChar) {
    if (str == null) {
      return null;
    }
    int pads = size - str.length();
    if (pads &lt;= 0) {
      return str; // returns original String when possible
    }
    if (pads &gt; PAD_LIMIT) {
      return rightPad(str, size, String.valueOf(padChar));
    }
    return str.concat(padding(pads, padChar));
  }

  /**
   * &lt;p&gt;Right pad a String with a specified String.&lt;/p&gt;
   *
   * &lt;p&gt;The String is padded to the size of &lt;code&gt;size&lt;/code&gt;.&lt;/p&gt;
   *
   * &lt;pre&gt;
   * StringUtils.rightPad(null, *, *)      = null
   * StringUtils.rightPad(&quot;&quot;, 3, &quot;z&quot;)      = &quot;zzz&quot;
   * StringUtils.rightPad(&quot;bat&quot;, 3, &quot;yz&quot;)  = &quot;bat&quot;
   * StringUtils.rightPad(&quot;bat&quot;, 5, &quot;yz&quot;)  = &quot;batyz&quot;
   * StringUtils.rightPad(&quot;bat&quot;, 8, &quot;yz&quot;)  = &quot;batyzyzy&quot;
   * StringUtils.rightPad(&quot;bat&quot;, 1, &quot;yz&quot;)  = &quot;bat&quot;
   * StringUtils.rightPad(&quot;bat&quot;, -1, &quot;yz&quot;) = &quot;bat&quot;
   * StringUtils.rightPad(&quot;bat&quot;, 5, null)  = &quot;bat  &quot;
   * StringUtils.rightPad(&quot;bat&quot;, 5, &quot;&quot;)    = &quot;bat  &quot;
   * &lt;/pre&gt;
   *
   * @param str  the String to pad out, may be null
   * @param size  the size to pad to
   * @param padStr  the String to pad with, null or empty treated as single space
   * @return right padded String or original String if no padding is necessary,
   *  &lt;code&gt;null&lt;/code&gt; if null String input
   */
  public static String rightPad(String str, int size, String padStr) {
    if (str == null) {
      return null;
    }
    if (isEmpty(padStr)) {
      padStr = &quot; &quot;;
    }
    int padLen = padStr.length();
    int strLen = str.length();
    int pads = size - strLen;
    if (pads &lt;= 0) {
      return str; // returns original String when possible
    }
    if (padLen == 1 &amp;&amp; pads &lt;= PAD_LIMIT) {
      return rightPad(str, size, padStr.charAt(0));
    }

    if (pads == padLen) {
      return str.concat(padStr);
    } else if (pads &lt; padLen) {
      return str.concat(padStr.substring(0, pads));
    } else {
      char[] padding = new char[pads];
      char[] padChars = padStr.toCharArray();
      for (int i = 0; i &lt; pads; i++) {
        padding[i] = padChars[i % padLen];
      }
      return str.concat(new String(padding));
    }
  }

  /**
   * &lt;p&gt;Left pad a String with spaces (' ').&lt;/p&gt;
   *
   * &lt;p&gt;The String is padded to the size of &lt;code&gt;size&lt;code&gt;.&lt;/p&gt;
   *
   * &lt;pre&gt;
   * StringUtils.leftPad(null, *)   = null
   * StringUtils.leftPad(&quot;&quot;, 3)     = &quot;   &quot;
   * StringUtils.leftPad(&quot;bat&quot;, 3)  = &quot;bat&quot;
   * StringUtils.leftPad(&quot;bat&quot;, 5)  = &quot;  bat&quot;
   * StringUtils.leftPad(&quot;bat&quot;, 1)  = &quot;bat&quot;
   * StringUtils.leftPad(&quot;bat&quot;, -1) = &quot;bat&quot;
   * &lt;/pre&gt;
   *
   * @param str  the String to pad out, may be null
   * @param size  the size to pad to
   * @return left padded String or original String if no padding is necessary,
   *  &lt;code&gt;null&lt;/code&gt; if null String input
   */
  public static String leftPad(String str, int size) {
    return leftPad(str, size, ' ');
  }

  /**
   * &lt;p&gt;Left pad a String with a specified character.&lt;/p&gt;
   *
   * &lt;p&gt;Pad to a size of &lt;code&gt;size&lt;/code&gt;.&lt;/p&gt;
   *
   * &lt;pre&gt;
   * StringUtils.leftPad(null, *, *)     = null
   * StringUtils.leftPad(&quot;&quot;, 3, 'z')     = &quot;zzz&quot;
   * StringUtils.leftPad(&quot;bat&quot;, 3, 'z')  = &quot;bat&quot;
   * StringUtils.leftPad(&quot;bat&quot;, 5, 'z')  = &quot;zzbat&quot;
   * StringUtils.leftPad(&quot;bat&quot;, 1, 'z')  = &quot;bat&quot;
   * StringUtils.leftPad(&quot;bat&quot;, -1, 'z') = &quot;bat&quot;
   * &lt;/pre&gt;
   *
   * @param str  the String to pad out, may be null
   * @param size  the size to pad to
   * @param padChar  the character to pad with
   * @return left padded String or original String if no padding is necessary,
   *  &lt;code&gt;null&lt;/code&gt; if null String input
   * @since 2.0
   */
  public static String leftPad(String str, int size, char padChar) {
    if (str == null) {
      return null;
    }
    int pads = size - str.length();
    if (pads &lt;= 0) {
      return str; // returns original String when possible
    }
    if (pads &gt; PAD_LIMIT) {
      return leftPad(str, size, String.valueOf(padChar));
    }
    return padding(pads, padChar).concat(str);
  }

  /**
   * &lt;p&gt;Left pad a String with a specified String.&lt;/p&gt;
   *
   * &lt;p&gt;Pad to a size of &lt;code&gt;size&lt;/code&gt;.&lt;/p&gt;
   *
   * &lt;pre&gt;
   * StringUtils.leftPad(null, *, *)      = null
   * StringUtils.leftPad(&quot;&quot;, 3, &quot;z&quot;)      = &quot;zzz&quot;
   * StringUtils.leftPad(&quot;bat&quot;, 3, &quot;yz&quot;)  = &quot;bat&quot;
   * StringUtils.leftPad(&quot;bat&quot;, 5, &quot;yz&quot;)  = &quot;yzbat&quot;
   * StringUtils.leftPad(&quot;bat&quot;, 8, &quot;yz&quot;)  = &quot;yzyzybat&quot;
   * StringUtils.leftPad(&quot;bat&quot;, 1, &quot;yz&quot;)  = &quot;bat&quot;
   * StringUtils.leftPad(&quot;bat&quot;, -1, &quot;yz&quot;) = &quot;bat&quot;
   * StringUtils.leftPad(&quot;bat&quot;, 5, null)  = &quot;  bat&quot;
   * StringUtils.leftPad(&quot;bat&quot;, 5, &quot;&quot;)    = &quot;  bat&quot;
   * &lt;/pre&gt;
   *
   * @param str  the String to pad out, may be null
   * @param size  the size to pad to
   * @param padStr  the String to pad with, null or empty treated as single space
   * @return left padded String or original String if no padding is necessary,
   *  &lt;code&gt;null&lt;/code&gt; if null String input
   */
  public static String leftPad(String str, int size, String padStr) {
    if (str == null) {
      return null;
    }
    if (isEmpty(padStr)) {
      padStr = &quot; &quot;;
    }
    int padLen = padStr.length();
    int strLen = str.length();
    int pads = size - strLen;
    if (pads &lt;= 0) {
      return str; // returns original String when possible
    }
    if (padLen == 1 &amp;&amp; pads &lt;= PAD_LIMIT) {
      return leftPad(str, size, padStr.charAt(0));
    }

    if (pads == padLen) {
      return padStr.concat(str);
    } else if (pads &lt; padLen) {
      return padStr.substring(0, pads).concat(str);
    } else {
      char[] padding = new char[pads];
      char[] padChars = padStr.toCharArray();
      for (int i = 0; i &lt; pads; i++) {
        padding[i] = padChars[i % padLen];
      }
      return new String(padding).concat(str);
    }
  }

  /**
   * convert an exception to a runtime exception
   * @param e
   */
  public static void convertToRuntimeException(Exception e) {
    if (e instanceof RuntimeException) {
      throw (RuntimeException)e;
    }
    throw new RuntimeException(e.getMessage(), e);
  }

  /**
   * &lt;p&gt;Gets the substring before the first occurrence of a separator.
   * The separator is not returned.&lt;/p&gt;
   *
   * &lt;p&gt;A &lt;code&gt;null&lt;/code&gt; string input will return &lt;code&gt;null&lt;/code&gt;.
   * An empty (&quot;&quot;) string input will return the empty string.
   * A &lt;code&gt;null&lt;/code&gt; separator will return the input string.&lt;/p&gt;
   *
   * &lt;pre&gt;
   * StringUtils.substringBefore(null, *)      = null
   * StringUtils.substringBefore(&quot;&quot;, *)        = &quot;&quot;
   * StringUtils.substringBefore(&quot;abc&quot;, &quot;a&quot;)   = &quot;&quot;
   * StringUtils.substringBefore(&quot;abcba&quot;, &quot;b&quot;) = &quot;a&quot;
   * StringUtils.substringBefore(&quot;abc&quot;, &quot;c&quot;)   = &quot;ab&quot;
   * StringUtils.substringBefore(&quot;abc&quot;, &quot;d&quot;)   = &quot;abc&quot;
   * StringUtils.substringBefore(&quot;abc&quot;, &quot;&quot;)    = &quot;&quot;
   * StringUtils.substringBefore(&quot;abc&quot;, null)  = &quot;abc&quot;
   * &lt;/pre&gt;
   *
   * @param str  the String to get a substring from, may be null
   * @param separator  the String to search for, may be null
   * @return the substring before the first occurrence of the separator,
   *  &lt;code&gt;null&lt;/code&gt; if null String input
   * @since 2.0
   */
  public static String substringBefore(String str, String separator) {
    if (isEmpty(str) || separator == null) {
      return str;
    }
    if (separator.length() == 0) {
      return EMPTY;
    }
    int pos = str.indexOf(separator);
    if (pos == -1) {
      return str;
    }
    return str.substring(0, pos);
  }

  /**
   * &lt;p&gt;Gets the substring after the first occurrence of a separator.
   * The separator is not returned.&lt;/p&gt;
   *
   * &lt;p&gt;A &lt;code&gt;null&lt;/code&gt; string input will return &lt;code&gt;null&lt;/code&gt;.
   * An empty (&quot;&quot;) string input will return the empty string.
   * A &lt;code&gt;null&lt;/code&gt; separator will return the empty string if the
   * input string is not &lt;code&gt;null&lt;/code&gt;.&lt;/p&gt;
   *
   * &lt;pre&gt;
   * StringUtils.substringAfter(null, *)      = null
   * StringUtils.substringAfter(&quot;&quot;, *)        = &quot;&quot;
   * StringUtils.substringAfter(*, null)      = &quot;&quot;
   * StringUtils.substringAfter(&quot;abc&quot;, &quot;a&quot;)   = &quot;bc&quot;
   * StringUtils.substringAfter(&quot;abcba&quot;, &quot;b&quot;) = &quot;cba&quot;
   * StringUtils.substringAfter(&quot;abc&quot;, &quot;c&quot;)   = &quot;&quot;
   * StringUtils.substringAfter(&quot;abc&quot;, &quot;d&quot;)   = &quot;&quot;
   * StringUtils.substringAfter(&quot;abc&quot;, &quot;&quot;)    = &quot;abc&quot;
   * &lt;/pre&gt;
   *
   * @param str  the String to get a substring from, may be null
   * @param separator  the String to search for, may be null
   * @return the substring after the first occurrence of the separator,
   *  &lt;code&gt;null&lt;/code&gt; if null String input
   * @since 2.0
   */
  public static String substringAfter(String str, String separator) {
    if (isEmpty(str)) {
      return str;
    }
    if (separator == null) {
      return EMPTY;
    }
    int pos = str.indexOf(separator);
    if (pos == -1) {
      return EMPTY;
    }
    return str.substring(pos + separator.length());
  }

  /**
   * &lt;p&gt;Gets the substring before the last occurrence of a separator.
   * The separator is not returned.&lt;/p&gt;
   *
   * &lt;p&gt;A &lt;code&gt;null&lt;/code&gt; string input will return &lt;code&gt;null&lt;/code&gt;.
   * An empty (&quot;&quot;) string input will return the empty string.
   * An empty or &lt;code&gt;null&lt;/code&gt; separator will return the input string.&lt;/p&gt;
   *
   * &lt;pre&gt;
   * StringUtils.substringBeforeLast(null, *)      = null
   * StringUtils.substringBeforeLast(&quot;&quot;, *)        = &quot;&quot;
   * StringUtils.substringBeforeLast(&quot;abcba&quot;, &quot;b&quot;) = &quot;abc&quot;
   * StringUtils.substringBeforeLast(&quot;abc&quot;, &quot;c&quot;)   = &quot;ab&quot;
   * StringUtils.substringBeforeLast(&quot;a&quot;, &quot;a&quot;)     = &quot;&quot;
   * StringUtils.substringBeforeLast(&quot;a&quot;, &quot;z&quot;)     = &quot;a&quot;
   * StringUtils.substringBeforeLast(&quot;a&quot;, null)    = &quot;a&quot;
   * StringUtils.substringBeforeLast(&quot;a&quot;, &quot;&quot;)      = &quot;a&quot;
   * &lt;/pre&gt;
   *
   * @param str  the String to get a substring from, may be null
   * @param separator  the String to search for, may be null
   * @return the substring before the last occurrence of the separator,
   *  &lt;code&gt;null&lt;/code&gt; if null String input
   * @since 2.0
   */
  public static String substringBeforeLast(String str, String separator) {
    if (isEmpty(str) || isEmpty(separator)) {
      return str;
    }
    int pos = str.lastIndexOf(separator);
    if (pos == -1) {
      return str;
    }
    return str.substring(0, pos);
  }

  /**
   * &lt;p&gt;Gets the substring after the last occurrence of a separator.
   * The separator is not returned.&lt;/p&gt;
   *
   * &lt;p&gt;A &lt;code&gt;null&lt;/code&gt; string input will return &lt;code&gt;null&lt;/code&gt;.
   * An empty (&quot;&quot;) string input will return the empty string.
   * An empty or &lt;code&gt;null&lt;/code&gt; separator will return the empty string if
   * the input string is not &lt;code&gt;null&lt;/code&gt;.&lt;/p&gt;
   *
   * &lt;pre&gt;
   * StringUtils.substringAfterLast(null, *)      = null
   * StringUtils.substringAfterLast(&quot;&quot;, *)        = &quot;&quot;
   * StringUtils.substringAfterLast(*, &quot;&quot;)        = &quot;&quot;
   * StringUtils.substringAfterLast(*, null)      = &quot;&quot;
   * StringUtils.substringAfterLast(&quot;abc&quot;, &quot;a&quot;)   = &quot;bc&quot;
   * StringUtils.substringAfterLast(&quot;abcba&quot;, &quot;b&quot;) = &quot;a&quot;
   * StringUtils.substringAfterLast(&quot;abc&quot;, &quot;c&quot;)   = &quot;&quot;
   * StringUtils.substringAfterLast(&quot;a&quot;, &quot;a&quot;)     = &quot;&quot;
   * StringUtils.substringAfterLast(&quot;a&quot;, &quot;z&quot;)     = &quot;&quot;
   * &lt;/pre&gt;
   *
   * @param str  the String to get a substring from, may be null
   * @param separator  the String to search for, may be null
   * @return the substring after the last occurrence of the separator,
   *  &lt;code&gt;null&lt;/code&gt; if null String input
   * @since 2.0
   */
  public static String substringAfterLast(String str, String separator) {
    if (isEmpty(str)) {
      return str;
    }
    if (isEmpty(separator)) {
      return EMPTY;
    }
    int pos = str.lastIndexOf(separator);
    if (pos == -1 || pos == (str.length() - separator.length())) {
      return EMPTY;
    }
    return str.substring(pos + separator.length());
  }

  /**
   * get the value from the argMap, throw exception if not there and required
   * @param argMap
   * @param argMapNotUsed 
   * @param key
   * @param required
   * @param defaultValue 
   * @return the value or null or exception
   */
  public static Integer argMapInteger(Map&lt;String, String&gt; argMap, Map&lt;String, String&gt; argMapNotUsed, 
      String key, boolean required, Integer defaultValue) {
    String argString = argMapString(argMap, argMapNotUsed, key, required);

    if (isBlank(argString) &amp;&amp; required) {
      throw new RuntimeException(&quot;Argument '--&quot; + key + &quot;' is required, but not specified.  e.g. --&quot; + key + &quot;=5&quot;);
    }
    if (isBlank(argString)) {
      if (defaultValue != null) {
        return defaultValue;
      }
      return null;
    }
    return intValue(argString);
  }

  /**
   * null safe convert from util date to sql date
   * @param date
   * @return the sql date
   */
  public static java.sql.Date toSqlDate(Date date) {
    if (date == null) {
      return null;
    }
    return new java.sql.Date(date.getTime());
  }

  /**
   * &lt;p&gt;Find the index of the given object in the array.&lt;/p&gt;
   *
   * &lt;p&gt;This method returns &lt;code&gt;-1&lt;/code&gt; if &lt;code&gt;null&lt;/code&gt; array input.&lt;/p&gt;
   * 
   * @param array  the array to search through for the object, may be &lt;code&gt;null&lt;/code&gt;
   * @param objectToFind  the object to find, may be &lt;code&gt;null&lt;/code&gt;
   * @return the index of the object within the array, 
   *  &lt;code&gt;-1&lt;/code&gt; if not found or &lt;code&gt;null&lt;/code&gt; array input
   */
  public static int indexOf(Object[] array, Object objectToFind) {
    return indexOf(array, objectToFind, 0);
  }

  /**
   * &lt;p&gt;Checks if the object is in the given array.&lt;/p&gt;
   *
   * &lt;p&gt;The method returns &lt;code&gt;false&lt;/code&gt; if a &lt;code&gt;null&lt;/code&gt; array is passed in.&lt;/p&gt;
   * 
   * @param array  the array to search through
   * @param objectToFind  the object to find
   * @return &lt;code&gt;true&lt;/code&gt; if the array contains the object
   */
  public static boolean contains(Object[] array, Object objectToFind) {
    return indexOf(array, objectToFind) != -1;
  }

  /**
   * &lt;p&gt;Find the index of the given object in the array starting at the given index.&lt;/p&gt;
   *
   * &lt;p&gt;This method returns &lt;code&gt;-1&lt;/code&gt; if &lt;code&gt;null&lt;/code&gt; array input.&lt;/p&gt;
   *
   * &lt;p&gt;A negative startIndex is treated as zero. A startIndex larger than the array
   * length will return &lt;code&gt;-1&lt;/code&gt;.&lt;/p&gt;
   * 
   * @param array  the array to search through for the object, may be &lt;code&gt;null&lt;/code&gt;
   * @param objectToFind  the object to find, may be &lt;code&gt;null&lt;/code&gt;
   * @param startIndex  the index to start searching at
   * @return the index of the object within the array starting at the index,
   *  &lt;code&gt;-1&lt;/code&gt; if not found or &lt;code&gt;null&lt;/code&gt; array input
   */
  public static int indexOf(Object[] array, Object objectToFind, int startIndex) {
    if (array == null) {
      return -1;
    }
    if (startIndex &lt; 0) {
      startIndex = 0;
    }
    if (objectToFind == null) {
      for (int i = startIndex; i &lt; array.length; i++) {
        if (array[i] == null) {
          return i;
        }
      }
    } else {
      for (int i = startIndex; i &lt; array.length; i++) {
        if (objectToFind.equals(array[i])) {
          return i;
        }
      }
    }
    return -1;
  }

  /**
   * Note, this is 
   * web service format string
   */
  private static final String WS_DATE_FORMAT = &quot;yyyy/MM/dd HH:mm:ss.SSS&quot;;

  /**
   * Note, this is 
   * web service format string
   */
  private static final String WS_DATE_FORMAT2 = &quot;yyyy/MM/dd_HH:mm:ss.SSS&quot;;

  /**
   * convert a date to a string using the standard web service pattern
   * yyyy/MM/dd HH:mm:ss.SSS Note that HH is 0-23
   * 
   * @param date
   * @return the string, or null if the date is null
   */
  public static String dateToString(Date date) {
    if (date == null) {
      return null;
    }
    SimpleDateFormat simpleDateFormat = new SimpleDateFormat(WS_DATE_FORMAT);
    return simpleDateFormat.format(date);
  }

  /**
   * convert a string to a date using the standard web service pattern Note
   * that HH is 0-23
   * 
   * @param dateString
   * @return the string, or null if the date was null
   */
  public static Date stringToDate(String dateString) {
    if (isBlank(dateString)) {
      return null;
    }
    SimpleDateFormat simpleDateFormat = new SimpleDateFormat(WS_DATE_FORMAT);
    try {
      return simpleDateFormat.parse(dateString);
    } catch (ParseException e) {
      SimpleDateFormat simpleDateFormat2 = new SimpleDateFormat(WS_DATE_FORMAT2);
      try {
        return simpleDateFormat2.parse(dateString);
      } catch (ParseException e2) {
        throw new RuntimeException(&quot;Cannot convert '&quot; + dateString
            + &quot;' to a date based on format: &quot; + WS_DATE_FORMAT, e);
      }
    }
  }

  /**
   * match regex pattern yyyy-mm-dd or yyyy/mm/dd
   */
  private static Pattern datePattern_yyyy_mm_dd = Pattern.compile(&quot;^(\\d{4})[^\\d]+(\\d{1,2})[^\\d]+(\\d{1,2})$&quot;);
  
  /**
   * match regex pattern dd-mon-yyyy or dd/mon/yyyy
   */
  private static Pattern datePattern_dd_mon_yyyy = Pattern.compile(&quot;^(\\d{1,2})[^\\d]+([a-zA-Z]{3,15})[^\\d]+(\\d{4})$&quot;);
  
  /**
   * match regex pattern yyyy-mm-dd hh:mm:ss or yyyy/mm/dd hh:mm:ss
   */
  private static Pattern datePattern_yyyy_mm_dd_hhmmss = Pattern.compile(&quot;^(\\d{4})[^\\d]+(\\d{1,2})[^\\d]+(\\d{1,2})[^\\d]+(\\d{1,2})[^\\d]+(\\d{1,2})[^\\d]+(\\d{1,2})$&quot;);
  
  /**
   * match regex pattern dd-mon-yyyy hh:mm:ss or dd/mon/yyyy hh:mm:ss
   */
  private static Pattern datePattern_dd_mon_yyyy_hhmmss = Pattern.compile(&quot;^(\\d{1,2})[^\\d]+([a-zA-Z]{3,15})[^\\d]+(\\d{4})[^\\d]+(\\d{1,2})[^\\d]+(\\d{1,2})[^\\d]+(\\d{1,2})$&quot;);
  
  /**
   * match regex pattern yyyy-mm-dd hh:mm:ss.SSS or yyyy/mm/dd hh:mm:ss.SSS
   */
  private static Pattern datePattern_yyyy_mm_dd_hhmmss_SSS = Pattern.compile(&quot;^(\\d{4})[^\\d]+(\\d{1,2})[^\\d]+(\\d{1,2})[^\\d]+(\\d{1,2})[^\\d]+(\\d{1,2})[^\\d]+(\\d{1,2})[^\\d]+(\\d{1,3})$&quot;);
  
  /**
   * match regex pattern dd-mon-yyyy hh:mm:ss.SSS or dd/mon/yyyy hh:mm:ss.SSS
   */
  private static Pattern datePattern_dd_mon_yyyy_hhmmss_SSS = Pattern.compile(&quot;^(\\d{1,2})[^\\d]+([a-zA-Z]{3,15})[^\\d]+(\\d{4})[^\\d]+(\\d{1,2})[^\\d]+(\\d{1,2})[^\\d]+(\\d{1,2})[^\\d]+(\\d{1,3})$&quot;);
  
  /**
   * take as input:
   * yyyy/mm/dd
   * yyyy-mm-dd
   * dd-mon-yyyy
   * yyyy/mm/dd hh:mm:ss
   * dd-mon-yyyy hh:mm:ss
   * yyyy/mm/dd hh:mm:ss.SSS
   * dd-mon-yyyy hh:mm:ss.SSS
   * @param input
   * @return the date
   */
  public static Date stringToDate2(String input) {
    
    if (isBlank(input)) {
      return null;
    }
    input = input.trim();
    Matcher matcher = null;
    
    int month = 0;
    int day = 0;
    int year = 0;
    int hour = 0;
    int minute = 0;
    int second = 0;
    int milli = 0;
    
    boolean foundMatch = false;

    //yyyy/mm/dd
    if (!foundMatch) {
      matcher = datePattern_yyyy_mm_dd.matcher(input);
      if (matcher.matches()) {
        year = intValue(matcher.group(1));
        month =  intValue(matcher.group(2));
        day = intValue(matcher.group(3));
        foundMatch = true;
      }
    }
    
    //dd-mon-yyyy
    if (!foundMatch) {
      matcher = datePattern_dd_mon_yyyy.matcher(input);
      if (matcher.matches()) {
        day = intValue(matcher.group(1));
        month =  monthInt(matcher.group(2));
        year = intValue(matcher.group(3));
        foundMatch = true;
      }
    }
    
    //yyyy/mm/dd hh:mm:ss
    if (!foundMatch) {
      matcher = datePattern_yyyy_mm_dd_hhmmss.matcher(input);
      if (matcher.matches()) {
        year = intValue(matcher.group(1));
        month =  intValue(matcher.group(2));
        day = intValue(matcher.group(3));
        hour = intValue(matcher.group(4));
        minute = intValue(matcher.group(5));
        second = intValue(matcher.group(6));
        foundMatch = true;
      }      
    }
    
    //dd-mon-yyyy hh:mm:ss
    if (!foundMatch) {
      matcher = datePattern_dd_mon_yyyy_hhmmss.matcher(input);
      if (matcher.matches()) {
        day = intValue(matcher.group(1));
        month =  monthInt(matcher.group(2));
        year = intValue(matcher.group(3));
        hour = intValue(matcher.group(4));
        minute = intValue(matcher.group(5));
        second = intValue(matcher.group(6));
        foundMatch = true;
      }
    }
    
    //yyyy/mm/dd hh:mm:ss.SSS
    if (!foundMatch) {
      matcher = datePattern_yyyy_mm_dd_hhmmss_SSS.matcher(input);
      if (matcher.matches()) {
        year = intValue(matcher.group(1));
        month =  intValue(matcher.group(2));
        day = intValue(matcher.group(3));
        hour = intValue(matcher.group(4));
        minute = intValue(matcher.group(5));
        second = intValue(matcher.group(6));
        milli = intValue(matcher.group(7));
        foundMatch = true;
      }      
    }
    
    //dd-mon-yyyy hh:mm:ss.SSS
    if (!foundMatch) {
      matcher = datePattern_dd_mon_yyyy_hhmmss_SSS.matcher(input);
      if (matcher.matches()) {
        day = intValue(matcher.group(1));
        month =  monthInt(matcher.group(2));
        year = intValue(matcher.group(3));
        hour = intValue(matcher.group(4));
        minute = intValue(matcher.group(5));
        second = intValue(matcher.group(6));
        milli = intValue(matcher.group(7));
        foundMatch = true;
      }
    }
    
    Calendar calendar = Calendar.getInstance();
    calendar.set(Calendar.YEAR, year);
    calendar.set(Calendar.MONTH, month-1);
    calendar.set(Calendar.DAY_OF_MONTH, day);
    calendar.set(Calendar.HOUR_OF_DAY, hour);
    calendar.set(Calendar.MINUTE, minute);
    calendar.set(Calendar.SECOND, second);
    calendar.set(Calendar.MILLISECOND, milli);
    return calendar.getTime();
  }

  /**
   * convert a month string to an int (1 indexed).
   * e.g. if input is feb or Feb or february or February return 2
   * @param mon
   * @return the month
   */
  public static int monthInt(String mon) {
    
    if (!isBlank(mon)) {
      mon = mon.toLowerCase();
      
      if (equals(mon, &quot;jan&quot;) || equals(mon, &quot;january&quot;)) {
        return 1;
      }
      
      if (equals(mon, &quot;feb&quot;) || equals(mon, &quot;february&quot;)) {
        return 2;
      }
      
      if (equals(mon, &quot;mar&quot;) || equals(mon, &quot;march&quot;)) {
        return 3;
      }
      
      if (equals(mon, &quot;apr&quot;) || equals(mon, &quot;april&quot;)) {
        return 4;
      }
      
      if (equals(mon, &quot;may&quot;)) {
        return 5;
      }
      
      if (equals(mon, &quot;jun&quot;) || equals(mon, &quot;june&quot;)) {
        return 6;
      }
      
      if (equals(mon, &quot;jul&quot;) || equals(mon, &quot;july&quot;)) {
        return 7;
      }
      
      if (equals(mon, &quot;aug&quot;) || equals(mon, &quot;august&quot;)) {
        return 8;
      }
      
      if (equals(mon, &quot;sep&quot;) || equals(mon, &quot;september&quot;)) {
        return 9;
      }
      
      if (equals(mon, &quot;oct&quot;) || equals(mon, &quot;october&quot;)) {
        return 10;
      }
      
      if (equals(mon, &quot;nov&quot;) || equals(mon, &quot;november&quot;)) {
        return 11;
      }
      
      if (equals(mon, &quot;dec&quot;) || equals(mon, &quot;december&quot;)) {
        return 12;
      }
      
    }
    
    throw new RuntimeException(&quot;Invalid month: &quot; + mon);
  }

  /**
   * override map for properties in thread local to be used in a web server or the like, based on property file name
   * @param propertiesFileName 
   * @return the override map
   */
  public static Map&lt;String, String&gt; propertiesThreadLocalOverrideMap(String propertiesFileName) {
    Map&lt;String, Map&lt;String, String&gt;&gt; overrideMap = propertiesThreadLocalOverrideMap.get();
    if (overrideMap == null) {
      overrideMap = new HashMap&lt;String, Map&lt;String, String&gt;&gt;();
      propertiesThreadLocalOverrideMap.set(overrideMap);
    }
    Map&lt;String, String&gt; propertiesOverrideMap = overrideMap.get(propertiesFileName);
    if (propertiesOverrideMap == null) {
      propertiesOverrideMap = new HashMap&lt;String, String&gt;();
      overrideMap.put(propertiesFileName, propertiesOverrideMap);
    }
    return propertiesOverrideMap;
  }

  
  /**
   * This will execute a command, and split spaces for args (might not be what
   * you want if you are using quotes)
   * 
   * @param command
   */
  public static void execCommand(String command) {
    String[] args = splitTrim(command, &quot; &quot;);
    execCommand(args);
  }

  /**
   * Gobble up a stream from a runtime
   * @author mchyzer
   * @param &lt;V&gt; 
   */
  private static class StreamGobbler&lt;V&gt; implements Callable&lt;V&gt; {
    
    /** stream to read */
    InputStream inputStream;
    
    /** where to put the result */
    String resultString;

    /** type of the output for logging purposes */
    String type;
    
    /** command to log */
    String command;
    /**
     * construct
     * @param is
     * @param theType 
     * @param theCommand
     */
    StreamGobbler(InputStream is, String theType, String theCommand) {
      this.inputStream = is;
      this.type = theType;
      this.command = theCommand;
    }

    /**
     * get the string result
     * @return the result
     */
    public String getResultString() {
      return this.resultString;
    }

    // @Override
    public V call() throws Exception {
      try {
        
        StringWriter stringWriter = new StringWriter();
        copy(this.inputStream, stringWriter);
        this.resultString = stringWriter.toString();

      } catch (Exception e) {</pre></div></td></tr></table>
<table border="0" class="bodyTable">
<tr class="a">
<th>File</th>
<th>Line</th></tr>
<tr class="b">
<td>edu\internet2\middleware\grouperClient\config\ConfigPropertiesCascadeCommonUtils.java</td>
<td><a href="./xref/edu/internet2/middleware/grouperClient/config/ConfigPropertiesCascadeCommonUtils.html#L2634">2634</a></td></tr>
<tr class="a">
<td>edu\internet2\middleware\grouperClient\util\GcElUtilsSafe.java</td>
<td><a href="./xref/edu/internet2/middleware/grouperClient/util/GcElUtilsSafe.html#L1492">1492</a></td></tr>
<tr class="b">
<td>edu\internet2\middleware\grouperClient\util\GrouperClientCommonUtils.java</td>
<td><a href="./xref/edu/internet2/middleware/grouperClient/util/GrouperClientCommonUtils.html#L2697">2697</a></td></tr>
<tr class="a"><td colspan='2'>
<div>
<pre>        null, true, true);
  }

  /**
   * replace a string or strings from a string, and put the output in a string
   * buffer. This does not recurse
   * 
   * @param text
   *            string to look in
   * @param searchFor
   *            string array to search for
   * @param replaceWith
   *            string array to replace with
   * @return the string
   */
  public static String replace(String text, Object searchFor,
      Object replaceWith) {
    return replace(null, null, text, searchFor, replaceWith, false, 0,
        false);
  }

  /**
   * replace a string or strings from a string, and put the output in a string
   * buffer
   * 
   * @param text
   *            string to look in
   * @param searchFor
   *            string array to search for
   * @param replaceWith
   *            string array to replace with
   * @param recurse
   *            if true then do multiple replaces (on the replacements)
   * @return the string
   */
  public static String replace(String text, Object searchFor,
      Object replaceWith, boolean recurse) {
    return replace(null, null, text, searchFor, replaceWith, recurse,
        recurse ? length(searchFor) : 0, false);
  }

  /**
   * replace a string or strings from a string, and put the output in a string
   * buffer
   * 
   * @param text
   *            string to look in
   * @param searchFor
   *            string array to search for
   * @param replaceWith
   *            string array to replace with
   * @param recurse
   *            if true then do multiple replaces (on the replacements)
   * @param removeIfFound
   *            true if removing from searchFor and replaceWith if found
   * @return the string
   */
  public static String replace(String text, Object searchFor,
      Object replaceWith, boolean recurse, boolean removeIfFound) {
    return replace(null, null, text, searchFor, replaceWith, recurse,
        recurse ? length(searchFor) : 0, removeIfFound);
  }

  /**
   * &lt;p&gt;
   * Replaces all occurrences of a String within another String.
   * &lt;/p&gt;
   * 
   * &lt;p&gt;
   * A &lt;code&gt;null&lt;/code&gt; reference passed to this method is a no-op.
   * &lt;/p&gt;
   * 
   * &lt;pre&gt;
   * replace(null, *, *)        = null
   * replace(&amp;quot;&amp;quot;, *, *)          = &amp;quot;&amp;quot;
   * replace(&amp;quot;any&amp;quot;, null, *)    = &amp;quot;any&amp;quot;
   * replace(&amp;quot;any&amp;quot;, *, null)    = &amp;quot;any&amp;quot;
   * replace(&amp;quot;any&amp;quot;, &amp;quot;&amp;quot;, *)      = &amp;quot;any&amp;quot;
   * replace(&amp;quot;aba&amp;quot;, &amp;quot;a&amp;quot;, null)  = &amp;quot;aba&amp;quot;
   * replace(&amp;quot;aba&amp;quot;, &amp;quot;a&amp;quot;, &amp;quot;&amp;quot;)    = &amp;quot;b&amp;quot;
   * replace(&amp;quot;aba&amp;quot;, &amp;quot;a&amp;quot;, &amp;quot;z&amp;quot;)   = &amp;quot;zbz&amp;quot;
   * &lt;/pre&gt;
   * 
   * @see #replace(String text, String repl, String with, int max)
   * @param text
   *            text to search and replace in, may be null
   * @param repl
   *            the String to search for, may be null
   * @param with
   *            the String to replace with, may be null
   * @return the text with any replacements processed, &lt;code&gt;null&lt;/code&gt; if
   *         null String input
   */
  public static String replace(String text, String repl, String with) {
    return replace(text, repl, with, -1);
  }

  /**
   * &lt;p&gt;
   * Replaces a String with another String inside a larger String, for the
   * first &lt;code&gt;max&lt;/code&gt; values of the search String.
   * &lt;/p&gt;
   * 
   * &lt;p&gt;
   * A &lt;code&gt;null&lt;/code&gt; reference passed to this method is a no-op.
   * &lt;/p&gt;
   * 
   * &lt;pre&gt;
   * replace(null, *, *, *)         = null
   * replace(&amp;quot;&amp;quot;, *, *, *)           = &amp;quot;&amp;quot;
   * replace(&amp;quot;any&amp;quot;, null, *, *)     = &amp;quot;any&amp;quot;
   * replace(&amp;quot;any&amp;quot;, *, null, *)     = &amp;quot;any&amp;quot;
   * replace(&amp;quot;any&amp;quot;, &amp;quot;&amp;quot;, *, *)       = &amp;quot;any&amp;quot;
   * replace(&amp;quot;any&amp;quot;, *, *, 0)        = &amp;quot;any&amp;quot;
   * replace(&amp;quot;abaa&amp;quot;, &amp;quot;a&amp;quot;, null, -1) = &amp;quot;abaa&amp;quot;
   * replace(&amp;quot;abaa&amp;quot;, &amp;quot;a&amp;quot;, &amp;quot;&amp;quot;, -1)   = &amp;quot;b&amp;quot;
   * replace(&amp;quot;abaa&amp;quot;, &amp;quot;a&amp;quot;, &amp;quot;z&amp;quot;, 0)   = &amp;quot;abaa&amp;quot;
   * replace(&amp;quot;abaa&amp;quot;, &amp;quot;a&amp;quot;, &amp;quot;z&amp;quot;, 1)   = &amp;quot;zbaa&amp;quot;
   * replace(&amp;quot;abaa&amp;quot;, &amp;quot;a&amp;quot;, &amp;quot;z&amp;quot;, 2)   = &amp;quot;zbza&amp;quot;
   * replace(&amp;quot;abaa&amp;quot;, &amp;quot;a&amp;quot;, &amp;quot;z&amp;quot;, -1)  = &amp;quot;zbzz&amp;quot;
   * &lt;/pre&gt;
   * 
   * @param text
   *            text to search and replace in, may be null
   * @param repl
   *            the String to search for, may be null
   * @param with
   *            the String to replace with, may be null
   * @param max
   *            maximum number of values to replace, or &lt;code&gt;-1&lt;/code&gt; if
   *            no maximum
   * @return the text with any replacements processed, &lt;code&gt;null&lt;/code&gt; if
   *         null String input
   */
  public static String replace(String text, String repl, String with, int max) {
    if (text == null || isEmpty(repl) || with == null || max == 0) {
      return text;
    }

    StringBuffer buf = new StringBuffer(text.length());
    int start = 0, end = 0;
    while ((end = text.indexOf(repl, start)) != -1) {
      buf.append(text.substring(start, end)).append(with);
      start = end + repl.length();

      if (--max == 0) {
        break;
      }
    }
    buf.append(text.substring(start));
    return buf.toString();
  }

  /**
   * &lt;p&gt;
   * Checks if a String is empty (&quot;&quot;) or null.
   * &lt;/p&gt;
   * 
   * &lt;pre&gt;
   * isEmpty(null)      = true
   * isEmpty(&amp;quot;&amp;quot;)        = true
   * isEmpty(&amp;quot; &amp;quot;)       = false
   * isEmpty(&amp;quot;bob&amp;quot;)     = false
   * isEmpty(&amp;quot;  bob  &amp;quot;) = false
   * &lt;/pre&gt;
   * 
   * &lt;p&gt;
   * NOTE: This method changed in Lang version 2.0. It no longer trims the
   * String. That functionality is available in isBlank().
   * &lt;/p&gt;
   * 
   * @param str
   *            the String to check, may be null
   * @return &lt;code&gt;true&lt;/code&gt; if the String is empty or null
   */
  public static boolean isEmpty(String str) {
    return str == null || str.length() == 0;
  }

  /**
   * replace a string or strings from a string, and put the output in a string
   * buffer. This does not recurse
   * 
   * @param outBuffer
   *            stringbuffer to write to
   * @param text
   *            string to look in
   * @param searchFor
   *            string array to search for
   * @param replaceWith
   *            string array to replace with
   */
  public static void replace(StringBuffer outBuffer, String text,
      Object searchFor, Object replaceWith) {
    replace(outBuffer, null, text, searchFor, replaceWith, false, 0, false);
  }

  /**
   * replace a string or strings from a string, and put the output in a string
   * buffer
   * 
   * @param outBuffer
   *            stringbuffer to write to
   * @param text
   *            string to look in
   * @param searchFor
   *            string array to search for
   * @param replaceWith
   *            string array to replace with
   * @param recurse
   *            if true then do multiple replaces (on the replacements)
   */
  public static void replace(StringBuffer outBuffer, String text,
      Object searchFor, Object replaceWith, boolean recurse) {
    replace(outBuffer, null, text, searchFor, replaceWith, recurse,
        recurse ? length(searchFor) : 0, false);
  }

  /**
   * replace a string with other strings, and either write to outWriter, or
   * StringBuffer, and if StringBuffer potentially return a string. If
   * outBuffer and outWriter are null, then return the String
   * 
   * @param outBuffer
   *            stringbuffer to write to, or null to not
   * @param outWriter
   *            Writer to write to, or null to not.
   * @param text
   *            string to look in
   * @param searchFor
   *            string array to search for, or string, or list
   * @param replaceWith
   *            string array to replace with, or string, or list
   * @param recurse
   *            if true then do multiple replaces (on the replacements)
   * @param timeToLive
   *            if recursing, prevent endless loops
   * @param removeIfFound
   *            true if removing from searchFor and replaceWith if found
   * @return the String if outBuffer and outWriter are null
   * @throws IndexOutOfBoundsException
   *             if the lengths of the arrays are not the same (null is ok,
   *             and/or size 0)
   * @throws IllegalArgumentException
   *             if the search is recursive and there is an endless loop due
   *             to outputs of one being inputs to another
   */
  private static String replace(StringBuffer outBuffer, Writer outWriter,
      String text, Object searchFor, Object replaceWith, boolean recurse,
      int timeToLive, boolean removeIfFound) {

    // if recursing, we need to get the string, then print to buffer (since
    // we need multiple passes)
    if (!recurse) {
      return replaceHelper(outBuffer, outWriter, text, searchFor,
          replaceWith, recurse, timeToLive, removeIfFound);
    }
    // get the string
    String result = replaceHelper(null, null, text, searchFor, replaceWith,
        recurse, timeToLive, removeIfFound);
    if (outBuffer != null) {
      outBuffer.append(result);
      return null;
    }

    if (outWriter != null) {
      try {
        outWriter.write(result);
      } catch (IOException ioe) {
        throw new RuntimeException(ioe);
      }
      return null;
    }

    return result;

  }

  /**
   * replace a string or strings from a string, and put the output in a string
   * buffer. This does not recurse
   * 
   * @param outWriter
   *            writer to write to
   * @param text
   *            string to look in
   * @param searchFor
   *            string array to search for
   * @param replaceWith
   *            string array to replace with
   */
  public static void replace(Writer outWriter, String text, Object searchFor,
      Object replaceWith) {
    replace(null, outWriter, text, searchFor, replaceWith, false, 0, false);
  }

  /**
   * replace a string or strings from a string, and put the output in a string
   * buffer
   * 
   * @param outWriter
   *            writer to write to
   * @param text
   *            string to look in
   * @param searchFor
   *            string array to search for
   * @param replaceWith
   *            string array to replace with
   * @param recurse
   *            if true then do multiple replaces (on the replacements)
   */
  public static void replace(Writer outWriter, String text, Object searchFor,
      Object replaceWith, boolean recurse) {
    replace(null, outWriter, text, searchFor, replaceWith, recurse,
        recurse ? length(searchFor) : 0, false);
  }

  /**
   * replace a string with other strings, and either write to outWriter, or
   * StringBuffer, and if StringBuffer potentially return a string. If
   * outBuffer and outWriter are null, then return the String
   * 
   * @param outBuffer
   *            stringbuffer to write to, or null to not
   * @param outWriter
   *            Writer to write to, or null to not.
   * @param text
   *            string to look in
   * @param searchFor
   *            string array to search for, or string, or list
   * @param replaceWith
   *            string array to replace with, or string, or list
   * @param recurse
   *            if true then do multiple replaces (on the replacements)
   * @param timeToLive
   *            if recursing, prevent endless loops
   * @param removeIfFound
   *            true if removing from searchFor and replaceWith if found
   * @return the String if outBuffer and outWriter are null
   * @throws IllegalArgumentException
   *             if the search is recursive and there is an endless loop due
   *             to outputs of one being inputs to another
   * @throws IndexOutOfBoundsException
   *             if the lengths of the arrays are not the same (null is ok,
   *             and/or size 0)
   */
  private static String replaceHelper(StringBuffer outBuffer,
      Writer outWriter, String text, Object searchFor,
      Object replaceWith, boolean recurse, int timeToLive,
      boolean removeIfFound) {

    try {
      // if recursing, this shouldnt be less than 0
      if (timeToLive &lt; 0) {
        throw new IllegalArgumentException(&quot;TimeToLive under 0: &quot;
            + timeToLive + &quot;, &quot; + text);
      }

      int searchForLength = length(searchFor);
      boolean done = false;
      // no need to do anything
      if (isEmpty(text)) {
        return text;
      }
      // need to write the input to output, later
      if (searchForLength == 0) {
        done = true;
      }

      boolean[] noMoreMatchesForReplIndex = null;
      int inputIndex = -1;
      int replaceIndex = -1;
      long resultPacked = -1;

      if (!done) {
        // make sure lengths are ok, these need to be equal
        if (searchForLength != length(replaceWith)) {
          throw new IndexOutOfBoundsException(&quot;Lengths dont match: &quot;
              + searchForLength + &quot;, &quot; + length(replaceWith));
        }

        // keep track of which still have matches
        noMoreMatchesForReplIndex = new boolean[searchForLength];

        // index of replace array that will replace the search string
        // found
        

        resultPacked = findNextIndexHelper(searchForLength, searchFor,
            replaceWith, 
            noMoreMatchesForReplIndex, text, 0);

        inputIndex = unpackInt(resultPacked, true);
        replaceIndex = unpackInt(resultPacked, false);
      }

      // get a good guess on the size of the result buffer so it doesnt
      // have to double if it
      // goes over a bit
      boolean writeToWriter = outWriter != null;

      // no search strings found, we are done
      if (done || inputIndex == -1) {
        if (writeToWriter) {
          outWriter.write(text, 0, text.length());
          return null;
        }
        if (outBuffer != null) {
          appendSubstring(outBuffer, text, 0, text.length());
          return null;
        }
        return text;
      }

      // no buffer if writing to writer
      StringBuffer bufferToWriteTo = outBuffer != null ? outBuffer
          : (writeToWriter ? null : new StringBuffer(text.length()
              + replaceStringsBufferIncrease(text, searchFor,
                  replaceWith)));

      String searchString = null;
      String replaceString = null;

      int start = 0;

      while (inputIndex != -1) {

        searchString = (String) get(searchFor, replaceIndex);
        replaceString = (String) get(replaceWith, replaceIndex);
        if (writeToWriter) {
          outWriter.write(text, start, inputIndex - start);
          outWriter.write(replaceString);
        } else {
          appendSubstring(bufferToWriteTo, text, start, inputIndex)
              .append(replaceString);
        }

        if (removeIfFound) {
          // better be an iterator based find replace
          searchFor = remove(searchFor, replaceIndex);
          replaceWith = remove(replaceWith, replaceIndex);
          noMoreMatchesForReplIndex = (boolean[])remove(noMoreMatchesForReplIndex, replaceIndex);
          // we now have a lesser size if we removed one
          searchForLength--;
        }

        start = inputIndex + searchString.length();

        resultPacked = findNextIndexHelper(searchForLength, searchFor,
            replaceWith, 
            noMoreMatchesForReplIndex, text, start);
        inputIndex = unpackInt(resultPacked, true);
        replaceIndex = unpackInt(resultPacked, false);
      }
      if (writeToWriter) {
        outWriter.write(text, start, text.length() - start);

      } else {
        appendSubstring(bufferToWriteTo, text, start, text.length());
      }

      // no need to convert to string if incoming buffer or writer
      if (writeToWriter || outBuffer != null) {
        if (recurse) {
          throw new IllegalArgumentException(
              &quot;Cannot recurse and write to existing buffer or writer!&quot;);
        }
        return null;
      }
      String resultString = bufferToWriteTo.toString();

      if (recurse) {
        return replaceHelper(outBuffer, outWriter, resultString,
            searchFor, replaceWith, recurse, timeToLive - 1, false);
      }
      // this might be null for writer
      return resultString;
    } catch (IOException ioe) {
      throw new RuntimeException(ioe);
    }
  }

  /**
   * give a best guess on buffer increase for String[] replace get a good
   * guess on the size of the result buffer so it doesnt have to double if it
   * goes over a bit
   * 
   * @param text
   * @param repl
   * @param with
   * @return the increase, with 20% cap
   */
  static int replaceStringsBufferIncrease(String text, Object repl,
      Object with) {
    // count the greaters
    int increase = 0;
    Iterator iteratorReplace = iterator(repl);
    Iterator iteratorWith = iterator(with);
    int replLength = length(repl);
    String currentRepl = null;
    String currentWith = null;
    for (int i = 0; i &lt; replLength; i++) {
      currentRepl = (String) next(repl, iteratorReplace, i);
      currentWith = (String) next(with, iteratorWith, i);
      if (currentRepl == null || currentWith == null) {
        throw new NullPointerException(&quot;Replace string is null: &quot;
            + text + &quot;, &quot; + currentRepl + &quot;, &quot; + currentWith);
      }
      int greater = currentWith.length() - currentRepl.length();
      increase += greater &gt; 0 ? 3 * greater : 0; // assume 3 matches
    }
    // have upper-bound at 20% increase, then let Java take over
    increase = Math.min(increase, text.length() / 5);
    return increase;
  }

  /**
   * Helper method to find the next match in an array of strings replace
   * 
   * @param searchForLength
   * @param searchFor
   * @param replaceWith
   * @param noMoreMatchesForReplIndex
   * @param input
   * @param start
   *            is where to start looking
   * @return result packed into a long, inputIndex first, then replaceIndex
   */
  private static long findNextIndexHelper(int searchForLength,
      Object searchFor, Object replaceWith, boolean[] noMoreMatchesForReplIndex,
      String input, int start) {

    int inputIndex = -1;
    int replaceIndex = -1;

    Iterator iteratorSearchFor = iterator(searchFor);
    Iterator iteratorReplaceWith = iterator(replaceWith);

    String currentSearchFor = null;
    String currentReplaceWith = null;
    int tempIndex = -1;
    for (int i = 0; i &lt; searchForLength; i++) {
      currentSearchFor = (String) next(searchFor, iteratorSearchFor, i);
      currentReplaceWith = (String) next(replaceWith,
          iteratorReplaceWith, i);
      if (noMoreMatchesForReplIndex[i] || isEmpty(currentSearchFor)
          || currentReplaceWith == null) {
        continue;
      }
      tempIndex = input.indexOf(currentSearchFor, start);

      // see if we need to keep searching for this
      noMoreMatchesForReplIndex[i] = tempIndex == -1;

      if (tempIndex != -1 &amp;&amp; (inputIndex == -1 || tempIndex &lt; inputIndex)) {
        inputIndex = tempIndex;
        replaceIndex = i;
      }

    }
    // dont create an array, no more objects
    long resultPacked = packInts(inputIndex, replaceIndex);
    return resultPacked;
  }

  /**
   * pack two ints into a long. Note: the first is held in the left bits, the
   * second is held in the right bits
   * 
   * @param first
   *            is first int
   * @param second
   *            is second int
   * @return the long which has two ints in there
   */
  public static long packInts(int first, int second) {
    long result = first;
    result &lt;&lt;= 32;
    result |= second;
    return result;
  }

  /**
   * take a long
   * 
   * @param theLong
   *            to unpack
   * @param isFirst
   *            true for first, false for second
   * @return one of the packed ints, first or second
   */
  public static int unpackInt(long theLong, boolean isFirst) {

    int result = 0;
    // put this in the position of the second one
    if (isFirst) {
      theLong &gt;&gt;= 32;
    }
    // only look at right part
    result = (int) (theLong &amp; 0xffffffff);
    return result;
  }

  /**
   * append a substring to a stringbuffer. removes dependency on substring
   * which creates objects
   * 
   * @param buf
   *            stringbuffer
   * @param string
   *            source string
   * @param start
   *            start index of source string
   * @param end
   *            end index of source string
   * @return the string buffer for chaining
   */
  private static StringBuffer appendSubstring(StringBuffer buf,
      String string, int start, int end) {
    for (int i = start; i &lt; end; i++) {
      buf.append(string.charAt(i));
    }
    return buf;
  }

  /**
   * Get a specific index of an array or collection (note for collections and
   * iterating, it is more efficient to get an iterator and iterate
   * 
   * @param arrayOrCollection
   * @param index
   * @return the object at that index
   */
  public static Object get(Object arrayOrCollection, int index) {</pre></div></td></tr></table>
<table border="0" class="bodyTable">
<tr class="b">
<th>File</th>
<th>Line</th></tr>
<tr class="a">
<td>edu\internet2\middleware\grouperClient\config\ConfigPropertiesCascadeCommonUtils.java</td>
<td><a href="./xref/edu/internet2/middleware/grouperClient/config/ConfigPropertiesCascadeCommonUtils.html#L4275">4275</a></td></tr>
<tr class="b">
<td>edu\internet2\middleware\grouperClient\util\GrouperClientCommonUtils.java</td>
<td><a href="./xref/edu/internet2/middleware/grouperClient/util/GrouperClientCommonUtils.html#L4338">4338</a></td></tr>
<tr class="a"><td colspan='2'>
<div>
<pre>    synchronized (ConfigPropertiesCascadeCommonUtils.class) {
      if (date == null) {
        return null;
      }
  
      String theString = dateFormat().format(date);
  
      return theString;
    }
  }

  /**
   * &lt;pre&gt;convert a string to timestamp based on the following formats:
   * yyyyMMdd
   * yyyy/MM/dd HH:mm:ss
   * yyyy/MM/dd HH:mm:ss.SSS
   * yyyy/MM/dd HH:mm:ss.SSSSSS
   * &lt;/pre&gt;
   * @param input
   * @return the timestamp object
   */
  public static Timestamp stringToTimestamp(String input) {
    Date date = stringToTimestampHelper(input);
    if (date == null) {
      return null;
    }
    //maybe already a timestamp
    if (date instanceof Timestamp) {
      return (Timestamp)date; 
    }
    return new Timestamp(date.getTime());
  }

  /**
   * return a date based on input, null safe.  Allow any of the three 
   * formats:
   * yyyyMMdd
   * yyyy/MM/dd HH:mm:ss
   * yyyy/MM/dd HH:mm:ss.SSS
   * yyyy/MM/dd HH:mm:ss.SSSSSS
   * 
   * @param input
   * @return the millis, -1 for null
   */
  synchronized static Date stringToTimestampHelper(String input) {
    //trim and handle null and empty
    if (isBlank(input)) {
      return null;
    }
  
    try {
      //convert mainframe
      if (equals(&quot;99999999&quot;, input)
          || equals(&quot;999999&quot;, input)) {
        input = &quot;20991231&quot;;
      }
      if (input.length() == 8) {
        
        return dateFormat().parse(input);
      }
      if (!contains(input, '.')) {
        if (contains(input, '/')) {
          return dateMinutesSecondsFormat.parse(input);
        }
        //else no slash
        return dateMinutesSecondsNoSlashFormat.parse(input);
      }
      if (contains(input, '/')) {
        //see if the period is 6 back
        int lastDotIndex = input.lastIndexOf('.');
        if (lastDotIndex == input.length() - 7) {
          String nonNanoInput = input.substring(0,input.length()-3);
          Date date = timestampFormat.parse(nonNanoInput);
          //get the last 3
          String lastThree = input.substring(input.length()-3,input.length());
          int lastThreeInt = Integer.parseInt(lastThree);
          Timestamp timestamp = new Timestamp(date.getTime());
          timestamp.setNanos(timestamp.getNanos() + (lastThreeInt * 1000));
          return timestamp;
        }
        return timestampFormat.parse(input);
      }
      //else no slash
      return timestampNoSlashFormat.parse(input);
    } catch (ParseException pe) {
      throw new RuntimeException(errorStart + input);
    }
  }

  /**
   * start of error parsing messages
   */
  private static final String errorStart = &quot;Invalid timestamp, please use any of the formats: &quot;
    + DATE_FORMAT + &quot;, &quot; + TIMESTAMP_FORMAT 
    + &quot;, &quot; + DATE_MINUTES_SECONDS_FORMAT + &quot;: &quot;;

  /**
   * Convert an object to a byte, allow nulls
   * @param input
   * @return the boolean object value
   */
  public static BigDecimal bigDecimalObjectValue(Object input) {
    if (input instanceof BigDecimal) {
      return (BigDecimal)input;
    }
    if (isBlank(input)) {
      return null;
    }
    return BigDecimal.valueOf(doubleValue(input));
  }

  /**
   * Convert an object to a byte, allow nulls
   * @param input
   * @return the boolean object value
   */
  public static Byte byteObjectValue(Object input) {
    if (input instanceof Byte) {
      return (Byte)input;
    }
    if (isBlank(input)) {
      return null;
    }
    return Byte.valueOf(byteValue(input));
  }

  /**
   * convert an object to a byte
   * @param input
   * @return the byte
   */
  public static byte byteValue(Object input) {
    if (input instanceof String) {
      String string = (String)input;
      return Byte.parseByte(string);
    }
    if (input instanceof Number) {
      return ((Number)input).byteValue();
    }
    throw new RuntimeException(&quot;Cannot convert to byte: &quot; + className(input));
  }

  /**
   * get the Double value of an object
   * 
   * @param input
   *          is a number or String
   * @param allowNullBlank used to default to false, if true, return null if nul inputted 
   * 
   * @return the Double equivalent
   */
  public static Double doubleObjectValue(Object input, boolean allowNullBlank) {
  
    if (input instanceof Double) {
      return (Double) input;
    } 
    
    if (allowNullBlank &amp;&amp; isBlank(input)) {
      return null;
    }
    
    return Double.valueOf(doubleValue(input));
  }

  /**
   * get the double value of an object
   * 
   * @param input
   *          is a number or String
   * 
   * @return the double equivalent
   */
  public static double doubleValue(Object input) {
    if (input instanceof String) {
      String string = (String)input;
      return Double.parseDouble(string);
    }
    if (input instanceof Number) {
      return ((Number)input).doubleValue();
    }
    throw new RuntimeException(&quot;Cannot convert to double: &quot;  + className(input));
  }

  /**
   * get the double value of an object, do not throw an 
   * exception if there is an
   * error
   * 
   * @param input
   *          is a number or String
   * 
   * @return the double equivalent
   */
  public static double doubleValueNoError(Object input) {
    if (input == null || (input instanceof String 
        &amp;&amp; isBlank((String)input))) {
      return NOT_FOUND;
    }
  
    try {
      return doubleValue(input);
    } catch (Exception e) {
      //no need to log here
    }
  
    return NOT_FOUND;
  }

  /**
   * get the Float value of an object
   * 
   * @param input
   *          is a number or String
   * @param allowNullBlank true if allow null or blank
   * 
   * @return the Float equivalent
   */
  public static Float floatObjectValue(Object input, boolean allowNullBlank) {
  
    if (input instanceof Float) {
      return (Float) input;
    } 
  
    if (allowNullBlank &amp;&amp; isBlank(input)) {
      return null;
    }
    return Float.valueOf(floatValue(input));
  }

  /**
   * get the float value of an object
   * 
   * @param input
   *          is a number or String
   * 
   * @return the float equivalent
   */
  public static float floatValue(Object input) {
    if (input instanceof String) {
      String string = (String)input;
      return Float.parseFloat(string);
    }
    if (input instanceof Number) {
      return ((Number)input).floatValue();
    }
    throw new RuntimeException(&quot;Cannot convert to float: &quot; + className(input));
  }

  /**
   * get the float value of an object, do not throw an exception if there is an
   * error
   * 
   * @param input
   *          is a number or String
   * 
   * @return the float equivalent
   */
  public static float floatValueNoError(Object input) {
    if (input == null || (input instanceof String 
        &amp;&amp; isBlank((String)input))) {
      return NOT_FOUND;
    }
    try {
      return floatValue(input);
    } catch (Exception e) {
      e.printStackTrace();
    }
  
    return NOT_FOUND;
  }

  /**
   * get the Integer value of an object
   * 
   * @param input
   *          is a number or String
   * @param allowNullBlank true if convert null or blank to null
   * 
   * @return the Integer equivalent
   */
  public static Integer intObjectValue(Object input, boolean allowNullBlank) {
  
    if (input instanceof Integer) {
      return (Integer) input;
    } 
  
    if (allowNullBlank &amp;&amp; isBlank(input)) {
      return null;
    }
    
    return Integer.valueOf(intValue(input));
  }

  /**
   * convert an object to a int
   * @param input
   * @return the number
   */
  public static int intValue(Object input) {
    if (input instanceof String) {
      String string = (String)input;
      return Integer.parseInt(string);
    }
    if (input instanceof Number) {
      return ((Number)input).intValue();
    }
    if (false) {
      if (input == null) {
        return 0;
      }
      if (input instanceof String || isBlank((String)input)) {
        return 0;
      }
    }
    
    throw new RuntimeException(&quot;Cannot convert to int: &quot; + className(input));
  }

  /**
   * convert an object to a int
   * @param input
   * @param valueIfNull is if the input is null or empty, return this value
   * @return the number
   */
  public static int intValue(Object input, int valueIfNull) {
    if (input == null || &quot;&quot;.equals(input)) {
      return valueIfNull;
    }
    return intObjectValue(input, false);
  }

  /**
   * get the int value of an object, do not throw an exception if there is an
   * error
   * 
   * @param input
   *          is a number or String
   * 
   * @return the int equivalent
   */
  public static int intValueNoError(Object input) {
    if (input == null || (input instanceof String 
        &amp;&amp; isBlank((String)input))) {
      return NOT_FOUND;
    }
    try {
      return intValue(input);
    } catch (Exception e) {
      //no need to log here
    }
  
    return NOT_FOUND;
  }

  /** special number when a number is not found */
  public static final int NOT_FOUND = -999999999;

  /**
   * The name says it all.
   */
  public static final int DEFAULT_BUFFER_SIZE = 1024 * 4;

  /**
   * get the Long value of an object
   * 
   * @param input
   *          is a number or String
   * @param allowNullBlank true if null or blank converts to null
   * 
   * @return the Long equivalent
   */
  public static Long longObjectValue(Object input, boolean allowNullBlank) {
  
    if (input instanceof Long) {
      return (Long) input;
    } 
  
    if (allowNullBlank &amp;&amp; isBlank(input)) {
      return null;
    } 
    
    return Long.valueOf(longValue(input));
  }

  /**
   * convert an object to a long
   * @param input
   * @return the number
   */
  public static long longValue(Object input) {
    if (input instanceof String) {
      String string = (String)input;
      return Long.parseLong(string);
    }
    if (input instanceof Number) {
      return ((Number)input).longValue();
    }
    throw new RuntimeException(&quot;Cannot convert to long: &quot; + className(input));
  }

  /**
   * convert an object to a long
   * @param input
   * @param valueIfNull is if the input is null or empty, return this value
   * @return the number
   */
  public static long longValue(Object input, long valueIfNull) {
    if (input == null || &quot;&quot;.equals(input)) {
      return valueIfNull;
    }
    return longObjectValue(input, false);
  }

  /**
   * get the long value of an object, do not throw an exception if there is an
   * error
   * 
   * @param input
   *          is a number or String
   * 
   * @return the long equivalent
   */
  public static long longValueNoError(Object input) {
    if (input == null || (input instanceof String 
        &amp;&amp; isBlank((String)input))) {
      return NOT_FOUND;
    }
    try {
      return longValue(input);
    } catch (Exception e) {
      //no need to log here
    }
  
    return NOT_FOUND;
  }

  /**
   * get the Short value of an object.  converts null or blank to null
   * 
   * @param input
   *          is a number or String
   * 
   * @return the Long equivalent
   */
  public static Short shortObjectValue(Object input) {
  
    if (input instanceof Short) {
      return (Short) input;
    }
  
    if (isBlank(input)) {
      return null;
    } 
    
    return Short.valueOf(shortValue(input));
  }

  /**
   * convert an object to a short
   * @param input
   * @return the number
   */
  public static short shortValue(Object input) {
    if (input instanceof String) {
      String string = (String)input;
      return Short.parseShort(string);
    }
    if (input instanceof Number) {
      return ((Number)input).shortValue();
    }
    throw new RuntimeException(&quot;Cannot convert to short: &quot; + className(input));
  }

  /**
   * get the Character wrapper value for the input
   * @param input allow null, return null
   * @return the Character object wrapper
   */
  public static Character charObjectValue(Object input) {
    if (input instanceof Character) {
      return (Character) input;
    }
    if (isBlank(input)) {
      return null;
    }
    return new Character(charValue(input));
  }

  /**
   * convert an object to a char
   * @param input
   * @return the number
   */
  public static char charValue(Object input) {
    if (input instanceof Character) {
      return ((Character) input).charValue();
    }
    //if string length 1, thats ok
    if (input instanceof String) {
      String inputString = (String) input;
      if (inputString.length() == 1) {
        return inputString.charAt(0);
      }
    }
    throw new RuntimeException(&quot;Cannot convert to char: &quot;
        + (input == null ? null : (input.getClass() + &quot;, &quot; + input)));
  }

  /**
   * Create the parent directories for a file if they do not already exist
   * @param file
   */
  public static void createParentDirectories(File file) {
    if (!file.getParentFile().exists()) {
      if (!file.getParentFile().mkdirs()) {
        throw new RuntimeException(&quot;Could not create directory : &quot; + file.getParentFile());
      }
    }
  }

  /**
   * save a string into a file, file does not have to exist
   * 
   * @param file
   *          is the file to save to
   * @param contents
   *          is the contents of the file
   */
  public static void saveStringIntoFile(File file, String contents) {
    try {
      writeStringToFile(file, contents, &quot;UTF-8&quot;);</pre></div></td></tr></table>
<table border="0" class="bodyTable">
<tr class="b">
<th>File</th>
<th>Line</th></tr>
<tr class="a">
<td>edu\internet2\middleware\grouperClient\config\ConfigPropertiesCascadeCommonUtils.java</td>
<td><a href="./xref/edu/internet2/middleware/grouperClient/config/ConfigPropertiesCascadeCommonUtils.html#L7785">7785</a></td></tr>
<tr class="b">
<td>edu\internet2\middleware\grouperClient\util\GcElUtilsSafe.java</td>
<td><a href="./xref/edu/internet2/middleware/grouperClient/util/GcElUtilsSafe.html#L4565">4565</a></td></tr>
<tr class="a">
<td>edu\internet2\middleware\grouperClient\util\GrouperClientCommonUtils.java</td>
<td><a href="./xref/edu/internet2/middleware/grouperClient/util/GrouperClientCommonUtils.html#L7888">7888</a></td></tr>
<tr class="b"><td colspan='2'>
<div>
<pre>  }

  /**
   * &lt;p&gt;Strips any of a set of characters from the start of a String.&lt;/p&gt;
   *
   * &lt;p&gt;A &lt;code&gt;null&lt;/code&gt; input String returns &lt;code&gt;null&lt;/code&gt;.
   * An empty string (&quot;&quot;) input returns the empty string.&lt;/p&gt;
   *
   * &lt;p&gt;If the stripChars String is &lt;code&gt;null&lt;/code&gt;, whitespace is
   * stripped as defined by {@link Character#isWhitespace(char)}.&lt;/p&gt;
   *
   * &lt;pre&gt;
   * StringUtils.stripStart(null, *)          = null
   * StringUtils.stripStart(&quot;&quot;, *)            = &quot;&quot;
   * StringUtils.stripStart(&quot;abc&quot;, &quot;&quot;)        = &quot;abc&quot;
   * StringUtils.stripStart(&quot;abc&quot;, null)      = &quot;abc&quot;
   * StringUtils.stripStart(&quot;  abc&quot;, null)    = &quot;abc&quot;
   * StringUtils.stripStart(&quot;abc  &quot;, null)    = &quot;abc  &quot;
   * StringUtils.stripStart(&quot; abc &quot;, null)    = &quot;abc &quot;
   * StringUtils.stripStart(&quot;yxabc  &quot;, &quot;xyz&quot;) = &quot;abc  &quot;
   * &lt;/pre&gt;
   *
   * @param str  the String to remove characters from, may be null
   * @param stripChars  the characters to remove, null treated as whitespace
   * @return the stripped String, &lt;code&gt;null&lt;/code&gt; if null String input
   */
  public static String stripStart(String str, String stripChars) {
    int strLen;
    if (str == null || (strLen = str.length()) == 0) {
      return str;
    }
    int start = 0;
    if (stripChars == null) {
      while ((start != strLen) &amp;&amp; Character.isWhitespace(str.charAt(start))) {
        start++;
      }
    } else if (stripChars.length() == 0) {
      return str;
    } else {
      while ((start != strLen) &amp;&amp; (stripChars.indexOf(str.charAt(start)) != -1)) {
        start++;
      }
    }
    return str.substring(start);
  }

  /**
   * &lt;p&gt;Strips any of a set of characters from the end of a String.&lt;/p&gt;
   *
   * &lt;p&gt;A &lt;code&gt;null&lt;/code&gt; input String returns &lt;code&gt;null&lt;/code&gt;.
   * An empty string (&quot;&quot;) input returns the empty string.&lt;/p&gt;
   *
   * &lt;p&gt;If the stripChars String is &lt;code&gt;null&lt;/code&gt;, whitespace is
   * stripped as defined by {@link Character#isWhitespace(char)}.&lt;/p&gt;
   *
   * &lt;pre&gt;
   * StringUtils.stripEnd(null, *)          = null
   * StringUtils.stripEnd(&quot;&quot;, *)            = &quot;&quot;
   * StringUtils.stripEnd(&quot;abc&quot;, &quot;&quot;)        = &quot;abc&quot;
   * StringUtils.stripEnd(&quot;abc&quot;, null)      = &quot;abc&quot;
   * StringUtils.stripEnd(&quot;  abc&quot;, null)    = &quot;  abc&quot;
   * StringUtils.stripEnd(&quot;abc  &quot;, null)    = &quot;abc&quot;
   * StringUtils.stripEnd(&quot; abc &quot;, null)    = &quot; abc&quot;
   * StringUtils.stripEnd(&quot;  abcyx&quot;, &quot;xyz&quot;) = &quot;  abc&quot;
   * &lt;/pre&gt;
   *
   * @param str  the String to remove characters from, may be null
   * @param stripChars  the characters to remove, null treated as whitespace
   * @return the stripped String, &lt;code&gt;null&lt;/code&gt; if null String input
   */
  public static String stripEnd(String str, String stripChars) {
    int end;
    if (str == null || (end = str.length()) == 0) {
      return str;
    }

    if (stripChars == null) {
      while ((end != 0) &amp;&amp; Character.isWhitespace(str.charAt(end - 1))) {
        end--;
      }
    } else if (stripChars.length() == 0) {
      return str;
    } else {
      while ((end != 0) &amp;&amp; (stripChars.indexOf(str.charAt(end - 1)) != -1)) {
        end--;
      }
    }
    return str.substring(0, end);
  }

  /**
   * The empty String &lt;code&gt;&quot;&quot;&lt;/code&gt;.
   * @since 2.0
   */
  public static final String EMPTY = &quot;&quot;;

  /**
   * Represents a failed index search.
   * @since 2.1
   */
  public static final int INDEX_NOT_FOUND = -1;

  /**
   * &lt;p&gt;The maximum size to which the padding constant(s) can expand.&lt;/p&gt;
   */
  private static final int PAD_LIMIT = 8192;

  /**
   * &lt;p&gt;An array of &lt;code&gt;String&lt;/code&gt;s used for padding.&lt;/p&gt;
   *
   * &lt;p&gt;Used for efficient space padding. The length of each String expands as needed.&lt;/p&gt;
   */
  private static final String[] PADDING = new String[Character.MAX_VALUE];

  static {
    // space padding is most common, start with 64 chars
    PADDING[32] = &quot;                                                                &quot;;
  }

  /**
   * &lt;p&gt;Repeat a String &lt;code&gt;repeat&lt;/code&gt; times to form a
   * new String.&lt;/p&gt;
   *
   * &lt;pre&gt;
   * StringUtils.repeat(null, 2) = null
   * StringUtils.repeat(&quot;&quot;, 0)   = &quot;&quot;
   * StringUtils.repeat(&quot;&quot;, 2)   = &quot;&quot;
   * StringUtils.repeat(&quot;a&quot;, 3)  = &quot;aaa&quot;
   * StringUtils.repeat(&quot;ab&quot;, 2) = &quot;abab&quot;
   * StringUtils.repeat(&quot;a&quot;, -2) = &quot;&quot;
   * &lt;/pre&gt;
   *
   * @param str  the String to repeat, may be null
   * @param repeat  number of times to repeat str, negative treated as zero
   * @return a new String consisting of the original String repeated,
   *  &lt;code&gt;null&lt;/code&gt; if null String input
   */
  public static String repeat(String str, int repeat) {
    // Performance tuned for 2.0 (JDK1.4)

    if (str == null) {
      return null;
    }
    if (repeat &lt;= 0) {
      return EMPTY;
    }
    int inputLength = str.length();
    if (repeat == 1 || inputLength == 0) {
      return str;
    }
    if (inputLength == 1 &amp;&amp; repeat &lt;= PAD_LIMIT) {
      return padding(repeat, str.charAt(0));
    }

    int outputLength = inputLength * repeat;
    switch (inputLength) {
      case 1:
        char ch = str.charAt(0);
        char[] output1 = new char[outputLength];
        for (int i = repeat - 1; i &gt;= 0; i--) {
          output1[i] = ch;
        }
        return new String(output1);
      case 2:
        char ch0 = str.charAt(0);
        char ch1 = str.charAt(1);
        char[] output2 = new char[outputLength];
        for (int i = repeat * 2 - 2; i &gt;= 0; i--, i--) {
          output2[i] = ch0;
          output2[i + 1] = ch1;
        }
        return new String(output2);
      default:
        StringBuffer buf = new StringBuffer(outputLength);
        for (int i = 0; i &lt; repeat; i++) {
          buf.append(str);
        }
        return buf.toString();
    }
  }

  /**
   * &lt;p&gt;Returns padding using the specified delimiter repeated
   * to a given length.&lt;/p&gt;
   *
   * &lt;pre&gt;
   * StringUtils.padding(0, 'e')  = &quot;&quot;
   * StringUtils.padding(3, 'e')  = &quot;eee&quot;
   * StringUtils.padding(-2, 'e') = IndexOutOfBoundsException
   * &lt;/pre&gt;
   *
   * @param repeat  number of times to repeat delim
   * @param padChar  character to repeat
   * @return String with repeated character
   * @throws IndexOutOfBoundsException if &lt;code&gt;repeat &amp;lt; 0&lt;/code&gt;
   */
  private static String padding(int repeat, char padChar) {
    // be careful of synchronization in this method
    // we are assuming that get and set from an array index is atomic
    String pad = PADDING[padChar];
    if (pad == null) {
      pad = String.valueOf(padChar);
    }
    while (pad.length() &lt; repeat) {
      pad = pad.concat(pad);
    }
    PADDING[padChar] = pad;
    return pad.substring(0, repeat);
  }

  /**
   * &lt;p&gt;Right pad a String with spaces (' ').&lt;/p&gt;
   *
   * &lt;p&gt;The String is padded to the size of &lt;code&gt;size&lt;/code&gt;.&lt;/p&gt;
   *
   * &lt;pre&gt;
   * StringUtils.rightPad(null, *)   = null
   * StringUtils.rightPad(&quot;&quot;, 3)     = &quot;   &quot;
   * StringUtils.rightPad(&quot;bat&quot;, 3)  = &quot;bat&quot;
   * StringUtils.rightPad(&quot;bat&quot;, 5)  = &quot;bat  &quot;
   * StringUtils.rightPad(&quot;bat&quot;, 1)  = &quot;bat&quot;
   * StringUtils.rightPad(&quot;bat&quot;, -1) = &quot;bat&quot;
   * &lt;/pre&gt;
   *
   * @param str  the String to pad out, may be null
   * @param size  the size to pad to
   * @return right padded String or original String if no padding is necessary,
   *  &lt;code&gt;null&lt;/code&gt; if null String input
   */
  public static String rightPad(String str, int size) {
    return rightPad(str, size, ' ');
  }

  /**
   * &lt;p&gt;Right pad a String with a specified character.&lt;/p&gt;
   *
   * &lt;p&gt;The String is padded to the size of &lt;code&gt;size&lt;/code&gt;.&lt;/p&gt;
   *
   * &lt;pre&gt;
   * StringUtils.rightPad(null, *, *)     = null
   * StringUtils.rightPad(&quot;&quot;, 3, 'z')     = &quot;zzz&quot;
   * StringUtils.rightPad(&quot;bat&quot;, 3, 'z')  = &quot;bat&quot;
   * StringUtils.rightPad(&quot;bat&quot;, 5, 'z')  = &quot;batzz&quot;
   * StringUtils.rightPad(&quot;bat&quot;, 1, 'z')  = &quot;bat&quot;
   * StringUtils.rightPad(&quot;bat&quot;, -1, 'z') = &quot;bat&quot;
   * &lt;/pre&gt;
   *
   * @param str  the String to pad out, may be null
   * @param size  the size to pad to
   * @param padChar  the character to pad with
   * @return right padded String or original String if no padding is necessary,
   *  &lt;code&gt;null&lt;/code&gt; if null String input
   * @since 2.0
   */
  public static String rightPad(String str, int size, char padChar) {
    if (str == null) {
      return null;
    }
    int pads = size - str.length();
    if (pads &lt;= 0) {
      return str; // returns original String when possible
    }
    if (pads &gt; PAD_LIMIT) {
      return rightPad(str, size, String.valueOf(padChar));
    }
    return str.concat(padding(pads, padChar));
  }

  /**
   * &lt;p&gt;Right pad a String with a specified String.&lt;/p&gt;
   *
   * &lt;p&gt;The String is padded to the size of &lt;code&gt;size&lt;/code&gt;.&lt;/p&gt;
   *
   * &lt;pre&gt;
   * StringUtils.rightPad(null, *, *)      = null
   * StringUtils.rightPad(&quot;&quot;, 3, &quot;z&quot;)      = &quot;zzz&quot;
   * StringUtils.rightPad(&quot;bat&quot;, 3, &quot;yz&quot;)  = &quot;bat&quot;
   * StringUtils.rightPad(&quot;bat&quot;, 5, &quot;yz&quot;)  = &quot;batyz&quot;
   * StringUtils.rightPad(&quot;bat&quot;, 8, &quot;yz&quot;)  = &quot;batyzyzy&quot;
   * StringUtils.rightPad(&quot;bat&quot;, 1, &quot;yz&quot;)  = &quot;bat&quot;
   * StringUtils.rightPad(&quot;bat&quot;, -1, &quot;yz&quot;) = &quot;bat&quot;
   * StringUtils.rightPad(&quot;bat&quot;, 5, null)  = &quot;bat  &quot;
   * StringUtils.rightPad(&quot;bat&quot;, 5, &quot;&quot;)    = &quot;bat  &quot;
   * &lt;/pre&gt;
   *
   * @param str  the String to pad out, may be null
   * @param size  the size to pad to
   * @param padStr  the String to pad with, null or empty treated as single space
   * @return right padded String or original String if no padding is necessary,
   *  &lt;code&gt;null&lt;/code&gt; if null String input
   */
  public static String rightPad(String str, int size, String padStr) {
    if (str == null) {
      return null;
    }
    if (isEmpty(padStr)) {
      padStr = &quot; &quot;;
    }
    int padLen = padStr.length();
    int strLen = str.length();
    int pads = size - strLen;
    if (pads &lt;= 0) {
      return str; // returns original String when possible
    }
    if (padLen == 1 &amp;&amp; pads &lt;= PAD_LIMIT) {
      return rightPad(str, size, padStr.charAt(0));
    }

    if (pads == padLen) {
      return str.concat(padStr);
    } else if (pads &lt; padLen) {
      return str.concat(padStr.substring(0, pads));
    } else {
      char[] padding = new char[pads];
      char[] padChars = padStr.toCharArray();
      for (int i = 0; i &lt; pads; i++) {
        padding[i] = padChars[i % padLen];
      }
      return str.concat(new String(padding));
    }
  }

  /**
   * &lt;p&gt;Left pad a String with spaces (' ').&lt;/p&gt;
   *
   * &lt;p&gt;The String is padded to the size of &lt;code&gt;size&lt;code&gt;.&lt;/p&gt;
   *
   * &lt;pre&gt;
   * StringUtils.leftPad(null, *)   = null
   * StringUtils.leftPad(&quot;&quot;, 3)     = &quot;   &quot;
   * StringUtils.leftPad(&quot;bat&quot;, 3)  = &quot;bat&quot;
   * StringUtils.leftPad(&quot;bat&quot;, 5)  = &quot;  bat&quot;
   * StringUtils.leftPad(&quot;bat&quot;, 1)  = &quot;bat&quot;
   * StringUtils.leftPad(&quot;bat&quot;, -1) = &quot;bat&quot;
   * &lt;/pre&gt;
   *
   * @param str  the String to pad out, may be null
   * @param size  the size to pad to
   * @return left padded String or original String if no padding is necessary,
   *  &lt;code&gt;null&lt;/code&gt; if null String input
   */
  public static String leftPad(String str, int size) {
    return leftPad(str, size, ' ');
  }

  /**
   * &lt;p&gt;Left pad a String with a specified character.&lt;/p&gt;
   *
   * &lt;p&gt;Pad to a size of &lt;code&gt;size&lt;/code&gt;.&lt;/p&gt;
   *
   * &lt;pre&gt;
   * StringUtils.leftPad(null, *, *)     = null
   * StringUtils.leftPad(&quot;&quot;, 3, 'z')     = &quot;zzz&quot;
   * StringUtils.leftPad(&quot;bat&quot;, 3, 'z')  = &quot;bat&quot;
   * StringUtils.leftPad(&quot;bat&quot;, 5, 'z')  = &quot;zzbat&quot;
   * StringUtils.leftPad(&quot;bat&quot;, 1, 'z')  = &quot;bat&quot;
   * StringUtils.leftPad(&quot;bat&quot;, -1, 'z') = &quot;bat&quot;
   * &lt;/pre&gt;
   *
   * @param str  the String to pad out, may be null
   * @param size  the size to pad to
   * @param padChar  the character to pad with
   * @return left padded String or original String if no padding is necessary,
   *  &lt;code&gt;null&lt;/code&gt; if null String input
   * @since 2.0
   */
  public static String leftPad(String str, int size, char padChar) {
    if (str == null) {
      return null;
    }
    int pads = size - str.length();
    if (pads &lt;= 0) {
      return str; // returns original String when possible
    }
    if (pads &gt; PAD_LIMIT) {
      return leftPad(str, size, String.valueOf(padChar));
    }
    return padding(pads, padChar).concat(str);
  }

  /**
   * &lt;p&gt;Left pad a String with a specified String.&lt;/p&gt;
   *
   * &lt;p&gt;Pad to a size of &lt;code&gt;size&lt;/code&gt;.&lt;/p&gt;
   *
   * &lt;pre&gt;
   * StringUtils.leftPad(null, *, *)      = null
   * StringUtils.leftPad(&quot;&quot;, 3, &quot;z&quot;)      = &quot;zzz&quot;
   * StringUtils.leftPad(&quot;bat&quot;, 3, &quot;yz&quot;)  = &quot;bat&quot;
   * StringUtils.leftPad(&quot;bat&quot;, 5, &quot;yz&quot;)  = &quot;yzbat&quot;
   * StringUtils.leftPad(&quot;bat&quot;, 8, &quot;yz&quot;)  = &quot;yzyzybat&quot;
   * StringUtils.leftPad(&quot;bat&quot;, 1, &quot;yz&quot;)  = &quot;bat&quot;
   * StringUtils.leftPad(&quot;bat&quot;, -1, &quot;yz&quot;) = &quot;bat&quot;
   * StringUtils.leftPad(&quot;bat&quot;, 5, null)  = &quot;  bat&quot;
   * StringUtils.leftPad(&quot;bat&quot;, 5, &quot;&quot;)    = &quot;  bat&quot;
   * &lt;/pre&gt;
   *
   * @param str  the String to pad out, may be null
   * @param size  the size to pad to
   * @param padStr  the String to pad with, null or empty treated as single space
   * @return left padded String or original String if no padding is necessary,
   *  &lt;code&gt;null&lt;/code&gt; if null String input
   */
  public static String leftPad(String str, int size, String padStr) {
    if (str == null) {
      return null;
    }
    if (isEmpty(padStr)) {
      padStr = &quot; &quot;;
    }
    int padLen = padStr.length();
    int strLen = str.length();
    int pads = size - strLen;
    if (pads &lt;= 0) {
      return str; // returns original String when possible
    }
    if (padLen == 1 &amp;&amp; pads &lt;= PAD_LIMIT) {
      return leftPad(str, size, padStr.charAt(0));
    }

    if (pads == padLen) {
      return padStr.concat(str);
    } else if (pads &lt; padLen) {
      return padStr.substring(0, pads).concat(str);
    } else {
      char[] padding = new char[pads];
      char[] padChars = padStr.toCharArray();
      for (int i = 0; i &lt; pads; i++) {
        padding[i] = padChars[i % padLen];
      }
      return new String(padding).concat(str);
    }
  }

  /**
   * convert an exception to a runtime exception
   * @param e
   */
  public static void convertToRuntimeException(Exception e) {</pre></div></td></tr></table>
<table border="0" class="bodyTable">
<tr class="a">
<th>File</th>
<th>Line</th></tr>
<tr class="b">
<td>edu\internet2\middleware\grouperClient\config\ConfigPropertiesCascadeCommonUtils.java</td>
<td><a href="./xref/edu/internet2/middleware/grouperClient/config/ConfigPropertiesCascadeCommonUtils.html#L6426">6426</a></td></tr>
<tr class="a">
<td>edu\internet2\middleware\grouperClient\util\GcElUtilsSafe.java</td>
<td><a href="./xref/edu/internet2/middleware/grouperClient/util/GcElUtilsSafe.html#L4104">4104</a></td></tr>
<tr class="b">
<td>edu\internet2\middleware\grouperClient\util\GrouperClientCommonUtils.java</td>
<td><a href="./xref/edu/internet2/middleware/grouperClient/util/GrouperClientCommonUtils.html#L6503">6503</a></td></tr>
<tr class="a"><td colspan='2'>
<div>
<pre>  private static String[] splitWorker(String str, String separatorChars, int max,
      boolean preserveAllTokens) {
    // Performance tuned for 2.0 (JDK1.4)
    // Direct code is quicker than StringTokenizer.
    // Also, StringTokenizer uses isSpace() not isWhitespace()

    if (str == null) {
      return null;
    }
    int len = str.length();
    if (len == 0) {
      return EMPTY_STRING_ARRAY;
    }
    List list = new ArrayList();
    int sizePlus1 = 1;
    int i = 0, start = 0;
    boolean match = false;
    boolean lastMatch = false;
    if (separatorChars == null) {
      // Null separator means use whitespace
      while (i &lt; len) {
        if (Character.isWhitespace(str.charAt(i))) {
          if (match || preserveAllTokens) {
            lastMatch = true;
            if (sizePlus1++ == max) {
              i = len;
              lastMatch = false;
            }
            list.add(str.substring(start, i));
            match = false;
          }
          start = ++i;
          continue;
        }
        lastMatch = false;
        match = true;
        i++;
      }
    } else if (separatorChars.length() == 1) {
      // Optimise 1 character case
      char sep = separatorChars.charAt(0);
      while (i &lt; len) {
        if (str.charAt(i) == sep) {
          if (match || preserveAllTokens) {
            lastMatch = true;
            if (sizePlus1++ == max) {
              i = len;
              lastMatch = false;
            }
            list.add(str.substring(start, i));
            match = false;
          }
          start = ++i;
          continue;
        }
        lastMatch = false;
        match = true;
        i++;
      }
    } else {
      // standard case
      while (i &lt; len) {
        if (separatorChars.indexOf(str.charAt(i)) &gt;= 0) {
          if (match || preserveAllTokens) {
            lastMatch = true;
            if (sizePlus1++ == max) {
              i = len;
              lastMatch = false;
            }
            list.add(str.substring(start, i));
            match = false;
          }
          start = ++i;
          continue;
        }
        lastMatch = false;
        match = true;
        i++;
      }
    }
    if (match || (preserveAllTokens &amp;&amp; lastMatch)) {
      list.add(str.substring(start, i));
    }
    return (String[]) list.toArray(new String[list.size()]);
  }

  // Joining
  //-----------------------------------------------------------------------

  /**
   * &lt;p&gt;Joins the elements of the provided array into a single String
   * containing the provided list of elements.&lt;/p&gt;
   *
   * &lt;p&gt;No separator is added to the joined String.
   * Null objects or empty strings within the array are represented by
   * empty strings.&lt;/p&gt;
   *
   * &lt;pre&gt;
   * StringUtils.join(null)            = null
   * StringUtils.join([])              = &quot;&quot;
   * StringUtils.join([null])          = &quot;&quot;
   * StringUtils.join([&quot;a&quot;, &quot;b&quot;, &quot;c&quot;]) = &quot;abc&quot;
   * StringUtils.join([null, &quot;&quot;, &quot;a&quot;]) = &quot;a&quot;
   * &lt;/pre&gt;
   *
   * @param array  the array of values to join together, may be null
   * @return the joined String, &lt;code&gt;null&lt;/code&gt; if null array input
   * @since 2.0
   */
  public static String join(Object[] array) {
    return join(array, null);
  }

  /**
   * &lt;p&gt;Joins the elements of the provided array into a single String
   * containing the provided list of elements.&lt;/p&gt;
   *
   * &lt;p&gt;No delimiter is added before or after the list.
   * Null objects or empty strings within the array are represented by
   * empty strings.&lt;/p&gt;
   *
   * &lt;pre&gt;
   * StringUtils.join(null, *)               = null
   * StringUtils.join([], *)                 = &quot;&quot;
   * StringUtils.join([null], *)             = &quot;&quot;
   * StringUtils.join([&quot;a&quot;, &quot;b&quot;, &quot;c&quot;], ';')  = &quot;a;b;c&quot;
   * StringUtils.join([&quot;a&quot;, &quot;b&quot;, &quot;c&quot;], null) = &quot;abc&quot;
   * StringUtils.join([null, &quot;&quot;, &quot;a&quot;], ';')  = &quot;;;a&quot;
   * &lt;/pre&gt;
   *
   * @param array  the array of values to join together, may be null
   * @param separator  the separator character to use
   * @return the joined String, &lt;code&gt;null&lt;/code&gt; if null array input
   * @since 2.0
   */
  public static String join(Object[] array, char separator) {
    if (array == null) {
      return null;
    }
    int arraySize = array.length;
    int bufSize = (arraySize == 0 ? 0 : ((array[0] == null ? 16 : array[0].toString()
        .length()) + 1)
        * arraySize);
    StringBuffer buf = new StringBuffer(bufSize);

    for (int i = 0; i &lt; arraySize; i++) {
      if (i &gt; 0) {
        buf.append(separator);
      }
      if (array[i] != null) {
        buf.append(array[i]);
      }
    }
    return buf.toString();
  }

  /**
   * &lt;p&gt;Joins the elements of the provided array into a single String
   * containing the provided list of elements.&lt;/p&gt;
   *
   * &lt;p&gt;No delimiter is added before or after the list.
   * A &lt;code&gt;null&lt;/code&gt; separator is the same as an empty String (&quot;&quot;).
   * Null objects or empty strings within the array are represented by
   * empty strings.&lt;/p&gt;
   *
   * &lt;pre&gt;
   * StringUtils.join(null, *)                = null
   * StringUtils.join([], *)                  = &quot;&quot;
   * StringUtils.join([null], *)              = &quot;&quot;
   * StringUtils.join([&quot;a&quot;, &quot;b&quot;, &quot;c&quot;], &quot;--&quot;)  = &quot;a--b--c&quot;
   * StringUtils.join([&quot;a&quot;, &quot;b&quot;, &quot;c&quot;], null)  = &quot;abc&quot;
   * StringUtils.join([&quot;a&quot;, &quot;b&quot;, &quot;c&quot;], &quot;&quot;)    = &quot;abc&quot;
   * StringUtils.join([null, &quot;&quot;, &quot;a&quot;], ',')   = &quot;,,a&quot;
   * &lt;/pre&gt;
   *
   * @param array  the array of values to join together, may be null
   * @param separator  the separator character to use, null treated as &quot;&quot;
   * @return the joined String, &lt;code&gt;null&lt;/code&gt; if null array input
   */
  public static String join(Object[] array, String separator) {
    if (array == null) {
      return null;
    }
    if (separator == null) {
      separator = &quot;&quot;;
    }
    int arraySize = array.length;

    // ArraySize ==  0: Len = 0
    // ArraySize &gt; 0:   Len = NofStrings *(len(firstString) + len(separator))
    //           (Assuming that all Strings are roughly equally long)
    int bufSize = ((arraySize == 0) ? 0 : arraySize
        * ((array[0] == null ? 16 : array[0].toString().length()) + separator.length()));

    StringBuffer buf = new StringBuffer(bufSize);

    for (int i = 0; i &lt; arraySize; i++) {
      if (i &gt; 0) {
        buf.append(separator);
      }
      if (array[i] != null) {
        buf.append(array[i]);
      }
    }
    return buf.toString();
  }

  /**
   * &lt;p&gt;Joins the elements of the provided &lt;code&gt;Iterator&lt;/code&gt; into
   * a single String containing the provided elements.&lt;/p&gt;
   *
   * &lt;p&gt;No delimiter is added before or after the list. Null objects or empty
   * strings within the iteration are represented by empty strings.&lt;/p&gt;
   *
   * &lt;p&gt;See the examples here: {@link #join(Object[],char)}. &lt;/p&gt;
   *
   * @param iterator  the &lt;code&gt;Iterator&lt;/code&gt; of values to join together, may be null
   * @param separator  the separator character to use
   * @return the joined String, &lt;code&gt;null&lt;/code&gt; if null iterator input
   * @since 2.0
   */
  public static String join(Iterator iterator, char separator) {
    if (iterator == null) {
      return null;
    }
    StringBuffer buf = new StringBuffer(256); // Java default is 16, probably too small
    while (iterator.hasNext()) {
      Object obj = iterator.next();
      if (obj != null) {
        buf.append(obj);
      }
      if (iterator.hasNext()) {
        buf.append(separator);
      }
    }
    return buf.toString();
  }

  /**
   * &lt;p&gt;Joins the elements of the provided &lt;code&gt;Iterator&lt;/code&gt; into
   * a single String containing the provided elements.&lt;/p&gt;
   *
   * &lt;p&gt;No delimiter is added before or after the list.
   * A &lt;code&gt;null&lt;/code&gt; separator is the same as an empty String (&quot;&quot;).&lt;/p&gt;
   *
   * &lt;p&gt;See the examples here: {@link #join(Object[],String)}. &lt;/p&gt;
   *
   * @param iterator  the &lt;code&gt;Iterator&lt;/code&gt; of values to join together, may be null
   * @param separator  the separator character to use, null treated as &quot;&quot;
   * @return the joined String, &lt;code&gt;null&lt;/code&gt; if null iterator input
   */
  public static String join(Iterator iterator, String separator) {
    if (iterator == null) {
      return null;
    }
    StringBuffer buf = new StringBuffer(256); // Java default is 16, probably too small
    while (iterator.hasNext()) {
      Object obj = iterator.next();
      if (obj != null) {
        buf.append(obj);
      }
      if ((separator != null) &amp;&amp; iterator.hasNext()) {
        buf.append(separator);
      }
    }
    return buf.toString();
  }

  /**
   * &lt;p&gt;Returns either the passed in String,
   * or if the String is &lt;code&gt;null&lt;/code&gt;, an empty String (&quot;&quot;).&lt;/p&gt;
   *
   * &lt;pre&gt;
   * StringUtils.defaultString(null)  = &quot;&quot;
   * StringUtils.defaultString(&quot;&quot;)    = &quot;&quot;
   * StringUtils.defaultString(&quot;bat&quot;) = &quot;bat&quot;
   * &lt;/pre&gt;
   *
   * @see String#valueOf(Object)
   * @param str  the String to check, may be null
   * @return the passed in String, or the empty String if it
   *  was &lt;code&gt;null&lt;/code&gt;
   */
  public static String defaultString(String str) {
    return str == null ? &quot;&quot; : str;
  }

  /**
   * &lt;p&gt;Returns either the passed in String, or if the String is
   * &lt;code&gt;null&lt;/code&gt;, the value of &lt;code&gt;defaultStr&lt;/code&gt;.&lt;/p&gt;
   *
   * &lt;pre&gt;
   * StringUtils.defaultString(null, &quot;NULL&quot;)  = &quot;NULL&quot;
   * StringUtils.defaultString(&quot;&quot;, &quot;NULL&quot;)    = &quot;&quot;
   * StringUtils.defaultString(&quot;bat&quot;, &quot;NULL&quot;) = &quot;bat&quot;
   * &lt;/pre&gt;
   *
   * @see String#valueOf(Object)
   * @param str  the String to check, may be null
   * @param defaultStr  the default String to return
   *  if the input is &lt;code&gt;null&lt;/code&gt;, may be null
   * @return the passed in String, or the default if it was &lt;code&gt;null&lt;/code&gt;
   */
  public static String defaultString(String str, String defaultStr) {
    return str == null ? defaultStr : str;
  }

  /**
   * &lt;p&gt;Returns either the passed in String, or if the String is
   * empty or &lt;code&gt;null&lt;/code&gt;, the value of &lt;code&gt;defaultStr&lt;/code&gt;.&lt;/p&gt;
   *
   * &lt;pre&gt;
   * StringUtils.defaultIfEmpty(null, &quot;NULL&quot;)  = &quot;NULL&quot;
   * StringUtils.defaultIfEmpty(&quot;&quot;, &quot;NULL&quot;)    = &quot;NULL&quot;
   * StringUtils.defaultIfEmpty(&quot;bat&quot;, &quot;NULL&quot;) = &quot;bat&quot;
   * &lt;/pre&gt;
   *
   * @param str  the String to check, may be null
   * @param defaultStr  the default String to return
   *  if the input is empty (&quot;&quot;) or &lt;code&gt;null&lt;/code&gt;, may be null
   * @return the passed in String, or the default
   */
  public static String defaultIfEmpty(String str, String defaultStr) {
    return isEmpty(str) ? defaultStr : str;
  }

  /**
   * &lt;p&gt;Capitalizes a String changing the first letter to title case as
   * per {@link Character#toTitleCase(char)}. No other letters are changed.&lt;/p&gt;
   *
   * A &lt;code&gt;null&lt;/code&gt; input String returns &lt;code&gt;null&lt;/code&gt;.&lt;/p&gt;
   *
   * &lt;pre&gt;
   * StringUtils.capitalize(null)  = null
   * StringUtils.capitalize(&quot;&quot;)    = &quot;&quot;
   * StringUtils.capitalize(&quot;cat&quot;) = &quot;Cat&quot;
   * StringUtils.capitalize(&quot;cAt&quot;) = &quot;CAt&quot;
   * &lt;/pre&gt;
   *
   * @param str  the String to capitalize, may be null
   * @return the capitalized String, &lt;code&gt;null&lt;/code&gt; if null String input
   * @since 2.0
   */
  public static String capitalize(String str) {
    int strLen;
    if (str == null || (strLen = str.length()) == 0) {
      return str;
    }
    return new StringBuffer(strLen).append(Character.toTitleCase(str.charAt(0))).append(
        str.substring(1)).toString();
  }

  /**
   * &lt;p&gt;Checks if String contains a search character, handling &lt;code&gt;null&lt;/code&gt;.
   * This method uses {@link String#indexOf(int)}.&lt;/p&gt;
   *
   * &lt;p&gt;A &lt;code&gt;null&lt;/code&gt; or empty (&quot;&quot;) String will return &lt;code&gt;false&lt;/code&gt;.&lt;/p&gt;
   *
   * &lt;pre&gt;
   * StringUtils.contains(null, *)    = false
   * StringUtils.contains(&quot;&quot;, *)      = false
   * StringUtils.contains(&quot;abc&quot;, 'a') = true
   * StringUtils.contains(&quot;abc&quot;, 'z') = false
   * &lt;/pre&gt;
   *
   * @param str  the String to check, may be null
   * @param searchChar  the character to find
   * @return true if the String contains the search character,
   *  false if not or &lt;code&gt;null&lt;/code&gt; string input
   * @since 2.0
   */
  public static boolean contains(String str, char searchChar) {
    if (isEmpty(str)) {
      return false;
    }
    return str.indexOf(searchChar) &gt;= 0;
  }

  /**
   * &lt;p&gt;Checks if String contains a search String, handling &lt;code&gt;null&lt;/code&gt;.
   * This method uses {@link String#indexOf(int)}.&lt;/p&gt;
   *
   * &lt;p&gt;A &lt;code&gt;null&lt;/code&gt; String will return &lt;code&gt;false&lt;/code&gt;.&lt;/p&gt;
   *
   * &lt;pre&gt;
   * StringUtils.contains(null, *)     = false
   * StringUtils.contains(*, null)     = false
   * StringUtils.contains(&quot;&quot;, &quot;&quot;)      = true
   * StringUtils.contains(&quot;abc&quot;, &quot;&quot;)   = true
   * StringUtils.contains(&quot;abc&quot;, &quot;a&quot;)  = true
   * StringUtils.contains(&quot;abc&quot;, &quot;z&quot;)  = false
   * &lt;/pre&gt;
   *
   * @param str  the String to check, may be null
   * @param searchStr  the String to find, may be null
   * @return true if the String contains the search String,
   *  false if not or &lt;code&gt;null&lt;/code&gt; string input
   * @since 2.0
   */
  public static boolean contains(String str, String searchStr) {
    if (str == null || searchStr == null) {
      return false;
    }
    return str.indexOf(searchStr) &gt;= 0;
  }
  
  /**
   * An empty immutable &lt;code&gt;String&lt;/code&gt; array.
   */
  public static final String[] EMPTY_STRING_ARRAY = new String[0];

  /**
   * &lt;p&gt;Compares two objects for equality, where either one or both
   * objects may be &lt;code&gt;null&lt;/code&gt;.&lt;/p&gt;
   *
   * &lt;pre&gt;
   * ObjectUtils.equals(null, null)                  = true
   * ObjectUtils.equals(null, &quot;&quot;)                    = false
   * ObjectUtils.equals(&quot;&quot;, null)                    = false
   * ObjectUtils.equals(&quot;&quot;, &quot;&quot;)                      = true
   * ObjectUtils.equals(Boolean.TRUE, null)          = false
   * ObjectUtils.equals(Boolean.TRUE, &quot;true&quot;)        = false
   * ObjectUtils.equals(Boolean.TRUE, Boolean.TRUE)  = true
   * ObjectUtils.equals(Boolean.TRUE, Boolean.FALSE) = false
   * &lt;/pre&gt;
   *
   * @param object1  the first object, may be &lt;code&gt;null&lt;/code&gt;
   * @param object2  the second object, may be &lt;code&gt;null&lt;/code&gt;
   * @return &lt;code&gt;true&lt;/code&gt; if the values of both objects are the same
   */
  public static boolean equals(Object object1, Object object2) {
      if (object1 == object2) {
          return true;
      }
      if ((object1 == null) || (object2 == null)) {
          return false;
      }
      return object1.equals(object2);
  }

  /**
   * &lt;p&gt;A way to get the entire nested stack-trace of an throwable.&lt;/p&gt;
   *
   * @param throwable  the &lt;code&gt;Throwable&lt;/code&gt; to be examined
   * @return the nested stack trace, with the root cause first
   * @since 2.0
   */
  public static String getFullStackTrace(Throwable throwable) {</pre></div></td></tr></table>
<table border="0" class="bodyTable">
<tr class="b">
<th>File</th>
<th>Line</th></tr>
<tr class="a">
<td>edu\internet2\middleware\grouperClient\config\ConfigPropertiesCascadeCommonUtils.java</td>
<td><a href="./xref/edu/internet2/middleware/grouperClient/config/ConfigPropertiesCascadeCommonUtils.html#L8537">8537</a></td></tr>
<tr class="b">
<td>edu\internet2\middleware\grouperClient\util\GcElUtilsSafe.java</td>
<td><a href="./xref/edu/internet2/middleware/grouperClient/util/GcElUtilsSafe.html#L2342">2342</a></td></tr>
<tr class="a">
<td>edu\internet2\middleware\grouperClient\util\GrouperClientCommonUtils.java</td>
<td><a href="./xref/edu/internet2/middleware/grouperClient/util/GrouperClientCommonUtils.html#L8640">8640</a></td></tr>
<tr class="b"><td colspan='2'>
<div>
<pre>  }

  /**
   * match regex pattern yyyy-mm-dd or yyyy/mm/dd
   */
  private static Pattern datePattern_yyyy_mm_dd = Pattern.compile(&quot;^(\\d{4})[^\\d]+(\\d{1,2})[^\\d]+(\\d{1,2})$&quot;);
  
  /**
   * match regex pattern dd-mon-yyyy or dd/mon/yyyy
   */
  private static Pattern datePattern_dd_mon_yyyy = Pattern.compile(&quot;^(\\d{1,2})[^\\d]+([a-zA-Z]{3,15})[^\\d]+(\\d{4})$&quot;);
  
  /**
   * match regex pattern yyyy-mm-dd hh:mm:ss or yyyy/mm/dd hh:mm:ss
   */
  private static Pattern datePattern_yyyy_mm_dd_hhmmss = Pattern.compile(&quot;^(\\d{4})[^\\d]+(\\d{1,2})[^\\d]+(\\d{1,2})[^\\d]+(\\d{1,2})[^\\d]+(\\d{1,2})[^\\d]+(\\d{1,2})$&quot;);
  
  /**
   * match regex pattern dd-mon-yyyy hh:mm:ss or dd/mon/yyyy hh:mm:ss
   */
  private static Pattern datePattern_dd_mon_yyyy_hhmmss = Pattern.compile(&quot;^(\\d{1,2})[^\\d]+([a-zA-Z]{3,15})[^\\d]+(\\d{4})[^\\d]+(\\d{1,2})[^\\d]+(\\d{1,2})[^\\d]+(\\d{1,2})$&quot;);
  
  /**
   * match regex pattern yyyy-mm-dd hh:mm:ss.SSS or yyyy/mm/dd hh:mm:ss.SSS
   */
  private static Pattern datePattern_yyyy_mm_dd_hhmmss_SSS = Pattern.compile(&quot;^(\\d{4})[^\\d]+(\\d{1,2})[^\\d]+(\\d{1,2})[^\\d]+(\\d{1,2})[^\\d]+(\\d{1,2})[^\\d]+(\\d{1,2})[^\\d]+(\\d{1,3})$&quot;);
  
  /**
   * match regex pattern dd-mon-yyyy hh:mm:ss.SSS or dd/mon/yyyy hh:mm:ss.SSS
   */
  private static Pattern datePattern_dd_mon_yyyy_hhmmss_SSS = Pattern.compile(&quot;^(\\d{1,2})[^\\d]+([a-zA-Z]{3,15})[^\\d]+(\\d{4})[^\\d]+(\\d{1,2})[^\\d]+(\\d{1,2})[^\\d]+(\\d{1,2})[^\\d]+(\\d{1,3})$&quot;);
  
  /**
   * take as input:
   * yyyy/mm/dd
   * yyyy-mm-dd
   * dd-mon-yyyy
   * yyyy/mm/dd hh:mm:ss
   * dd-mon-yyyy hh:mm:ss
   * yyyy/mm/dd hh:mm:ss.SSS
   * dd-mon-yyyy hh:mm:ss.SSS
   * @param input
   * @return the date
   */
  public static Date stringToDate2(String input) {
    
    if (isBlank(input)) {
      return null;
    }
    input = input.trim();
    Matcher matcher = null;
    
    int month = 0;
    int day = 0;
    int year = 0;
    int hour = 0;
    int minute = 0;
    int second = 0;
    int milli = 0;
    
    boolean foundMatch = false;

    //yyyy/mm/dd
    if (!foundMatch) {
      matcher = datePattern_yyyy_mm_dd.matcher(input);
      if (matcher.matches()) {
        year = intValue(matcher.group(1));
        month =  intValue(matcher.group(2));
        day = intValue(matcher.group(3));
        foundMatch = true;
      }
    }
    
    //dd-mon-yyyy
    if (!foundMatch) {
      matcher = datePattern_dd_mon_yyyy.matcher(input);
      if (matcher.matches()) {
        day = intValue(matcher.group(1));
        month =  monthInt(matcher.group(2));
        year = intValue(matcher.group(3));
        foundMatch = true;
      }
    }
    
    //yyyy/mm/dd hh:mm:ss
    if (!foundMatch) {
      matcher = datePattern_yyyy_mm_dd_hhmmss.matcher(input);
      if (matcher.matches()) {
        year = intValue(matcher.group(1));
        month =  intValue(matcher.group(2));
        day = intValue(matcher.group(3));
        hour = intValue(matcher.group(4));
        minute = intValue(matcher.group(5));
        second = intValue(matcher.group(6));
        foundMatch = true;
      }      
    }
    
    //dd-mon-yyyy hh:mm:ss
    if (!foundMatch) {
      matcher = datePattern_dd_mon_yyyy_hhmmss.matcher(input);
      if (matcher.matches()) {
        day = intValue(matcher.group(1));
        month =  monthInt(matcher.group(2));
        year = intValue(matcher.group(3));
        hour = intValue(matcher.group(4));
        minute = intValue(matcher.group(5));
        second = intValue(matcher.group(6));
        foundMatch = true;
      }
    }
    
    //yyyy/mm/dd hh:mm:ss.SSS
    if (!foundMatch) {
      matcher = datePattern_yyyy_mm_dd_hhmmss_SSS.matcher(input);
      if (matcher.matches()) {
        year = intValue(matcher.group(1));
        month =  intValue(matcher.group(2));
        day = intValue(matcher.group(3));
        hour = intValue(matcher.group(4));
        minute = intValue(matcher.group(5));
        second = intValue(matcher.group(6));
        milli = intValue(matcher.group(7));
        foundMatch = true;
      }      
    }
    
    //dd-mon-yyyy hh:mm:ss.SSS
    if (!foundMatch) {
      matcher = datePattern_dd_mon_yyyy_hhmmss_SSS.matcher(input);
      if (matcher.matches()) {
        day = intValue(matcher.group(1));
        month =  monthInt(matcher.group(2));
        year = intValue(matcher.group(3));
        hour = intValue(matcher.group(4));
        minute = intValue(matcher.group(5));
        second = intValue(matcher.group(6));
        milli = intValue(matcher.group(7));
        foundMatch = true;
      }
    }
    
    Calendar calendar = Calendar.getInstance();
    calendar.set(Calendar.YEAR, year);
    calendar.set(Calendar.MONTH, month-1);
    calendar.set(Calendar.DAY_OF_MONTH, day);
    calendar.set(Calendar.HOUR_OF_DAY, hour);
    calendar.set(Calendar.MINUTE, minute);
    calendar.set(Calendar.SECOND, second);
    calendar.set(Calendar.MILLISECOND, milli);
    return calendar.getTime();
  }

  /**
   * convert a month string to an int (1 indexed).
   * e.g. if input is feb or Feb or february or February return 2
   * @param mon
   * @return the month
   */
  public static int monthInt(String mon) {
    
    if (!isBlank(mon)) {
      mon = mon.toLowerCase();
      
      if (equals(mon, &quot;jan&quot;) || equals(mon, &quot;january&quot;)) {
        return 1;
      }
      
      if (equals(mon, &quot;feb&quot;) || equals(mon, &quot;february&quot;)) {
        return 2;
      }
      
      if (equals(mon, &quot;mar&quot;) || equals(mon, &quot;march&quot;)) {
        return 3;
      }
      
      if (equals(mon, &quot;apr&quot;) || equals(mon, &quot;april&quot;)) {
        return 4;
      }
      
      if (equals(mon, &quot;may&quot;)) {
        return 5;
      }
      
      if (equals(mon, &quot;jun&quot;) || equals(mon, &quot;june&quot;)) {
        return 6;
      }
      
      if (equals(mon, &quot;jul&quot;) || equals(mon, &quot;july&quot;)) {
        return 7;
      }
      
      if (equals(mon, &quot;aug&quot;) || equals(mon, &quot;august&quot;)) {
        return 8;
      }
      
      if (equals(mon, &quot;sep&quot;) || equals(mon, &quot;september&quot;)) {
        return 9;
      }
      
      if (equals(mon, &quot;oct&quot;) || equals(mon, &quot;october&quot;)) {
        return 10;
      }
      
      if (equals(mon, &quot;nov&quot;) || equals(mon, &quot;november&quot;)) {
        return 11;
      }
      
      if (equals(mon, &quot;dec&quot;) || equals(mon, &quot;december&quot;)) {
        return 12;
      }
      
    }
    
    throw new RuntimeException(&quot;Invalid month: &quot; + mon);
  }

  /**
   * override map for properties in thread local to be used in a web server or the like, based on property file name
   * @param propertiesFileName 
   * @return the override map
   */
  public static Map&lt;String, String&gt; propertiesThreadLocalOverrideMap(String propertiesFileName) {</pre></div></td></tr></table>
<table border="0" class="bodyTable">
<tr class="a">
<th>File</th>
<th>Line</th></tr>
<tr class="b">
<td>edu\internet2\middleware\grouperClient\config\ConfigPropertiesCascadeCommonUtils.java</td>
<td><a href="./xref/edu/internet2/middleware/grouperClient/config/ConfigPropertiesCascadeCommonUtils.html#L90">90</a></td></tr>
<tr class="a">
<td>edu\internet2\middleware\grouperClient\util\GrouperClientCommonUtils.java</td>
<td><a href="./xref/edu/internet2/middleware/grouperClient/util/GrouperClientCommonUtils.html#L94">94</a></td></tr>
<tr class="b"><td colspan='2'>
<div>
<pre>public class ConfigPropertiesCascadeCommonUtils  {

  /** override map for properties in thread local to be used in a web server or the like */
  private static ThreadLocal&lt;Map&lt;String, Map&lt;String, String&gt;&gt;&gt; propertiesThreadLocalOverrideMap = new ThreadLocal&lt;Map&lt;String, Map&lt;String, String&gt;&gt;&gt;();

  /**
   * return the arg after the argBefore, or null if not there, or exception
   * if argBefore is not found
   * @param args
   * @param argBefore
   * @return the arg
   */
  public static String argAfter(String[] args, String argBefore) {
    if (length(args) &lt;= 1) {
      return null;
    }
    int argBeforeIndex = -1;
    for (int i=0;i&lt;args.length;i++) {
      if (equals(args[i], argBefore)) {
        argBeforeIndex = i;
        break;
      }
    }
    if (argBeforeIndex == -1) {
      throw new RuntimeException(&quot;Cant find arg before&quot;);
    }
    if (argBeforeIndex &lt; args.length - 1) {
      return args[argBeforeIndex + 1];
    }
    return null;
  }
  
  /**
   * append and maybe put a separator in there
   * @param result
   * @param separatorIfResultNotEmpty
   * @param stringToAppend
   */
  public static void append(StringBuilder result, 
      String separatorIfResultNotEmpty, String stringToAppend) {
    if (result.length() != 0) {
      result.append(separatorIfResultNotEmpty);
    }
    result.append(stringToAppend);
  }
  
  /**
   * 
   */
  public static final String LOG_ERROR = &quot;Error trying to make parent dirs for logger or logging first statement, check to make &quot; +
                &quot;sure you have proper file permissions, and that your servlet container is giving &quot; +
                &quot;your app rights to access the log directory (e.g. for tomcat set TOMCAT5_SECURITY=no), g&quot; +
                &quot;oogle it for more info&quot;;

  /**
   * The number of bytes in a kilobyte.
   */
  public static final long ONE_KB = 1024;

  /**
   * The number of bytes in a megabyte.
   */
  public static final long ONE_MB = ONE_KB * ONE_KB;

  /**
   * The number of bytes in a gigabyte.
   */
  public static final long ONE_GB = ONE_KB * ONE_MB;

  /**
   * Returns a human-readable version of the file size (original is in
   * bytes).
   *
   * @param size The number of bytes.
   * @return     A human-readable display value (includes units).
   * @todo need for I18N?
   */
  public static String byteCountToDisplaySize(long size) {
    String displaySize;

    if (size / ONE_GB &gt; 0) {
      displaySize = String.valueOf(size / ONE_GB) + &quot; GB&quot;;
    } else if (size / ONE_MB &gt; 0) {
      displaySize = String.valueOf(size / ONE_MB) + &quot; MB&quot;;
    } else if (size / ONE_KB &gt; 0) {
      displaySize = String.valueOf(size / ONE_KB) + &quot; KB&quot;;
    } else {
      displaySize = String.valueOf(size) + &quot; bytes&quot;;
    }

    return displaySize;
  }
  /**
   * see if options have a specific option by int bits
   * @param options
   * @param option
   * @return if the option is there
   */
  public static boolean hasOption(int options, int option) {
    return (options &amp; option) &gt; 0;
  }
  
  /**
   * get canonical path of file
   * @param file
   * @return the path
   */
  public static String fileCanonicalPath(File file) {
    try {
      return file.getCanonicalPath();
    } catch (IOException ioe) {
      throw new RuntimeException(ioe);
    }
  }
  
  /**
   * return the suffix after a char.  If the char doesnt exist, just return the string
   * @param input string
   * @param theChar char
   * @return new string
   */
  public static String suffixAfterChar(String input, char theChar) {
    if (input == null) {
      return null;
    }
    //get the real type off the end
    int lastIndex = input.lastIndexOf(theChar);
    if (lastIndex &gt; -1) {
      input = input.substring(lastIndex + 1, input.length());
    }
    return input;
  }

  /**
   * get the oracle underscore name e.g. javaNameHere -&gt; JAVA_NAME_HERE
   *
   * @param javaName
   *          the java convention name
   *
   * @return the oracle underscore name based on the java name
   */
  public static String oracleStandardNameFromJava(String javaName) {
  
    StringBuilder result = new StringBuilder();
  
    if ((javaName == null) || (0 == &quot;&quot;.compareTo(javaName))) {
      return javaName;
    }
  
    //if package is specified, only look at class name
    javaName = suffixAfterChar(javaName, '.');
  
    //dont check the first char
    result.append(javaName.charAt(0));
  
    char currChar;
  
    boolean previousCap = false;
    
    //loop through the string, looking for uppercase
    for (int i = 1; i &lt; javaName.length(); i++) {
      currChar = javaName.charAt(i);
  
      //if uppcase append an underscore
      if (!previousCap &amp;&amp; (currChar &gt;= 'A') &amp;&amp; (currChar &lt;= 'Z')) {
        result.append(&quot;_&quot;);
      }
  
      result.append(currChar);
      if ((currChar &gt;= 'A') &amp;&amp; (currChar &lt;= 'Z')) {
        previousCap = true;
      } else {
        previousCap = false;
      }
    }
  
    //this is in upper-case
    return result.toString().toUpperCase();
  }

  
  /**
   * see if two maps are the equivalent (based on number of entries, 
   * and the equals() method of the keys and values)
   * @param &lt;K&gt; 
   * @param &lt;V&gt; 
   * @param first
   * @param second
   * @return true if equal
   */
  public static &lt;K,V&gt; boolean mapEquals(Map&lt;K,V&gt; first, Map&lt;K,V&gt; second) {
    Set&lt;K&gt; keysMismatch = new HashSet&lt;K&gt;();
    mapDifferences(first, second, keysMismatch, null);
    //if any keys mismatch, then not equal
    return keysMismatch.size() == 0;
    
  }
  
  /**
   * empty map
   */
  private static final Map EMPTY_MAP = Collections.unmodifiableMap(new HashMap());
  
  /**
   * see if two maps are the equivalent (based on number of entries, 
   * and the equals() method of the keys and values)
   * @param &lt;K&gt; 
   * @param &lt;V&gt; 
   * @param first map to check diffs
   * @param second map to check diffs
   * @param differences set of keys (with prefix) of the diffs
   * @param prefix for the entries in the diffs (e.g. &quot;attribute__&quot;
   */
  @SuppressWarnings(&quot;unchecked&quot;)
  public static &lt;K,V&gt; void mapDifferences(Map&lt;K,V&gt; first, Map&lt;K,V&gt; second, Set&lt;K&gt; differences, String prefix) {
    if (first == second) {
      return;
    }
    //put the collections in new collections so we can remove and keep track
    if (first == null) {
      first = EMPTY_MAP;
    }
    if (second == null) {
      second = EMPTY_MAP;
    } else {
      //make linked so the results are ordered
      second = new LinkedHashMap&lt;K,V&gt;(second);
    }
    int firstSize = first == null ? 0 : first.size();
    int secondSize = second == null ? 0 : second.size();
    //if both empty then all good
    if (firstSize == 0 &amp;&amp; secondSize == 0) {
      return;
    }
   
    for (K key : first.keySet()) {

      if (second.containsKey(key)) {
        V firstValue = first.get(key);
        V secondValue = second.get(key);
        //keep track by removing from second
        second.remove(key);
        if (equals(firstValue, secondValue)) {
          continue;
        }
      }
      differences.add(isNotBlank(prefix) ? (K)(prefix + key) : key);
    }
    //add the ones left over in the second map which are not in the first map
    for (K key : second.keySet()) {
      differences.add(isNotBlank(prefix) ? (K)(prefix + key) : key);
    }
  }
  
  /**
   * sleep, if interrupted, throw runtime
   * @param millis
   */
  public static void sleep(long millis) {
    try {
      Thread.sleep(millis);
    } catch (InterruptedException ie) {
      throw new RuntimeException(ie);
    }
  }
  
  /**
   * If we can, inject this into the exception, else return false
   * @param t
   * @param message
   * @return true if success, false if not
   */
  public static boolean injectInException(Throwable t, String message) {
    
    String throwableFieldName = &quot;detailMessage&quot;;

    try {
      String currentValue = t.getMessage();
      if (!isBlank(currentValue)) {
        currentValue += &quot;,\n&quot; + message;
      } else {
        currentValue = message;
      }
      assignField(t, throwableFieldName, currentValue);
      return true;
    } catch (Throwable t2) {
      //dont worry about what the problem is, return false so the caller can log
      return false;
    }
    
  }
  
  /**
   * get a unique string identifier based on the current time,
   * this is not globally unique, just unique for as long as this
   * server is running...
   * 
   * @return String
   */
  public static String uniqueId() {
    //this needs to be threadsafe since we are using a static field
    synchronized (ConfigPropertiesCascadeCommonUtils.class) {</pre></div></td></tr></table>
<table border="0" class="bodyTable">
<tr class="a">
<th>File</th>
<th>Line</th></tr>
<tr class="b">
<td>edu\internet2\middleware\grouperClient\config\ConfigPropertiesCascadeCommonUtils.java</td>
<td><a href="./xref/edu/internet2/middleware/grouperClient/config/ConfigPropertiesCascadeCommonUtils.html#L4911">4911</a></td></tr>
<tr class="a">
<td>edu\internet2\middleware\grouperClient\util\GrouperClientCommonUtils.java</td>
<td><a href="./xref/edu/internet2/middleware/grouperClient/util/GrouperClientCommonUtils.html#L4974">4974</a></td></tr>
<tr class="b"><td colspan='2'>
<div>
<pre>      copy(inputStream, stringWriter, &quot;UTF-8&quot;);
    } catch (IOException ioe) {
      throw new RuntimeException(&quot;Error reading resource: '&quot; + resourceName + &quot;'&quot;, ioe);
    } finally {
      closeQuietly(inputStream);
      closeQuietly(stringWriter);
    }
    return stringWriter.toString();
  }

  /**
   * read resource into string
   * @param resourceName
   * @param classInJar if not null, then look for the jar where this file is, and look in the same dir
   * @return the properties or null if not exist
   */
  public static String readResourceIntoString(String resourceName, Class&lt;?&gt; classInJar) {

    try {
      return readResourceIntoString(resourceName, false);
    } catch (Exception e) {
      //try from jar location
    }
  
    //lets look next to jar
    File jarFile = classInJar == null ? null : jarFile(classInJar);
    File parentDir = jarFile == null ? null : jarFile.getParentFile();
    String fileName = parentDir == null ? null 
        : (stripLastSlashIfExists(fileCanonicalPath(parentDir)) + File.separator + resourceName);
    File configFile = fileName == null ? null 
        : new File(fileName);

    return readFileIntoString(configFile);
  }

  /**
   * &lt;p&gt;
   * Reads the contents of a file into a String.
   * &lt;/p&gt;
   * &lt;p&gt;
   * There is no readFileToString method without encoding parameter because
   * the default encoding can differ between platforms and therefore results
   * in inconsistent results.
   * &lt;/p&gt;
   *
   * @param file the file to read.
   * @param encoding the encoding to use
   * @return The file contents or null if read failed.
   * @throws IOException in case of an I/O error
   */
  public static String readFileToString(File file, String encoding) throws IOException {
    InputStream in = new java.io.FileInputStream(file);
    try {
      return toString(in, encoding);
    } finally {
      closeQuietly(in);
    }
  }

  /**
   * replace all whitespace with space
   * @param input
   * @return the string
   */
  public static String replaceWhitespaceWithSpace(String input) {
    if (input == null) {
      return input;
    }
    return input.replaceAll(&quot;\\s+&quot;, &quot; &quot;);
  }

  /**
   * Unconditionally close an &lt;code&gt;InputStream&lt;/code&gt;.
   * Equivalent to {@link InputStream#close()}, except any exceptions will be ignored.
   * @param input A (possibly null) InputStream
   */
  public static void closeQuietly(InputStream input) {
    if (input == null) {
      return;
    }
  
    try {
      input.close();
    } catch (IOException ioe) {
    }
  }

  /**
   * Unconditionally close an &lt;code&gt;OutputStream&lt;/code&gt;.
   * Equivalent to {@link OutputStream#close()}, except any exceptions will be ignored.
   * @param output A (possibly null) OutputStream
   */
  public static void closeQuietly(OutputStream output) {
    if (output == null) {
      return;
    }
  
    try {
      output.close();
    } catch (IOException ioe) {
    }
  }

  /**
   * Unconditionally close an &lt;code&gt;Reader&lt;/code&gt;.
   * Equivalent to {@link Reader#close()}, except any exceptions will be ignored.
   *
   * @param input A (possibly null) Reader
   */
  public static void closeQuietly(Reader input) {
    if (input == null) {
      return;
    }
  
    try {
      input.close();
    } catch (IOException ioe) {
    }
  }

  /**
   * close a writer quietly
   * @param writer
   */
  public static void closeQuietly(Writer writer) {
    if (writer != null) {
      try {
        writer.close();
      } catch (IOException e) {
        //swallow, its ok
      }
    }
  }

  /**
   * Get the contents of an &lt;code&gt;InputStream&lt;/code&gt; as a String.
   * @param input the &lt;code&gt;InputStream&lt;/code&gt; to read from
   * @param encoding The name of a supported character encoding. See the
   *   &lt;a href=&quot;http://www.iana.org/assignments/character-sets&quot;&gt;IANA
   *   Charset Registry&lt;/a&gt; for a list of valid encoding types.
   * @return the requested &lt;code&gt;String&lt;/code&gt;
   * @throws IOException In case of an I/O problem
   */
  public static String toString(InputStream input, String encoding) throws IOException {
    StringWriter sw = new StringWriter();
    copy(input, sw, encoding);
    return sw.toString();
  }

  /**
   * Copy and convert bytes from an &lt;code&gt;InputStream&lt;/code&gt; to chars on a
   * &lt;code&gt;Writer&lt;/code&gt;, using the specified encoding.
   * @param input the &lt;code&gt;InputStream&lt;/code&gt; to read from
   * @param output the &lt;code&gt;Writer&lt;/code&gt; to write to
   * @param encoding The name of a supported character encoding. See the
   * &lt;a href=&quot;http://www.iana.org/assignments/character-sets&quot;&gt;IANA
   * Charset Registry&lt;/a&gt; for a list of valid encoding types.
   * @throws IOException In case of an I/O problem
   */
  public static void copy(InputStream input, Writer output, String encoding)
      throws IOException {
    InputStreamReader in = new InputStreamReader(input, encoding);
    copy(in, output);
  }

  /**
   * Copy chars from a &lt;code&gt;Reader&lt;/code&gt; to a &lt;code&gt;Writer&lt;/code&gt;.
   * @param input the &lt;code&gt;Reader&lt;/code&gt; to read from
   * @param output the &lt;code&gt;Writer&lt;/code&gt; to write to
   * @return the number of characters copied
   * @throws IOException In case of an I/O problem
   */
  public static int copy(Reader input, Writer output) throws IOException {
    char[] buffer = new char[DEFAULT_BUFFER_SIZE];
    int count = 0;
    int n = 0;
    while (-1 != (n = input.read(buffer))) {
      output.write(buffer, 0, n);
      count += n;
    }
    return count;
  }

  /**
   * this method takes a long (less than 62) and converts it to a 1 character
   * string (a-z, A-Z, 0-9)
   * 
   * @param theLong
   *          is the long (less than 62) to convert to a 1 character string
   * 
   * @return a one character string
   */
  public static String convertLongToChar(long theLong) {
    if ((theLong &lt; 0) || (theLong &gt;= 62)) {
      throw new RuntimeException(&quot;convertLongToChar() &quot;
          + &quot; invalid input (not &gt;=0 &amp;&amp; &lt;62: &quot; + theLong);
    } else if (theLong &lt; 26) {
      return &quot;&quot; + (char) ('a' + theLong);
    } else if (theLong &lt; 52) {
      return &quot;&quot; + (char) ('A' + (theLong - 26));
    } else {
      return &quot;&quot; + (char) ('0' + (theLong - 52));
    }
  }

  /**
   * this method takes a long (less than 36) and converts it to a 1 character
   * string (A-Z, 0-9)
   * 
   * @param theLong
   *          is the long (less than 36) to convert to a 1 character string
   * 
   * @return a one character string
   */
  public static String convertLongToCharSmall(long theLong) {
    if ((theLong &lt; 0) || (theLong &gt;= 36)) {
      throw new RuntimeException(&quot;convertLongToCharSmall() &quot;
          + &quot; invalid input (not &gt;=0 &amp;&amp; &lt;36: &quot; + theLong);
    } else if (theLong &lt; 26) {
      return &quot;&quot; + (char) ('A' + theLong);
    } else {
      return &quot;&quot; + (char) ('0' + (theLong - 26));
    }
  }

  /**
   * convert a long to a string by converting it to base 62 (26 lower, 26 upper,
   * 10 digits)
   * 
   * @param theLong
   *          is the long to convert
   * 
   * @return the String conversion of this
   */
  public static String convertLongToString(long theLong) {
    long quotient = theLong / 62;
    long remainder = theLong % 62;
  
    if (quotient == 0) {
      return convertLongToChar(remainder);
    }
    StringBuffer result = new StringBuffer();
    result.append(convertLongToString(quotient));
    result.append(convertLongToChar(remainder));
  
    return result.toString();
  }

  /**
   * convert a long to a string by converting it to base 36 (26 upper, 10
   * digits)
   * 
   * @param theLong
   *          is the long to convert
   * 
   * @return the String conversion of this
   */
  public static String convertLongToStringSmall(long theLong) {
    long quotient = theLong / 36;
    long remainder = theLong % 36;
  
    if (quotient == 0) {
      return convertLongToCharSmall(remainder);
    }
    StringBuffer result = new StringBuffer();
    result.append(convertLongToStringSmall(quotient));
    result.append(convertLongToCharSmall(remainder));
  
    return result.toString();
  }

  /**
   * increment a character (A-Z then 0-9)
   * 
   * @param theChar
   * 
   * @return the value
   */
  public static char incrementChar(char theChar) {
    if (theChar == 'Z') {
      return '0';
    }
  
    if (theChar == '9') {
      return 'A';
    }
  
    return ++theChar;
  }

  /**
   * Increment a string with A-Z and 0-9 (no lower case so case insensitive apps
   * like windows IE will still work)
   * 
   * @param string
   * 
   * @return the value
   */
  public static char[] incrementStringInt(char[] string) {
    if (string == null) {
      return string;
    }
  
    //loop through the string backwards
    int i = 0;
  
    for (i = string.length - 1; i &gt;= 0; i--) {
      char inc = string[i];
      inc = incrementChar(inc);
      string[i] = inc;
  
      if (inc != 'A') {
        break;
      }
    }
  
    //if we are at 0, then it means we hit AAAAAAA (or more)
    if (i &lt; 0) {
      return (&quot;A&quot; + new String(string)).toCharArray();
    }
  
    return string;
  }

  /**
   * read properties from a resource, dont modify the properties returned since they are cached
   * @param resourceName
   * @return the properties
   */
  public synchronized static Properties propertiesFromResourceName(String resourceName) {
    return propertiesFromResourceName(resourceName, true, true, null, null);
  }</pre></div></td></tr></table>
<table border="0" class="bodyTable">
<tr class="a">
<th>File</th>
<th>Line</th></tr>
<tr class="b">
<td>edu\internet2\middleware\grouperClient\config\ConfigPropertiesCascadeCommonUtils.java</td>
<td><a href="./xref/edu/internet2/middleware/grouperClient/config/ConfigPropertiesCascadeCommonUtils.html#L7453">7453</a></td></tr>
<tr class="a">
<td>edu\internet2\middleware\grouperClient\util\GrouperClientCommonUtils.java</td>
<td><a href="./xref/edu/internet2/middleware/grouperClient/util/GrouperClientCommonUtils.html#L7552">7552</a></td></tr>
<tr class="b"><td colspan='2'>
<div>
<pre>    }
    return null;
  }

  /**
   * strip the last slash (/ or \) from a string if it exists
   * 
   * @param input
   * 
   * @return input - the last / or \
   */
  public static String stripLastSlashIfExists(String input) {
    if ((input == null) || (input.length() == 0)) {
      return null;
    }

    char lastChar = input.charAt(input.length() - 1);

    if ((lastChar == '\\') || (lastChar == '/')) {
      return input.substring(0, input.length() - 1);
    }

    return input;
  }

  /**
   * retrieve a password from stdin
   * @param dontMask
   * @param prompt to print to user
   * @return the password
   */
  public static String retrievePasswordFromStdin(boolean dontMask, String prompt) {
    String passwordString = null;

    if (dontMask) {

      System.out.print(prompt);
      //  open up standard input 
      BufferedReader br = new BufferedReader(new InputStreamReader(System.in)); 

      //  read the username from the command-line; need to use try/catch with the 
      //  readLine() method 
      try { 
         passwordString = br.readLine(); 
      } catch (IOException ioe) { 
         System.out.println(&quot;IO error! &quot; + getFullStackTrace(ioe));
         System.exit(1); 
      } 

    } else {
      char password[] = null;
      try {
        password = retrievePasswordFromStdin(System.in, prompt);
      } catch (IOException ioe) {
        ioe.printStackTrace();
      }
      passwordString = String.valueOf(password);
    } 
    return passwordString;
    
  }

  /**
   * @param in stream to be used (e.g. System.in)
   * @param prompt The prompt to display to the user.
   * @return The password as entered by the user.
   * @throws IOException 
   */
  public static final char[] retrievePasswordFromStdin(InputStream in, String prompt) throws IOException {
    MaskingThread maskingthread = new MaskingThread(prompt);

    Thread thread = new Thread(maskingthread);
    thread.start();

    char[] lineBuffer;
    char[] buf;

    buf = lineBuffer = new char[128];

    int room = buf.length;
    int offset = 0;
    int c;

    loop: while (true) {
      switch (c = in.read()) {
        case -1:
        case '\n':
          break loop;

        case '\r':
          int c2 = in.read();
          if ((c2 != '\n') &amp;&amp; (c2 != -1)) {
            if (!(in instanceof PushbackInputStream)) {
              in = new PushbackInputStream(in);
            }
            ((PushbackInputStream) in).unread(c2);
          } else {
            break loop;
          }

        default:
          if (--room &lt; 0) {
            buf = new char[offset + 128];
            room = buf.length - offset - 1;
            System.arraycopy(lineBuffer, 0, buf, 0, offset);
            Arrays.fill(lineBuffer, ' ');
            lineBuffer = buf;
          }
          buf[offset++] = (char) c;
          break;
      }
    }
    maskingthread.stopMasking();
    if (offset == 0) {
      return null;
    }
    char[] ret = new char[offset];
    System.arraycopy(buf, 0, ret, 0, offset);
    Arrays.fill(buf, ' ');
    return ret;
  }

  /**
   * thread to mask input
   */
  static class MaskingThread extends Thread {

    /** stop */
    private volatile boolean stop;

    /** echo char, this doesnt work correctly, so make a space so people dont notice...  
     * prints out too many */
    private char echochar = ' ';

    /**
     *@param prompt The prompt displayed to the user
     */
    public MaskingThread(String prompt) {
      System.out.print(prompt);
    }

    /**
     * Begin masking until asked to stop.
     */
    @Override
    public void run() {

      int priority = Thread.currentThread().getPriority();
      Thread.currentThread().setPriority(Thread.MAX_PRIORITY);

      try {
        this.stop = true;
        while (this.stop) {
          System.out.print(&quot;\010&quot; + this.echochar);
          try {
            // attempt masking at this rate
            Thread.sleep(1);
          } catch (InterruptedException iex) {
            Thread.currentThread().interrupt();
            return;
          }
        }
      } finally { // restore the original priority
        Thread.currentThread().setPriority(priority);
      }
    }

    /**
     * Instruct the thread to stop masking.
     */
    public void stopMasking() {
      this.stop = false;
    }
  }

  /**
   * make sure a value exists in properties
   * @param resourceName
   * @param properties 
   * @param overrideMap 
   * @param key
   * @param exceptionOnError 
   * @return true if ok, false if not
   */
  public static boolean propertyValidateValueRequired(String resourceName, Properties properties, 
      Map&lt;String, String&gt; overrideMap, String key, boolean exceptionOnError) {
    
    Map&lt;String, String&gt; threadLocalMap = propertiesThreadLocalOverrideMap(resourceName);

    String value = propertiesValue(properties, threadLocalMap, overrideMap, key);

    if (!isBlank(value)) {
      return true;
    }
    String error = &quot;Cant find property &quot; + key + &quot; in resource: &quot; + resourceName + &quot;, it is required&quot;;
    
    if (exceptionOnError) {
      throw new RuntimeException(error);
    }
    
    System.err.println(&quot;Grouper error: &quot; + error);</pre></div></td></tr></table>
<table border="0" class="bodyTable">
<tr class="a">
<th>File</th>
<th>Line</th></tr>
<tr class="b">
<td>edu\internet2\middleware\grouperClient\config\ConfigPropertiesCascadeCommonUtils.java</td>
<td><a href="./xref/edu/internet2/middleware/grouperClient/config/ConfigPropertiesCascadeCommonUtils.html#L4333">4333</a></td></tr>
<tr class="a">
<td>edu\internet2\middleware\grouperClient\util\GcElUtilsSafe.java</td>
<td><a href="./xref/edu/internet2/middleware/grouperClient/util/GcElUtilsSafe.html#L2811">2811</a></td></tr>
<tr class="b">
<td>edu\internet2\middleware\grouperClient\util\GrouperClientCommonUtils.java</td>
<td><a href="./xref/edu/internet2/middleware/grouperClient/util/GrouperClientCommonUtils.html#L4396">4396</a></td></tr>
<tr class="a"><td colspan='2'>
<div>
<pre>        return dateFormat().parse(input);
      }
      if (!contains(input, '.')) {
        if (contains(input, '/')) {
          return dateMinutesSecondsFormat.parse(input);
        }
        //else no slash
        return dateMinutesSecondsNoSlashFormat.parse(input);
      }
      if (contains(input, '/')) {
        //see if the period is 6 back
        int lastDotIndex = input.lastIndexOf('.');
        if (lastDotIndex == input.length() - 7) {
          String nonNanoInput = input.substring(0,input.length()-3);
          Date date = timestampFormat.parse(nonNanoInput);
          //get the last 3
          String lastThree = input.substring(input.length()-3,input.length());
          int lastThreeInt = Integer.parseInt(lastThree);
          Timestamp timestamp = new Timestamp(date.getTime());
          timestamp.setNanos(timestamp.getNanos() + (lastThreeInt * 1000));
          return timestamp;
        }
        return timestampFormat.parse(input);
      }
      //else no slash
      return timestampNoSlashFormat.parse(input);
    } catch (ParseException pe) {
      throw new RuntimeException(errorStart + input);
    }
  }

  /**
   * start of error parsing messages
   */
  private static final String errorStart = &quot;Invalid timestamp, please use any of the formats: &quot;
    + DATE_FORMAT + &quot;, &quot; + TIMESTAMP_FORMAT 
    + &quot;, &quot; + DATE_MINUTES_SECONDS_FORMAT + &quot;: &quot;;

  /**
   * Convert an object to a byte, allow nulls
   * @param input
   * @return the boolean object value
   */
  public static BigDecimal bigDecimalObjectValue(Object input) {
    if (input instanceof BigDecimal) {
      return (BigDecimal)input;
    }
    if (isBlank(input)) {
      return null;
    }
    return BigDecimal.valueOf(doubleValue(input));
  }

  /**
   * Convert an object to a byte, allow nulls
   * @param input
   * @return the boolean object value
   */
  public static Byte byteObjectValue(Object input) {
    if (input instanceof Byte) {
      return (Byte)input;
    }
    if (isBlank(input)) {
      return null;
    }
    return Byte.valueOf(byteValue(input));
  }

  /**
   * convert an object to a byte
   * @param input
   * @return the byte
   */
  public static byte byteValue(Object input) {
    if (input instanceof String) {
      String string = (String)input;
      return Byte.parseByte(string);
    }
    if (input instanceof Number) {
      return ((Number)input).byteValue();
    }
    throw new RuntimeException(&quot;Cannot convert to byte: &quot; + className(input));
  }

  /**
   * get the Double value of an object
   * 
   * @param input
   *          is a number or String
   * @param allowNullBlank used to default to false, if true, return null if nul inputted 
   * 
   * @return the Double equivalent
   */
  public static Double doubleObjectValue(Object input, boolean allowNullBlank) {
  
    if (input instanceof Double) {
      return (Double) input;
    } 
    
    if (allowNullBlank &amp;&amp; isBlank(input)) {
      return null;
    }
    
    return Double.valueOf(doubleValue(input));
  }

  /**
   * get the double value of an object
   * 
   * @param input
   *          is a number or String
   * 
   * @return the double equivalent
   */
  public static double doubleValue(Object input) {
    if (input instanceof String) {
      String string = (String)input;
      return Double.parseDouble(string);
    }
    if (input instanceof Number) {
      return ((Number)input).doubleValue();
    }
    throw new RuntimeException(&quot;Cannot convert to double: &quot;  + className(input));
  }

  /**
   * get the double value of an object, do not throw an 
   * exception if there is an
   * error
   * 
   * @param input
   *          is a number or String
   * 
   * @return the double equivalent
   */
  public static double doubleValueNoError(Object input) {
    if (input == null || (input instanceof String 
        &amp;&amp; isBlank((String)input))) {
      return NOT_FOUND;
    }
  
    try {
      return doubleValue(input);
    } catch (Exception e) {
      //no need to log here
    }
  
    return NOT_FOUND;
  }

  /**
   * get the Float value of an object
   * 
   * @param input
   *          is a number or String
   * @param allowNullBlank true if allow null or blank
   * 
   * @return the Float equivalent
   */
  public static Float floatObjectValue(Object input, boolean allowNullBlank) {
  
    if (input instanceof Float) {
      return (Float) input;
    } 
  
    if (allowNullBlank &amp;&amp; isBlank(input)) {
      return null;
    }
    return Float.valueOf(floatValue(input));
  }

  /**
   * get the float value of an object
   * 
   * @param input
   *          is a number or String
   * 
   * @return the float equivalent
   */
  public static float floatValue(Object input) {
    if (input instanceof String) {
      String string = (String)input;
      return Float.parseFloat(string);
    }
    if (input instanceof Number) {
      return ((Number)input).floatValue();
    }
    throw new RuntimeException(&quot;Cannot convert to float: &quot; + className(input));
  }

  /**
   * get the float value of an object, do not throw an exception if there is an
   * error
   * 
   * @param input
   *          is a number or String
   * 
   * @return the float equivalent
   */
  public static float floatValueNoError(Object input) {
    if (input == null || (input instanceof String 
        &amp;&amp; isBlank((String)input))) {
      return NOT_FOUND;
    }
    try {
      return floatValue(input);
    } catch (Exception e) {</pre></div></td></tr></table>
<table border="0" class="bodyTable">
<tr class="b">
<th>File</th>
<th>Line</th></tr>
<tr class="a">
<td>edu\internet2\middleware\grouperClient\config\ConfigPropertiesCascadeCommonUtils.java</td>
<td><a href="./xref/edu/internet2/middleware/grouperClient/config/ConfigPropertiesCascadeCommonUtils.html#L9073">9073</a></td></tr>
<tr class="b">
<td>edu\internet2\middleware\grouperClient\util\GrouperClientCommonUtils.java</td>
<td><a href="./xref/edu/internet2/middleware/grouperClient/util/GrouperClientCommonUtils.html#L9185">9185</a></td></tr>
<tr class="a"><td colspan='2'>
<div>
<pre>      if (deleteFileOnException) {
        //close before deleting
        closeQuietly(ois);
        ois = null;
        deleteFile(file);
      }
      return null;
    } finally {
      closeQuietly(ois);
    }
    
  }
  
  /**
   * delete and create a new file.  If its a directory, delete, and create a new dir.
   * 
   * @param file
   *          is the file to delete and create
   */
  public static void deleteCreateFile(File file) {

    deleteFile(file);

    createParentDirectories(file);

    try {
      if (!file.createNewFile()) {
        throw new IOException(&quot;createNewFile returned false: &quot;);
      }
    } catch (IOException ioe) {
      throw new RuntimeException(&quot;Couldnt create new file: &quot; + file.toString(), ioe);
    }

  }

  /**
   * Delete a file, throw exception if cannot
   * @param file
   */
  public static void deleteFile(File file) {
    //delete and create
    if (file != null &amp;&amp; file.exists()) {

      if (file.isDirectory()) {
        deleteRecursiveDirectory(file.getAbsolutePath());
      } else if (!file.delete()) {
        throw new RuntimeException(&quot;Couldnt delete file: &quot; + file.toString());
      }
    }
  }

  /**
   * copy a file to a new file
   * @param fromFile
   * @param toFile
   */
  public static void copy(File fromFile, File toFile) {
    if (toFile.exists()) {
      deleteFile(toFile);
    }
    FileInputStream fromFileStream = null;
    FileOutputStream toFileStream = null;
    try {
      fromFileStream = new FileInputStream(fromFile);
      toFileStream = new FileOutputStream(toFile);
      copy(fromFileStream, toFileStream);
    } catch (Exception e) {
      throw new RuntimeException(&quot;Problem copying file: &quot; + fromFile.getAbsolutePath() 
          + &quot; to file: &quot; + toFile.getAbsolutePath());
    }
    
  }

  /**
   * rename a file to another file and throw runtime exception if not ok
   * @param fromFile
   * @param toFile
   */
  public static void renameTo(File fromFile, File toFile) {

    if (!fromFile.renameTo(toFile)) {
      throw new RuntimeException(&quot;Cannot rename file: '&quot; + fromFile.getAbsolutePath() 
          + &quot;', to file: '&quot; + toFile.getAbsolutePath() + &quot;'&quot;);
    }

  }

  /**
   * clear out all files recursively in a directory, including the directory
   * itself
   * @param dirName
   * 
   * @throws RuntimeException
   *           when something goes wrong
   */
  public static void deleteRecursiveDirectory(String dirName) {
    //delete all files in the directory
    File dir = new File(dirName);

    //if it doesnt exist then we are done
    if (!dir.exists()) {
      return;
    }

    //see if its a directory
    if (!dir.isDirectory()) {
      throw new RuntimeException(&quot;The directory: &quot; + dirName + &quot; is not a directory&quot;);
    }

    //get the files into a vector
    File[] allFiles = dir.listFiles();

    //loop through the array
    for (int i = 0; i &lt; allFiles.length; i++) {
      if (-1 &lt; allFiles[i].getName().indexOf(&quot;..&quot;)) {
        continue; //dont go to the parent directory
      }

      if (allFiles[i].isFile()) {
        //delete the file
        if (!allFiles[i].delete()) {
          throw new RuntimeException(&quot;Could not delete file: &quot; + allFiles[i].getPath());
        }
      } else {
        //its a directory
        deleteRecursiveDirectory(allFiles[i].getPath());
      }
    }

    //delete the directory itself
    if (!dir.delete()) {
      throw new RuntimeException(&quot;Could not delete directory: &quot; + dir.getPath());
    }
  }

  /**
   * absolute path null safe
   * @param file
   * @return absolute path null safe
   */
  public static String absolutePath(File file) {
    return file == null ? null : file.getAbsolutePath();
  }


  /**
   * pattern to get the file path or resource location for a file
   */
  private static Pattern fileLocationPattern = Pattern.compile(&quot;^(file|classpath)\\s*:(.*)$&quot;);
  
  /**
   * file or classpath location
   * @param typeAndLocation
   * @return the inputstream
   */
  public static InputStream fileOrClasspathInputstream(String typeAndLocation, String logHint) {
    Matcher matcher = fileLocationPattern.matcher(typeAndLocation);
    if (!matcher.matches()) {
      throw new RuntimeException(logHint + &quot; must start with file: or classpath:&quot;);
    }
    String typeString = matcher.group(1);
    String location = trim(matcher.group(2));
    
    if (equals(typeString, &quot;file&quot;)) {
      File file = new File(location);
      if (!file.exists() || !file.isFile()) {
        throw new RuntimeException(logHint + &quot; File does not exist: &quot; + file.getAbsolutePath());
      }
      try {
        return new FileInputStream(file);
      } catch (Exception e) {
        throw new RuntimeException(logHint + &quot; Problem with file: &quot; + file.getAbsolutePath());
      }
    } else if (equals(typeString, &quot;classpath&quot;)) {
      if (!location.startsWith(&quot;/&quot;)) {
        location = &quot;/&quot; + location;
      }
      try {
        return ConfigPropertiesCascadeCommonUtils.class.getResourceAsStream(location);</pre></div></td></tr></table>
<table border="0" class="bodyTable">
<tr class="b">
<th>File</th>
<th>Line</th></tr>
<tr class="a">
<td>edu\internet2\middleware\grouperClient\ws\beans\WsRestAssignGrouperPrivilegesLiteRequest.java</td>
<td><a href="./xref/edu/internet2/middleware/grouperClient/ws/beans/WsRestAssignGrouperPrivilegesLiteRequest.html#L38">38</a></td></tr>
<tr class="b">
<td>edu\internet2\middleware\grouperClient\ws\beans\WsRestGetGrouperPrivilegesLiteRequest.java</td>
<td><a href="./xref/edu/internet2/middleware/grouperClient/ws/beans/WsRestGetGrouperPrivilegesLiteRequest.html#L33">33</a></td></tr>
<tr class="a"><td colspan='2'>
<div>
<pre>  private String clientVersion;
  
  /**
   * subject id of subject to search for privileges.  Mutually exclusive with subjectIdentifier
   */
  private String subjectId;
  
  /**
   * source id of subject object (optional)
   */
  private String subjectSourceId;
  
  /**
   * subject identifier of subject.  Mutuallyexclusive with subjectId
   */
  private String subjectIdentifier;
  
  /**
   * if this is a group privilege.  mutually exclusive with groupUuid
   */
  private String groupName;
  
  /**
   * if this is a group privilege.  mutually exclusive with groupName
   */
  private String groupUuid;
  
  /**
   * if this is a stem privilege.  mutually exclusive with stemUuid
   */
  private String stemName;
  
  /**
   * if this is a stem privilege.  mutually exclusive with stemName
   */
  private String stemUuid;
  
  /**
   * privilegeType (e.g. &quot;access&quot; for groups and &quot;naming&quot; for stems)
   */
  private String privilegeType;
  
  /**
   * (e.g. for groups: read, view, update, admin, optin, optout.  e.g. for stems:
   * stem, create)
   */
  private String privilegeName;
  
  /**
   * optional: is the subject id of subject to act as (if
   * proxying). Only pass one of actAsSubjectId or
   * actAsSubjectIdentifer
   */
  private String actAsSubjectId;
  
  /**
   * is source of act as subject to narrow the result and prevent
   * duplicates
   */
  private String actAsSubjectSourceId;
  
  /**
   * optional: is the subject identifier of subject to act as (if
   * proxying). Only pass one of actAsSubjectId or
   * actAsSubjectIdentifer
   */
  private String actAsSubjectIdentifier;
  
  /**
   * 
   */
  private String includeSubjectDetail;
  
  /**
   * additional subject attributes (data) to return.
   * If blank, whatever is configured in the grouper-ws.properties will be sent (comma separated)
   */
  private String subjectAttributeNames;
  
  /**
   * T or F as for if group detail should be included
   */
  private String includeGroupDetail;
  
  /**
   * reserved for future use
   */
  private String paramName0;
  
  /**
   * reserved for future use
   */
  private String paramValue0;
  
  /**
   * reserved for future use
   */
  private String paramName1;
  
  /**
   * reserved for future use
   */
  private String paramValue1;

  /**
   * version of the client.  Must be in GrouperWsVersion, e.g. v1_3_000
   * @return version
   */
  public String getClientVersion() {
    return this.clientVersion;
  }

  /**
   * 
   * @param clientVersion1
   */
  public void setClientVersion(String clientVersion1) {
    this.clientVersion = clientVersion1;
  }

  /**
   * subject id of subject to search for privileges.  Mutually exclusive with subjectIdentifier
   * @return subjectid
   */
  public String getSubjectId() {
    return this.subjectId;
  }

  /**
   * subject id of subject to search for privileges.  Mutually exclusive with subjectIdentifier
   * @param subjectId1
   */
  public void setSubjectId(String subjectId1) {
    this.subjectId = subjectId1;
  }

  /**
   * source id of subject object (optional)
   * @return source id
   */
  public String getSubjectSourceId() {
    return this.subjectSourceId;
  }

  /**
   * source id of subject object (optional)
   * @param subjectSourceId1
   */
  public void setSubjectSourceId(String subjectSourceId1) {
    this.subjectSourceId = subjectSourceId1;
  }

  /**
   * subject identifier of subject.  Mutuallyexclusive with subjectId
   * @return id
   */
  public String getSubjectIdentifier() {
    return this.subjectIdentifier;
  }

  /**
   * subject identifier of subject.  Mutuallyexclusive with subjectId
   * @param subjectIdentifier1
   */
  public void setSubjectIdentifier(String subjectIdentifier1) {
    this.subjectIdentifier = subjectIdentifier1;
  }

  /**
   * if this is a group privilege.  mutually exclusive with groupUuid
   * @return name
   */
  public String getGroupName() {
    return this.groupName;
  }

  /**
   * if this is a group privilege.  mutually exclusive with groupUuid
   * @param groupName1
   */
  public void setGroupName(String groupName1) {
    this.groupName = groupName1;
  }

  /**
   * if this is a group privilege.  mutually exclusive with groupName
   * @return uuid
   */
  public String getGroupUuid() {
    return this.groupUuid;
  }

  /**
   * if this is a group privilege.  mutually exclusive with groupName
   * @param groupUuid1
   */
  public void setGroupUuid(String groupUuid1) {
    this.groupUuid = groupUuid1;
  }

  /**
   * if this is a stem privilege.  mutually exclusive with stemUuid
   * @return name
   */
  public String getStemName() {
    return this.stemName;
  }

  /**
   * if this is a stem privilege.  mutually exclusive with stemUuid
   * @param stemName1
   */
  public void setStemName(String stemName1) {
    this.stemName = stemName1;
  }

  /**
   * if this is a stem privilege.  mutually exclusive with stemName
   * @return stem uuid
   */
  public String getStemUuid() {
    return this.stemUuid;
  }

  /**
   * if this is a stem privilege.  mutually exclusive with stemName
   * @param stemUuid1
   */
  public void setStemUuid(String stemUuid1) {
    this.stemUuid = stemUuid1;
  }

  /**
   * privilegeType (e.g. &quot;access&quot; for groups and &quot;naming&quot; for stems)
   * @return type
   */
  public String getPrivilegeType() {
    return this.privilegeType;
  }

  /**
   * privilegeType (e.g. &quot;access&quot; for groups and &quot;naming&quot; for stems)
   * @param privilegeType1
   */
  public void setPrivilegeType(String privilegeType1) {
    this.privilegeType = privilegeType1;
  }

  /**
   * (e.g. for groups: read, view, update, admin, optin, optout.  e.g. for stems:
   * stem, create)
   * @return name
   */
  public String getPrivilegeName() {
    return this.privilegeName;
  }

  /**
   * (e.g. for groups: read, view, update, admin, optin, optout.  e.g. for stems:
   * stem, create)
   * @param privilegeName1
   */
  public void setPrivilegeName(String privilegeName1) {
    this.privilegeName = privilegeName1;
  }

  /**
   * optional: is the subject id of subject to act as (if
   * proxying). Only pass one of actAsSubjectId or
   * actAsSubjectIdentifer
   * @return id
   */
  public String getActAsSubjectId() {
    return this.actAsSubjectId;
  }

  /**
   * optional: is the subject id of subject to act as (if
   * proxying). Only pass one of actAsSubjectId or
   * actAsSubjectIdentifer
   * @param actAsSubjectId1
   */
  public void setActAsSubjectId(String actAsSubjectId1) {
    this.actAsSubjectId = actAsSubjectId1;
  }

  /**
   * is source of act as subject to narrow the result and prevent
   * duplicates
   * @return id
   */
  public String getActAsSubjectSourceId() {
    return this.actAsSubjectSourceId;
  }

  /**
   * is source of act as subject to narrow the result and prevent
   * duplicates
   * @param actAsSubjectSourceId1
   */
  public void setActAsSubjectSourceId(String actAsSubjectSourceId1) {
    this.actAsSubjectSourceId = actAsSubjectSourceId1;
  }

  /**
   * optional: is the subject identifier of subject to act as (if
   * proxying). Only pass one of actAsSubjectId or
   * actAsSubjectIdentifer
   * @return id
   */
  public String getActAsSubjectIdentifier() {
    return this.actAsSubjectIdentifier;
  }

  /**
   * optional: is the subject identifier of subject to act as (if
   * proxying). Only pass one of actAsSubjectId or
   * actAsSubjectIdentifer
   * @param actAsSubjectIdentifier1
   */
  public void setActAsSubjectIdentifier(String actAsSubjectIdentifier1) {
    this.actAsSubjectIdentifier = actAsSubjectIdentifier1;
  }

  /**
   * T|F, for if the extended subject information should be
   * returned (anything more than just the id)
   * @return include detail
   */
  public String getIncludeSubjectDetail() {
    return this.includeSubjectDetail;
  }

  /**
   * T|F, for if the extended subject information should be
   * returned (anything more than just the id)
   * @param includeSubjectDetail1
   */
  public void setIncludeSubjectDetail(String includeSubjectDetail1) {
    this.includeSubjectDetail = includeSubjectDetail1;
  }

  /**
   * additional subject attributes (data) to return.
   * If blank, whatever is configured in the grouper-ws.properties will be sent (comma separated)
   * @return names to return
   */
  public String getSubjectAttributeNames() {
    return this.subjectAttributeNames;
  }

  /**
   * additional subject attributes (data) to return.
   * If blank, whatever is configured in the grouper-ws.properties will be sent (comma separated)
   * @param subjectAttributeNames1
   */
  public void setSubjectAttributeNames(String subjectAttributeNames1) {
    this.subjectAttributeNames = subjectAttributeNames1;
  }

  /**
   * T or F as for if group detail should be included
   * @return T of F
   */
  public String getIncludeGroupDetail() {
    return this.includeGroupDetail;
  }

  /**
   * T or F as for if group detail should be included
   * @param includeGroupDetail1
   */
  public void setIncludeGroupDetail(String includeGroupDetail1) {
    this.includeGroupDetail = includeGroupDetail1;
  }

  /**
   * reserved for future use
   * @return param
   */
  public String getParamName0() {
    return this.paramName0;
  }

  /**
   * reserved for future use
   * @param _paramName0
   */
  public void setParamName0(String _paramName0) {
    this.paramName0 = _paramName0;
  }

  /**
   * reserved for future use
   * @return param
   */
  public String getParamValue0() {
    return this.paramValue0;
  }

  /**
   * reserved for future use
   * @param _paramValue0
   */
  public void setParamValue0(String _paramValue0) {
    this.paramValue0 = _paramValue0;
  }

  /**
   * reserved for future use
   * @return param
   */
  public String getParamName1() {
    return this.paramName1;
  }

  /**
   * reserved for future use
   * @param _paramName1
   */
  public void setParamName1(String _paramName1) {
    this.paramName1 = _paramName1;
  }

  /**
   * reserved for future use
   * @return param
   */
  public String getParamValue1() {
    return this.paramValue1;
  }

  /**
   * reserved for future use
   * @param _paramValue1
   */
  public void setParamValue1(String _paramValue1) {
    this.paramValue1 = _paramValue1;
  }</pre></div></td></tr></table>
<table border="0" class="bodyTable">
<tr class="b">
<th>File</th>
<th>Line</th></tr>
<tr class="a">
<td>edu\internet2\middleware\grouperClient\config\ConfigPropertiesCascadeCommonUtils.java</td>
<td><a href="./xref/edu/internet2/middleware/grouperClient/config/ConfigPropertiesCascadeCommonUtils.html#L5805">5805</a></td></tr>
<tr class="b">
<td>edu\internet2\middleware\grouperClient\util\GcElUtilsSafe.java</td>
<td><a href="./xref/edu/internet2/middleware/grouperClient/util/GcElUtilsSafe.html#L3487">3487</a></td></tr>
<tr class="a">
<td>edu\internet2\middleware\grouperClient\util\GrouperClientCommonUtils.java</td>
<td><a href="./xref/edu/internet2/middleware/grouperClient/util/GrouperClientCommonUtils.html#L5882">5882</a></td></tr>
<tr class="b"><td colspan='2'>
<div>
<pre>  }
  

  /**
   * null safe string compare
   * @param first
   * @param second
   * @return true if equal
   */
  public static boolean equals(String first, String second) {
    if (first == second) {
      return true;
    }
    if (first == null || second == null) {
      return false;
    }
    return first.equals(second);
  }

  /**
   * &lt;p&gt;Checks if a String is whitespace, empty (&quot;&quot;) or null.&lt;/p&gt;
   *
   * &lt;pre&gt;
   * isBlank(null)      = true
   * isBlank(&quot;&quot;)        = true
   * isBlank(&quot; &quot;)       = true
   * isBlank(&quot;bob&quot;)     = false
   * isBlank(&quot;  bob  &quot;) = false
   * &lt;/pre&gt;
   *
   * @param str  the String to check, may be null
   * @return &lt;code&gt;true&lt;/code&gt; if the String is null, empty or whitespace
   * @since 2.0
   */
  public static boolean isBlank(String str) {
    int strLen;
    if (str == null || (strLen = str.length()) == 0) {
      return true;
    }
    for (int i = 0; i &lt; strLen; i++) {
      if ((Character.isWhitespace(str.charAt(i)) == false)) {
        return false;
      }
    }
    return true;
  }

  /**
   * 
   * @param str
   * @return true if not blank
   */
  public static boolean isNotBlank(String str) {
    return !isBlank(str);
  }

  /**
   * trim whitespace from string
   * @param str
   * @return trimmed string
   */
  public static String trim(String str) {
    return str == null ? null : str.trim();
  }

  /**
   * equalsignorecase
   * @param str1
   * @param str2
   * @return true if the strings are equal ignore case
   */
  public static boolean equalsIgnoreCase(String str1, String str2) {
    return str1 == null ? str2 == null : str1.equalsIgnoreCase(str2);
  }

  /**
   * trim to empty, convert null to empty
   * @param str
   * @return trimmed
   */
  public static String trimToEmpty(String str) {
    return str == null ? &quot;&quot; : str.trim();
  }

  /**
   * &lt;p&gt;Abbreviates a String using ellipses. This will turn
   * &quot;Now is the time for all good men&quot; into &quot;Now is the time for...&quot;&lt;/p&gt;
   *
   * &lt;p&gt;Specifically:
   * &lt;ul&gt;
   *   &lt;li&gt;If &lt;code&gt;str&lt;/code&gt; is less than &lt;code&gt;maxWidth&lt;/code&gt; characters
   *       long, return it.&lt;/li&gt;
   *   &lt;li&gt;Else abbreviate it to &lt;code&gt;(substring(str, 0, max-3) + &quot;...&quot;)&lt;/code&gt;.&lt;/li&gt;
   *   &lt;li&gt;If &lt;code&gt;maxWidth&lt;/code&gt; is less than &lt;code&gt;4&lt;/code&gt;, throw an
   *       &lt;code&gt;IllegalArgumentException&lt;/code&gt;.&lt;/li&gt;
   *   &lt;li&gt;In no case will it return a String of length greater than
   *       &lt;code&gt;maxWidth&lt;/code&gt;.&lt;/li&gt;
   * &lt;/ul&gt;
   * &lt;/p&gt;
   *
   * &lt;pre&gt;
   * StringUtils.abbreviate(null, *)      = null
   * StringUtils.abbreviate(&quot;&quot;, 4)        = &quot;&quot;
   * StringUtils.abbreviate(&quot;abcdefg&quot;, 6) = &quot;abc...&quot;
   * StringUtils.abbreviate(&quot;abcdefg&quot;, 7) = &quot;abcdefg&quot;
   * StringUtils.abbreviate(&quot;abcdefg&quot;, 8) = &quot;abcdefg&quot;
   * StringUtils.abbreviate(&quot;abcdefg&quot;, 4) = &quot;a...&quot;
   * StringUtils.abbreviate(&quot;abcdefg&quot;, 3) = IllegalArgumentException
   * &lt;/pre&gt;
   *
   * @param str  the String to check, may be null
   * @param maxWidth  maximum length of result String, must be at least 4
   * @return abbreviated String, &lt;code&gt;null&lt;/code&gt; if null String input
   * @throws IllegalArgumentException if the width is too small
   * @since 2.0
   */
  public static String abbreviate(String str, int maxWidth) {
    return abbreviate(str, 0, maxWidth);
  }

  /**
   * &lt;p&gt;Abbreviates a String using ellipses. This will turn
   * &quot;Now is the time for all good men&quot; into &quot;...is the time for...&quot;&lt;/p&gt;
   *
   * &lt;p&gt;Works like &lt;code&gt;abbreviate(String, int)&lt;/code&gt;, but allows you to specify
   * a &quot;left edge&quot; offset.  Note that this left edge is not necessarily going to
   * be the leftmost character in the result, or the first character following the
   * ellipses, but it will appear somewhere in the result.
   *
   * &lt;p&gt;In no case will it return a String of length greater than
   * &lt;code&gt;maxWidth&lt;/code&gt;.&lt;/p&gt;
   *
   * &lt;pre&gt;
   * StringUtils.abbreviate(null, *, *)                = null
   * StringUtils.abbreviate(&quot;&quot;, 0, 4)                  = &quot;&quot;
   * StringUtils.abbreviate(&quot;abcdefghijklmno&quot;, -1, 10) = &quot;abcdefg...&quot;
   * StringUtils.abbreviate(&quot;abcdefghijklmno&quot;, 0, 10)  = &quot;abcdefg...&quot;
   * StringUtils.abbreviate(&quot;abcdefghijklmno&quot;, 1, 10)  = &quot;abcdefg...&quot;
   * StringUtils.abbreviate(&quot;abcdefghijklmno&quot;, 4, 10)  = &quot;abcdefg...&quot;
   * StringUtils.abbreviate(&quot;abcdefghijklmno&quot;, 5, 10)  = &quot;...fghi...&quot;
   * StringUtils.abbreviate(&quot;abcdefghijklmno&quot;, 6, 10)  = &quot;...ghij...&quot;
   * StringUtils.abbreviate(&quot;abcdefghijklmno&quot;, 8, 10)  = &quot;...ijklmno&quot;
   * StringUtils.abbreviate(&quot;abcdefghijklmno&quot;, 10, 10) = &quot;...ijklmno&quot;
   * StringUtils.abbreviate(&quot;abcdefghijklmno&quot;, 12, 10) = &quot;...ijklmno&quot;
   * StringUtils.abbreviate(&quot;abcdefghij&quot;, 0, 3)        = IllegalArgumentException
   * StringUtils.abbreviate(&quot;abcdefghij&quot;, 5, 6)        = IllegalArgumentException
   * &lt;/pre&gt;
   *
   * @param str  the String to check, may be null
   * @param offset  left edge of source String
   * @param maxWidth  maximum length of result String, must be at least 4
   * @return abbreviated String, &lt;code&gt;null&lt;/code&gt; if null String input
   * @throws IllegalArgumentException if the width is too small
   * @since 2.0
   */
  public static String abbreviate(String str, int offset, int maxWidth) {
    if (str == null) {
      return null;
    }
    if (maxWidth &lt; 4) {
      throw new IllegalArgumentException(&quot;Minimum abbreviation width is 4&quot;);
    }
    if (str.length() &lt;= maxWidth) {
      return str;
    }
    if (offset &gt; str.length()) {
      offset = str.length();
    }
    if ((str.length() - offset) &lt; (maxWidth - 3)) {
      offset = str.length() - (maxWidth - 3);
    }
    if (offset &lt;= 4) {
      return str.substring(0, maxWidth - 3) + &quot;...&quot;;
    }
    if (maxWidth &lt; 7) {
      throw new IllegalArgumentException(&quot;Minimum abbreviation width with offset is 7&quot;);
    }
    if ((offset + (maxWidth - 3)) &lt; str.length()) {
      return &quot;...&quot; + abbreviate(str.substring(offset), maxWidth - 3);
    }
    return &quot;...&quot; + str.substring(str.length() - (maxWidth - 3));
  }

  // Splitting
  //-----------------------------------------------------------------------
  /**
   * &lt;p&gt;Splits the provided text into an array, using whitespace as the
   * separator.
   * Whitespace is defined by {@link Character#isWhitespace(char)}.&lt;/p&gt;
   *
   * &lt;p&gt;The separator is not included in the returned String array.
   * Adjacent separators are treated as one separator.
   * For more control over the split use the StrTokenizer class.&lt;/p&gt;
   *
   * &lt;p&gt;A &lt;code&gt;null&lt;/code&gt; input String returns &lt;code&gt;null&lt;/code&gt;.&lt;/p&gt;
   *
   * &lt;pre&gt;
   * StringUtils.split(null)       = null
   * StringUtils.split(&quot;&quot;)         = []
   * StringUtils.split(&quot;abc def&quot;)  = [&quot;abc&quot;, &quot;def&quot;]
   * StringUtils.split(&quot;abc  def&quot;) = [&quot;abc&quot;, &quot;def&quot;]
   * StringUtils.split(&quot; abc &quot;)    = [&quot;abc&quot;]
   * &lt;/pre&gt;
   *
   * @param str  the String to parse, may be null
   * @return an array of parsed Strings, &lt;code&gt;null&lt;/code&gt; if null String input
   */
  public static String[] split(String str) {
    return split(str, null, -1);
  }

  /**
   * &lt;p&gt;Splits the provided text into an array, separator specified.
   * This is an alternative to using StringTokenizer.&lt;/p&gt;
   *
   * &lt;p&gt;The separator is not included in the returned String array.
   * Adjacent separators are treated as one separator.
   * For more control over the split use the StrTokenizer class.&lt;/p&gt;
   *
   * &lt;p&gt;A &lt;code&gt;null&lt;/code&gt; input String returns &lt;code&gt;null&lt;/code&gt;.&lt;/p&gt;
   *
   * &lt;pre&gt;
   * StringUtils.split(null, *)         = null
   * StringUtils.split(&quot;&quot;, *)           = []
   * StringUtils.split(&quot;a.b.c&quot;, '.')    = [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;]
   * StringUtils.split(&quot;a..b.c&quot;, '.')   = [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;]
   * StringUtils.split(&quot;a:b:c&quot;, '.')    = [&quot;a:b:c&quot;]
   * StringUtils.split(&quot;a\tb\nc&quot;, null) = [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;]
   * StringUtils.split(&quot;a b c&quot;, ' ')    = [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;]
   * &lt;/pre&gt;
   *
   * @param str  the String to parse, may be null
   * @param separatorChar  the character used as the delimiter,
   *  &lt;code&gt;null&lt;/code&gt; splits on whitespace
   * @return an array of parsed Strings, &lt;code&gt;null&lt;/code&gt; if null String input
   * @since 2.0
   */
  public static String[] split(String str, char separatorChar) {
    return splitWorker(str, separatorChar, false);
  }

  /**
   * &lt;p&gt;Splits the provided text into an array, separators specified.
   * This is an alternative to using StringTokenizer.&lt;/p&gt;
   *
   * &lt;p&gt;The separator is not included in the returned String array.
   * Adjacent separators are treated as one separator.
   * For more control over the split use the StrTokenizer class.&lt;/p&gt;
   *
   * &lt;p&gt;A &lt;code&gt;null&lt;/code&gt; input String returns &lt;code&gt;null&lt;/code&gt;.
   * A &lt;code&gt;null&lt;/code&gt; separatorChars splits on whitespace.&lt;/p&gt;
   *
   * &lt;pre&gt;
   * StringUtils.split(null, *)         = null
   * StringUtils.split(&quot;&quot;, *)           = []
   * StringUtils.split(&quot;abc def&quot;, null) = [&quot;abc&quot;, &quot;def&quot;]
   * StringUtils.split(&quot;abc def&quot;, &quot; &quot;)  = [&quot;abc&quot;, &quot;def&quot;]
   * StringUtils.split(&quot;abc  def&quot;, &quot; &quot;) = [&quot;abc&quot;, &quot;def&quot;]
   * StringUtils.split(&quot;ab:cd:ef&quot;, &quot;:&quot;) = [&quot;ab&quot;, &quot;cd&quot;, &quot;ef&quot;]
   * &lt;/pre&gt;
   *
   * @param str  the String to parse, may be null
   * @param separatorChars  the characters used as the delimiters,
   *  &lt;code&gt;null&lt;/code&gt; splits on whitespace
   * @return an array of parsed Strings, &lt;code&gt;null&lt;/code&gt; if null String input
   */
  public static String[] split(String str, String separatorChars) {
    return splitWorker(str, separatorChars, -1, false);
  }

  /**
   * &lt;p&gt;Splits the provided text into an array with a maximum length,
   * separators specified.&lt;/p&gt;
   *
   * &lt;p&gt;The separator is not included in the returned String array.
   * Adjacent separators are treated as one separator.&lt;/p&gt;
   *
   * &lt;p&gt;A &lt;code&gt;null&lt;/code&gt; input String returns &lt;code&gt;null&lt;/code&gt;.
   * A &lt;code&gt;null&lt;/code&gt; separatorChars splits on whitespace.&lt;/p&gt;
   *
   * &lt;p&gt;If more than &lt;code&gt;max&lt;/code&gt; delimited substrings are found, the last
   * returned string includes all characters after the first &lt;code&gt;max - 1&lt;/code&gt;
   * returned strings (including separator characters).&lt;/p&gt;
   *
   * &lt;pre&gt;
   * StringUtils.split(null, *, *)            = null
   * StringUtils.split(&quot;&quot;, *, *)              = []
   * StringUtils.split(&quot;ab de fg&quot;, null, 0)   = [&quot;ab&quot;, &quot;cd&quot;, &quot;ef&quot;]
   * StringUtils.split(&quot;ab   de fg&quot;, null, 0) = [&quot;ab&quot;, &quot;cd&quot;, &quot;ef&quot;]
   * StringUtils.split(&quot;ab:cd:ef&quot;, &quot;:&quot;, 0)    = [&quot;ab&quot;, &quot;cd&quot;, &quot;ef&quot;]
   * StringUtils.split(&quot;ab:cd:ef&quot;, &quot;:&quot;, 2)    = [&quot;ab&quot;, &quot;cd:ef&quot;]
   * &lt;/pre&gt;
   *
   * @param str  the String to parse, may be null
   * @param separatorChars  the characters used as the delimiters,
   *  &lt;code&gt;null&lt;/code&gt; splits on whitespace
   * @param max  the maximum number of elements to include in the
   *  array. A zero or negative value implies no limit
   * @return an array of parsed Strings, &lt;code&gt;null&lt;/code&gt; if null String input
   */
  public static String[] split(String str, String separatorChars, int max) {
    return splitWorker(str, separatorChars, max, false);
  }

  /**
   * &lt;p&gt;Splits the provided text into an array, separator string specified.&lt;/p&gt;
   *
   * &lt;p&gt;The separator(s) will not be included in the returned String array.
   * Adjacent separators are treated as one separator.&lt;/p&gt;
   *
   * &lt;p&gt;A &lt;code&gt;null&lt;/code&gt; input String returns &lt;code&gt;null&lt;/code&gt;.
   * A &lt;code&gt;null&lt;/code&gt; separator splits on whitespace.&lt;/p&gt;
   *
   * &lt;pre&gt;
   * StringUtils.split(null, *)            = null
   * StringUtils.split(&quot;&quot;, *)              = []
   * StringUtils.split(&quot;ab de fg&quot;, null)   = [&quot;ab&quot;, &quot;de&quot;, &quot;fg&quot;]
   * StringUtils.split(&quot;ab   de fg&quot;, null) = [&quot;ab&quot;, &quot;de&quot;, &quot;fg&quot;]
   * StringUtils.split(&quot;ab:cd:ef&quot;, &quot;:&quot;)    = [&quot;ab&quot;, &quot;cd&quot;, &quot;ef&quot;]
   * StringUtils.split(&quot;abstemiouslyaeiouyabstemiously&quot;, &quot;aeiouy&quot;)  = [&quot;bst&quot;, &quot;m&quot;, &quot;sl&quot;, &quot;bst&quot;, &quot;m&quot;, &quot;sl&quot;]
   * StringUtils.split(&quot;abstemiouslyaeiouyabstemiously&quot;, &quot;aeiouy&quot;)  = [&quot;abstemiously&quot;, &quot;abstemiously&quot;]
   * &lt;/pre&gt;
   *
   * @param str  the String to parse, may be null
   * @param separator  String containing the String to be used as a delimiter,
   *  &lt;code&gt;null&lt;/code&gt; splits on whitespace
   * @return an array of parsed Strings, &lt;code&gt;null&lt;/code&gt; if null String was input
   */
  public static String[] splitByWholeSeparator(String str, String separator) {
    return splitByWholeSeparator(str, separator, -1);
  }</pre></div></td></tr></table>
<table border="0" class="bodyTable">
<tr class="a">
<th>File</th>
<th>Line</th></tr>
<tr class="b">
<td>edu\internet2\middleware\grouperClient\GrouperClient.java</td>
<td><a href="./xref/edu/internet2/middleware/grouperClient/GrouperClient.html#L3710">3710</a></td></tr>
<tr class="a">
<td>edu\internet2\middleware\grouperClient\GrouperClient.java</td>
<td><a href="./xref/edu/internet2/middleware/grouperClient/GrouperClient.html#L4166">4166</a></td></tr>
<tr class="b"><td colspan='2'>
<div>
<pre>    for (WsAttributeAssign wsAttributeAssign : GrouperClientUtils.nonNull(wsAttributeAssignmentsResults.getWsAttributeAssigns(), WsAttributeAssign.class)) {
      
      WsAttributeDef wsAttributeDef = attributeDefLookup.get(wsAttributeAssign.getAttributeDefId());
      WsAttributeDefName wsAttributeDefName = attributeDefNameLookup.get(wsAttributeAssign.getAttributeDefNameId());
      WsStem wsOwnerStem = stemLookup.get(wsAttributeAssign.getOwnerStemId());
      WsAttributeDef wsOwnerAttributeDef = attributeDefLookup.get(wsAttributeAssign.getOwnerAttributeDefId());
      WsMembership wsOwnerMembership = membershipLookup.get(wsAttributeAssign.getOwnerMembershipId());
      WsGroup wsOwnerGroup = groupLookup.get(wsAttributeAssign.getOwnerGroupId());
      MultiKey ownerSubjectKey = new MultiKey(wsAttributeAssign.getOwnerMemberSourceId(), wsAttributeAssign.getOwnerMemberSubjectId());
      WsSubject wsOwnerMemberSubject = subjectLookup.get(ownerSubjectKey);
      
      String ownerName = null;
      if (GrouperClientUtils.equals(&quot;group&quot;, wsAttributeAssign.getAttributeAssignType())) {
        ownerName = wsOwnerGroup.getName();
      } else if (GrouperClientUtils.equals(&quot;member&quot;, wsAttributeAssign.getAttributeAssignType())) {
        ownerName = wsAttributeAssign.getOwnerMemberSourceId() + &quot; - &quot; + wsAttributeAssign.getOwnerMemberSubjectId();
      } else if (GrouperClientUtils.equals(&quot;stem&quot;, wsAttributeAssign.getAttributeAssignType())) {
        ownerName = wsOwnerStem.getName();
      } else if (GrouperClientUtils.equals(&quot;any_mem&quot;, wsAttributeAssign.getAttributeAssignType())) {
        ownerName = wsOwnerGroup.getName() + &quot; - &quot; + wsAttributeAssign.getOwnerMemberSourceId() + &quot; - &quot; + wsAttributeAssign.getOwnerMemberSubjectId();
      } else if (GrouperClientUtils.equals(&quot;imm_mem&quot;, wsAttributeAssign.getAttributeAssignType())) {
        ownerName = wsAttributeAssign.getOwnerMembershipId();
      } else if (GrouperClientUtils.equals(&quot;attr_def&quot;, wsAttributeAssign.getAttributeAssignType())) {
        ownerName = wsOwnerAttributeDef.getName();
      } else if (wsAttributeAssign.getAttributeAssignType() != null &amp;&amp; wsAttributeAssign.getAttributeAssignType().endsWith(&quot;_asgn&quot;)) {
        ownerName = wsAttributeAssign.getOwnerAttributeAssignId();
      } else {
        throw new RuntimeException(&quot;Cant find attribute assign type: &quot; + wsAttributeAssign.getAttributeAssignType());
      }

      String valuesString = &quot;none&quot;;
      int valuesLength = GrouperClientUtils.length(wsAttributeAssign.getWsAttributeAssignValues());
      if (valuesLength &gt; 0) {
        StringBuilder valuesResult = new StringBuilder();
        for (int i=0;i&lt;valuesLength;i++) {
          WsAttributeAssignValue wsAttributeAssignValue = wsAttributeAssign.getWsAttributeAssignValues()[i];
          valuesResult.append(wsAttributeAssignValue.getValueSystem());
          if (i&lt;valuesLength-1) {
            valuesResult.append(&quot;,&quot;);
          }
        }
        valuesString = valuesResult.toString();
      }
      
      substituteMap.put(&quot;index&quot;, index);
      substituteMap.put(&quot;ownerName&quot;, ownerName);
      substituteMap.put(&quot;valuesString&quot;, valuesString);
      substituteMap.put(&quot;wsOwnerAttributeDef&quot;, wsOwnerAttributeDef);
      substituteMap.put(&quot;wsAttributeAssign&quot;, wsAttributeAssign);
      substituteMap.put(&quot;wsAttributeDef&quot;, wsAttributeDef);
      substituteMap.put(&quot;wsAttributeDefName&quot;, wsAttributeDefName);
      substituteMap.put(&quot;wsOwnerMemberSubject&quot;, wsOwnerMemberSubject);
      substituteMap.put(&quot;wsOwnerMembership&quot;, wsOwnerMembership);
      substituteMap.put(&quot;wsOwnerGroup&quot;, wsOwnerGroup);
      
      String output = GrouperClientUtils.substituteExpressionLanguage(outputTemplate, substituteMap);
      result.append(output);
      
      index++;
    }</pre></div></td></tr></table>
<table border="0" class="bodyTable">
<tr class="a">
<th>File</th>
<th>Line</th></tr>
<tr class="b">
<td>edu\internet2\middleware\grouperClient\config\ConfigPropertiesCascadeCommonUtils.java</td>
<td><a href="./xref/edu/internet2/middleware/grouperClient/config/ConfigPropertiesCascadeCommonUtils.html#L1323">1323</a></td></tr>
<tr class="a">
<td>edu\internet2\middleware\grouperClient\util\GcElUtilsSafe.java</td>
<td><a href="./xref/edu/internet2/middleware/grouperClient/util/GcElUtilsSafe.html#L1272">1272</a></td></tr>
<tr class="b">
<td>edu\internet2\middleware\grouperClient\util\GrouperClientCommonUtils.java</td>
<td><a href="./xref/edu/internet2/middleware/grouperClient/util/GrouperClientCommonUtils.html#L1386">1386</a></td></tr>
<tr class="a"><td colspan='2'>
<div>
<pre>  public static Iterator iterator(Object collection) {
    if (collection == null) {
      return null;
    }
    // array list doesnt need an iterator
    if (collection instanceof Collection
        &amp;&amp; !(collection instanceof ArrayList)) {
      return ((Collection) collection).iterator();
    }
    return null;
  }

  /**
   * Null safe array length or map
   * 
   * @param arrayOrCollection
   * @return the length of the array (0 for null)
   */
  public static int length(Object arrayOrCollection) {
    if (arrayOrCollection == null) {
      return 0;
    }
    if (arrayOrCollection.getClass().isArray()) {
      return Array.getLength(arrayOrCollection);
    }
    if (arrayOrCollection instanceof Collection) {
      return ((Collection) arrayOrCollection).size();
    }
    if (arrayOrCollection instanceof Map) {
      return ((Map) arrayOrCollection).size();
    }
    // simple non array non collection object
    return 1;
  }

  /**
   * If array, get the element based on index, if Collection, get it based on
   * iterator.
   * 
   * @param arrayOrCollection
   * @param iterator
   * @param index
   * @return the object
   */
  public static Object next(Object arrayOrCollection, Iterator iterator,
      int index) {
    if (arrayOrCollection.getClass().isArray()) {
      return Array.get(arrayOrCollection, index);
    }
    if (arrayOrCollection instanceof ArrayList) {
      return ((ArrayList) arrayOrCollection).get(index);
    }
    if (arrayOrCollection instanceof Collection) {
      return iterator.next();
    }
    // simple object
    if (0 == index) {
      return arrayOrCollection;
    }
    throw new RuntimeException(&quot;Invalid class type: &quot;
        + arrayOrCollection.getClass().getName());
  }

  /**
   * Remove the iterator or index
   * 
   * @param arrayOrCollection
   * @param index
   * @return the object list or new array
   */
  public static Object remove(Object arrayOrCollection, 
      int index) {
    return remove(arrayOrCollection, null, index);
  }
  
  /**
   * Remove the iterator or index
   * 
   * @param arrayOrCollection
   * @param iterator
   * @param index
   * @return the object list or new array
   */
  public static Object remove(Object arrayOrCollection, Iterator iterator,
      int index) {
    
    //if theres an iterator, just use that
    if (iterator != null) {
      iterator.remove();
      return arrayOrCollection;
    }
    if (arrayOrCollection.getClass().isArray()) {
      int newLength = Array.getLength(arrayOrCollection) - 1;
      Object newArray = Array.newInstance(arrayOrCollection.getClass().getComponentType(), newLength);
      if (newLength == 0) {
        return newArray;
      }
      if (index &gt; 0) {
        System.arraycopy(arrayOrCollection, 0, newArray, 0, index);
      }
      if (index &lt; newLength) {
        System.arraycopy(arrayOrCollection, index+1, newArray, index, newLength - index);
      }
      return newArray;
    }
    if (arrayOrCollection instanceof List) {
      ((List)arrayOrCollection).remove(index);
      return arrayOrCollection;
    } else if (arrayOrCollection instanceof Collection) {
      //this should work unless there are duplicates or something weird
      ((Collection)arrayOrCollection).remove(get(arrayOrCollection, index));
      return arrayOrCollection;
    }
    throw new RuntimeException(&quot;Invalid class type: &quot;
        + arrayOrCollection.getClass().getName());
  }

  /**
   * print the simple names of a list of classes
   * @param object
   * @return the simple names
   */
  public static String classesString(Object object) {
    StringBuilder result = new StringBuilder();
    if (object.getClass().isArray()) {
      int length = Array.getLength(object);
      for (int i=0;i&lt;length;i++) {
        result.append(((Class)object).getSimpleName());</pre></div></td></tr></table>
<table border="0" class="bodyTable">
<tr class="b">
<th>File</th>
<th>Line</th></tr>
<tr class="a">
<td>edu\internet2\middleware\grouperClient\config\ConfigPropertiesCascadeCommonUtils.java</td>
<td><a href="./xref/edu/internet2/middleware/grouperClient/config/ConfigPropertiesCascadeCommonUtils.html#L4635">4635</a></td></tr>
<tr class="b">
<td>edu\internet2\middleware\grouperClient\util\GcElUtilsSafe.java</td>
<td><a href="./xref/edu/internet2/middleware/grouperClient/util/GcElUtilsSafe.html#L3109">3109</a></td></tr>
<tr class="a">
<td>edu\internet2\middleware\grouperClient\util\GrouperClientCommonUtils.java</td>
<td><a href="./xref/edu/internet2/middleware/grouperClient/util/GrouperClientCommonUtils.html#L4698">4698</a></td></tr>
<tr class="b"><td colspan='2'>
<div>
<pre>  public static final int DEFAULT_BUFFER_SIZE = 1024 * 4;

  /**
   * get the Long value of an object
   * 
   * @param input
   *          is a number or String
   * @param allowNullBlank true if null or blank converts to null
   * 
   * @return the Long equivalent
   */
  public static Long longObjectValue(Object input, boolean allowNullBlank) {
  
    if (input instanceof Long) {
      return (Long) input;
    } 
  
    if (allowNullBlank &amp;&amp; isBlank(input)) {
      return null;
    } 
    
    return Long.valueOf(longValue(input));
  }

  /**
   * convert an object to a long
   * @param input
   * @return the number
   */
  public static long longValue(Object input) {
    if (input instanceof String) {
      String string = (String)input;
      return Long.parseLong(string);
    }
    if (input instanceof Number) {
      return ((Number)input).longValue();
    }
    throw new RuntimeException(&quot;Cannot convert to long: &quot; + className(input));
  }

  /**
   * convert an object to a long
   * @param input
   * @param valueIfNull is if the input is null or empty, return this value
   * @return the number
   */
  public static long longValue(Object input, long valueIfNull) {
    if (input == null || &quot;&quot;.equals(input)) {
      return valueIfNull;
    }
    return longObjectValue(input, false);
  }

  /**
   * get the long value of an object, do not throw an exception if there is an
   * error
   * 
   * @param input
   *          is a number or String
   * 
   * @return the long equivalent
   */
  public static long longValueNoError(Object input) {
    if (input == null || (input instanceof String 
        &amp;&amp; isBlank((String)input))) {
      return NOT_FOUND;
    }
    try {
      return longValue(input);
    } catch (Exception e) {
      //no need to log here
    }
  
    return NOT_FOUND;
  }

  /**
   * get the Short value of an object.  converts null or blank to null
   * 
   * @param input
   *          is a number or String
   * 
   * @return the Long equivalent
   */
  public static Short shortObjectValue(Object input) {
  
    if (input instanceof Short) {
      return (Short) input;
    }
  
    if (isBlank(input)) {
      return null;
    } 
    
    return Short.valueOf(shortValue(input));
  }

  /**
   * convert an object to a short
   * @param input
   * @return the number
   */
  public static short shortValue(Object input) {
    if (input instanceof String) {
      String string = (String)input;
      return Short.parseShort(string);
    }
    if (input instanceof Number) {
      return ((Number)input).shortValue();
    }
    throw new RuntimeException(&quot;Cannot convert to short: &quot; + className(input));
  }

  /**
   * get the Character wrapper value for the input
   * @param input allow null, return null
   * @return the Character object wrapper
   */
  public static Character charObjectValue(Object input) {
    if (input instanceof Character) {
      return (Character) input;
    }
    if (isBlank(input)) {
      return null;
    }
    return new Character(charValue(input));
  }

  /**
   * convert an object to a char
   * @param input
   * @return the number
   */
  public static char charValue(Object input) {
    if (input instanceof Character) {
      return ((Character) input).charValue();
    }
    //if string length 1, thats ok
    if (input instanceof String) {
      String inputString = (String) input;
      if (inputString.length() == 1) {
        return inputString.charAt(0);
      }
    }
    throw new RuntimeException(&quot;Cannot convert to char: &quot;
        + (input == null ? null : (input.getClass() + &quot;, &quot; + input)));
  }

  /**
   * Create the parent directories for a file if they do not already exist
   * @param file
   */
  public static void createParentDirectories(File file) {</pre></div></td></tr></table>
<table border="0" class="bodyTable">
<tr class="a">
<th>File</th>
<th>Line</th></tr>
<tr class="b">
<td>edu\internet2\middleware\grouperClient\config\ConfigPropertiesCascadeCommonUtils.java</td>
<td><a href="./xref/edu/internet2/middleware/grouperClient/config/ConfigPropertiesCascadeCommonUtils.html#L5092">5092</a></td></tr>
<tr class="a">
<td>edu\internet2\middleware\grouperClient\util\GcElUtilsSafe.java</td>
<td><a href="./xref/edu/internet2/middleware/grouperClient/util/GcElUtilsSafe.html#L3267">3267</a></td></tr>
<tr class="b">
<td>edu\internet2\middleware\grouperClient\util\GrouperClientCommonUtils.java</td>
<td><a href="./xref/edu/internet2/middleware/grouperClient/util/GrouperClientCommonUtils.html#L5155">5155</a></td></tr>
<tr class="a"><td colspan='2'>
<div>
<pre>  }

  /**
   * this method takes a long (less than 62) and converts it to a 1 character
   * string (a-z, A-Z, 0-9)
   * 
   * @param theLong
   *          is the long (less than 62) to convert to a 1 character string
   * 
   * @return a one character string
   */
  public static String convertLongToChar(long theLong) {
    if ((theLong &lt; 0) || (theLong &gt;= 62)) {
      throw new RuntimeException(&quot;convertLongToChar() &quot;
          + &quot; invalid input (not &gt;=0 &amp;&amp; &lt;62: &quot; + theLong);
    } else if (theLong &lt; 26) {
      return &quot;&quot; + (char) ('a' + theLong);
    } else if (theLong &lt; 52) {
      return &quot;&quot; + (char) ('A' + (theLong - 26));
    } else {
      return &quot;&quot; + (char) ('0' + (theLong - 52));
    }
  }

  /**
   * this method takes a long (less than 36) and converts it to a 1 character
   * string (A-Z, 0-9)
   * 
   * @param theLong
   *          is the long (less than 36) to convert to a 1 character string
   * 
   * @return a one character string
   */
  public static String convertLongToCharSmall(long theLong) {
    if ((theLong &lt; 0) || (theLong &gt;= 36)) {
      throw new RuntimeException(&quot;convertLongToCharSmall() &quot;
          + &quot; invalid input (not &gt;=0 &amp;&amp; &lt;36: &quot; + theLong);
    } else if (theLong &lt; 26) {
      return &quot;&quot; + (char) ('A' + theLong);
    } else {
      return &quot;&quot; + (char) ('0' + (theLong - 26));
    }
  }

  /**
   * convert a long to a string by converting it to base 62 (26 lower, 26 upper,
   * 10 digits)
   * 
   * @param theLong
   *          is the long to convert
   * 
   * @return the String conversion of this
   */
  public static String convertLongToString(long theLong) {
    long quotient = theLong / 62;
    long remainder = theLong % 62;
  
    if (quotient == 0) {
      return convertLongToChar(remainder);
    }
    StringBuffer result = new StringBuffer();
    result.append(convertLongToString(quotient));
    result.append(convertLongToChar(remainder));
  
    return result.toString();
  }

  /**
   * convert a long to a string by converting it to base 36 (26 upper, 10
   * digits)
   * 
   * @param theLong
   *          is the long to convert
   * 
   * @return the String conversion of this
   */
  public static String convertLongToStringSmall(long theLong) {
    long quotient = theLong / 36;
    long remainder = theLong % 36;
  
    if (quotient == 0) {
      return convertLongToCharSmall(remainder);
    }
    StringBuffer result = new StringBuffer();
    result.append(convertLongToStringSmall(quotient));
    result.append(convertLongToCharSmall(remainder));
  
    return result.toString();
  }

  /**
   * increment a character (A-Z then 0-9)
   * 
   * @param theChar
   * 
   * @return the value
   */
  public static char incrementChar(char theChar) {
    if (theChar == 'Z') {
      return '0';
    }
  
    if (theChar == '9') {
      return 'A';
    }
  
    return ++theChar;
  }

  /**
   * Increment a string with A-Z and 0-9 (no lower case so case insensitive apps
   * like windows IE will still work)
   * 
   * @param string
   * 
   * @return the value
   */
  public static char[] incrementStringInt(char[] string) {
    if (string == null) {
      return string;
    }
  
    //loop through the string backwards
    int i = 0;
  
    for (i = string.length - 1; i &gt;= 0; i--) {
      char inc = string[i];
      inc = incrementChar(inc);
      string[i] = inc;
  
      if (inc != 'A') {
        break;
      }
    }
  
    //if we are at 0, then it means we hit AAAAAAA (or more)
    if (i &lt; 0) {
      return (&quot;A&quot; + new String(string)).toCharArray();
    }
  
    return string;
  }

  /**
   * read properties from a resource, dont modify the properties returned since they are cached
   * @param resourceName
   * @return the properties
   */
  public synchronized static Properties propertiesFromResourceName(String resourceName) {</pre></div></td></tr></table>
<table border="0" class="bodyTable">
<tr class="b">
<th>File</th>
<th>Line</th></tr>
<tr class="a">
<td>edu\internet2\middleware\grouperClient\GrouperClient.java</td>
<td><a href="./xref/edu/internet2/middleware/grouperClient/GrouperClient.html#L3710">3710</a></td></tr>
<tr class="b">
<td>edu\internet2\middleware\grouperClient\GrouperClient.java</td>
<td><a href="./xref/edu/internet2/middleware/grouperClient/GrouperClient.html#L4166">4166</a></td></tr>
<tr class="a">
<td>edu\internet2\middleware\grouperClient\GrouperClient.java</td>
<td><a href="./xref/edu/internet2/middleware/grouperClient/GrouperClient.html#L5673">5673</a></td></tr>
<tr class="b"><td colspan='2'>
<div>
<pre>    for (WsAttributeAssign wsAttributeAssign : GrouperClientUtils.nonNull(wsAttributeAssignmentsResults.getWsAttributeAssigns(), WsAttributeAssign.class)) {
      
      WsAttributeDef wsAttributeDef = attributeDefLookup.get(wsAttributeAssign.getAttributeDefId());
      WsAttributeDefName wsAttributeDefName = attributeDefNameLookup.get(wsAttributeAssign.getAttributeDefNameId());
      WsStem wsOwnerStem = stemLookup.get(wsAttributeAssign.getOwnerStemId());
      WsAttributeDef wsOwnerAttributeDef = attributeDefLookup.get(wsAttributeAssign.getOwnerAttributeDefId());
      WsMembership wsOwnerMembership = membershipLookup.get(wsAttributeAssign.getOwnerMembershipId());
      WsGroup wsOwnerGroup = groupLookup.get(wsAttributeAssign.getOwnerGroupId());
      MultiKey ownerSubjectKey = new MultiKey(wsAttributeAssign.getOwnerMemberSourceId(), wsAttributeAssign.getOwnerMemberSubjectId());
      WsSubject wsOwnerMemberSubject = subjectLookup.get(ownerSubjectKey);
      
      String ownerName = null;
      if (GrouperClientUtils.equals(&quot;group&quot;, wsAttributeAssign.getAttributeAssignType())) {
        ownerName = wsOwnerGroup.getName();
      } else if (GrouperClientUtils.equals(&quot;member&quot;, wsAttributeAssign.getAttributeAssignType())) {
        ownerName = wsAttributeAssign.getOwnerMemberSourceId() + &quot; - &quot; + wsAttributeAssign.getOwnerMemberSubjectId();
      } else if (GrouperClientUtils.equals(&quot;stem&quot;, wsAttributeAssign.getAttributeAssignType())) {
        ownerName = wsOwnerStem.getName();
      } else if (GrouperClientUtils.equals(&quot;any_mem&quot;, wsAttributeAssign.getAttributeAssignType())) {
        ownerName = wsOwnerGroup.getName() + &quot; - &quot; + wsAttributeAssign.getOwnerMemberSourceId() + &quot; - &quot; + wsAttributeAssign.getOwnerMemberSubjectId();
      } else if (GrouperClientUtils.equals(&quot;imm_mem&quot;, wsAttributeAssign.getAttributeAssignType())) {
        ownerName = wsAttributeAssign.getOwnerMembershipId();
      } else if (GrouperClientUtils.equals(&quot;attr_def&quot;, wsAttributeAssign.getAttributeAssignType())) {
        ownerName = wsOwnerAttributeDef.getName();
      } else if (wsAttributeAssign.getAttributeAssignType() != null &amp;&amp; wsAttributeAssign.getAttributeAssignType().endsWith(&quot;_asgn&quot;)) {
        ownerName = wsAttributeAssign.getOwnerAttributeAssignId();
      } else {
        throw new RuntimeException(&quot;Cant find attribute assign type: &quot; + wsAttributeAssign.getAttributeAssignType());
      }

      String valuesString = &quot;none&quot;;
      int valuesLength = GrouperClientUtils.length(wsAttributeAssign.getWsAttributeAssignValues());
      if (valuesLength &gt; 0) {
        StringBuilder valuesResult = new StringBuilder();
        for (int i=0;i&lt;valuesLength;i++) {
          WsAttributeAssignValue wsAttributeAssignValue = wsAttributeAssign.getWsAttributeAssignValues()[i];
          valuesResult.append(wsAttributeAssignValue.getValueSystem());
          if (i&lt;valuesLength-1) {
            valuesResult.append(&quot;,&quot;);
          }
        }
        valuesString = valuesResult.toString();
      }
      
      substituteMap.put(&quot;index&quot;, index);</pre></div></td></tr></table>
<table border="0" class="bodyTable">
<tr class="a">
<th>File</th>
<th>Line</th></tr>
<tr class="b">
<td>edu\internet2\middleware\grouperClient\config\ConfigPropertiesCascadeCommonUtils.java</td>
<td><a href="./xref/edu/internet2/middleware/grouperClient/config/ConfigPropertiesCascadeCommonUtils.html#L3310">3310</a></td></tr>
<tr class="a">
<td>edu\internet2\middleware\grouperClient\util\GcElUtilsSafe.java</td>
<td><a href="./xref/edu/internet2/middleware/grouperClient/util/GcElUtilsSafe.html#L2124">2124</a></td></tr>
<tr class="b">
<td>edu\internet2\middleware\grouperClient\util\GrouperClientCommonUtils.java</td>
<td><a href="./xref/edu/internet2/middleware/grouperClient/util/GrouperClientCommonUtils.html#L3373">3373</a></td></tr>
<tr class="a"><td colspan='2'>
<div>
<pre>  public static String toStringSafe(Object object) {
    if (object == null) {
      return null;
    }
    
    try {
      //give size and type if collection
      if (object instanceof Collection) {
        Collection&lt;Object&gt; collection = (Collection&lt;Object&gt;) object;
        int collectionSize = collection.size();
        if (collectionSize == 0) {
          return &quot;Empty &quot; + object.getClass().getSimpleName();
        }
        Object first = collection.iterator().next();
        return object.getClass().getSimpleName() + &quot; of size &quot; 
          + collectionSize + &quot; with first type: &quot; + 
          (first == null ? null : first.getClass());
      }
    
      return object.toString();
    } catch (Exception e) {
      return &quot;&lt;&lt;exception&gt;&gt; &quot; + object.getClass() + &quot;:\n&quot; + getFullStackTrace(e) + &quot;\n&quot;;
    }
  }

  /**
   * get the boolean value for an object, cant be null or blank
   * 
   * @param object
   * @return the boolean
   */
  public static boolean booleanValue(Object object) {
    // first handle blanks
    if (nullOrBlank(object)) {
      throw new RuntimeException(
          &quot;Expecting something which can be converted to boolean, but is null or blank: '&quot;
              + object + &quot;'&quot;);
    }
    // its not blank, just convert
    if (object instanceof Boolean) {
      return (Boolean) object;
    }
    if (object instanceof String) {
      String string = (String) object;
      if (equalsIgnoreCase(string, &quot;true&quot;)
          || equalsIgnoreCase(string, &quot;t&quot;)
          || equalsIgnoreCase(string, &quot;yes&quot;)
          || equalsIgnoreCase(string, &quot;y&quot;)) {
        return true;
      }
      if (equalsIgnoreCase(string, &quot;false&quot;)
          || equalsIgnoreCase(string, &quot;f&quot;)
          || equalsIgnoreCase(string, &quot;no&quot;)
          || equalsIgnoreCase(string, &quot;n&quot;)) {
        return false;
      }
      throw new RuntimeException(
          &quot;Invalid string to boolean conversion: '&quot; + string
              + &quot;' expecting true|false or t|f or yes|no or y|n case insensitive&quot;);
  
    }
    throw new RuntimeException(&quot;Cant convert object to boolean: &quot;
        + object.getClass());
  
  }

  /**
   * get the boolean value for an object
   * 
   * @param object
   * @param defaultBoolean
   *            if object is null or empty
   * @return the boolean
   */
  public static boolean booleanValue(Object object, boolean defaultBoolean) {
    if (nullOrBlank(object)) {
      return defaultBoolean;
    }
    return booleanValue(object);
  }

  /**
   * get the Boolean value for an object
   * 
   * @param object
   * @return the Boolean or null if null or empty
   */
  public static Boolean booleanObjectValue(Object object) {
    if (nullOrBlank(object)) {
      return null;
    }
    return booleanValue(object);
  }

  /**
   * is an object null or blank
   * 
   * @param object
   * @return true if null or blank
   */
  public static boolean nullOrBlank(Object object) {
    // first handle blanks and nulls
    if (object == null) {
      return true;
    }
    if (object instanceof String &amp;&amp; isBlank(((String) object))) {
      return true;
    }
    return false;
  
  }

  /**
   * get a getter method object for a class, potentially in superclasses
   * @param theClass
   * @param fieldName
   * @param callOnSupers true if superclasses should be looked in for the getter
   * @param throwExceptionIfNotFound will throw runtime exception if not found
   * @return the getter object or null if not found (or exception if param is set)
   */
  public static Method getter(Class theClass, String fieldName, boolean callOnSupers, </pre></div></td></tr></table>
<table border="0" class="bodyTable">
<tr class="b">
<th>File</th>
<th>Line</th></tr>
<tr class="a">
<td>edu\internet2\middleware\grouperClient\config\ConfigPropertiesCascadeCommonUtils.java</td>
<td><a href="./xref/edu/internet2/middleware/grouperClient/config/ConfigPropertiesCascadeCommonUtils.html#L4139">4139</a></td></tr>
<tr class="b">
<td>edu\internet2\middleware\grouperClient\util\GcElUtilsSafe.java</td>
<td><a href="./xref/edu/internet2/middleware/grouperClient/util/GcElUtilsSafe.html#L2575">2575</a></td></tr>
<tr class="a">
<td>edu\internet2\middleware\grouperClient\util\GrouperClientCommonUtils.java</td>
<td><a href="./xref/edu/internet2/middleware/grouperClient/util/GrouperClientCommonUtils.html#L4202">4202</a></td></tr>
<tr class="b"><td colspan='2'>
<div>
<pre>  }
  
  /**
   * see if a class is a scalar (not bean, not array or list, etc)
   * @param type
   * @return true if scalar
   */
  public static boolean isScalar(Class&lt;?&gt; type) {
    
    if (type.isArray()) {
      return false;
    }
    
    //definitely all primitives
    if (type.isPrimitive()) {
      return true;
    }
    //Integer, Float, etc
    if (Number.class.isAssignableFrom(type)) {
      return true;
    }
    //Date, Timestamp
    if (Date.class.isAssignableFrom(type)) {
      return true;
    }
    if (Character.class.equals(type)) {
      return true;
    }
    //handles strings and string builders
    if (CharSequence.class.equals(type) || CharSequence.class.isAssignableFrom(type)) {
      return true;
    }
    if (Class.class == type || Boolean.class == type || type.isEnum()) {
      return true;
    }
    //appears not to be a scalar
    return false;
  }
  
  
  /**
   * &lt;pre&gt;
   * Convert a string or object to a timestamp (could be string, date, timestamp, etc)
   * yyyymmdd
   * or
   * yyyy/MM/dd HH:mm:ss
   * or
   * yyyy/MM/dd HH:mm:ss.SSS
   * or
   * yyyy/MM/dd HH:mm:ss.SSSSSS
   * 
   * &lt;/pre&gt;
   * 
   * @param input
   * @return the timestamp 
   * @throws RuntimeException if invalid format
   */
  public static Timestamp toTimestamp(Object input) {

    if (null == input) {
      return null;
    } else if (input instanceof java.sql.Timestamp) {
      return (Timestamp) input;
    } else if (input instanceof String) {
      return stringToTimestamp((String) input);
    } else if (input instanceof Date) {
      return new Timestamp(((Date)input).getTime());
    } else if (input instanceof java.sql.Date) {
      return new Timestamp(((java.sql.Date)input).getTime());
    } else {
      throw new RuntimeException(&quot;Cannot convert Object to timestamp : &quot; + input);
    }

  }

  /**
   * convert an object to a string
   * 
   * @param input
   *          is the object to convert
   * 
   * @return the String conversion of the object
   */
  public static String stringValue(Object input) {
    //this isnt needed
    if (input == null) {
      return (String) input;
    }

    if (input instanceof Timestamp) {
      //convert to yyyy/MM/dd HH:mm:ss.SSS
      return timestampToString((Timestamp) input);
    }

    if (input instanceof Date) {
      //convert to yyyymmdd
      return stringValue((Date) input);
    }

    if (input instanceof Number) {
      DecimalFormat decimalFormat = new DecimalFormat(
          &quot;###################.###############&quot;);
      return decimalFormat.format(((Number) input).doubleValue());

    }

    return input.toString();
  }

  /**
   * Convert a timestamp into a string: yyyy/MM/dd HH:mm:ss.SSS
   * @param timestamp
   * @return the string representation
   */
  public synchronized static String timestampToString(Date timestamp) {
    if (timestamp == null) {
      return null;
    }
    return timestampFormat.format(timestamp);
  }</pre></div></td></tr></table>
<table border="0" class="bodyTable">
<tr class="a">
<th>File</th>
<th>Line</th></tr>
<tr class="b">
<td>edu\internet2\middleware\grouperClient\config\ConfigPropertiesCascadeCommonUtils.java</td>
<td><a href="./xref/edu/internet2/middleware/grouperClient/config/ConfigPropertiesCascadeCommonUtils.html#L666">666</a></td></tr>
<tr class="a">
<td>edu\internet2\middleware\grouperClient\util\GcElUtilsSafe.java</td>
<td><a href="./xref/edu/internet2/middleware/grouperClient/util/GcElUtilsSafe.html#L697">697</a></td></tr>
<tr class="b">
<td>edu\internet2\middleware\grouperClient\util\GrouperClientCommonUtils.java</td>
<td><a href="./xref/edu/internet2/middleware/grouperClient/util/GrouperClientCommonUtils.html#L729">729</a></td></tr>
<tr class="a"><td colspan='2'>
<div>
<pre>  private static void toStringForLogHelper(Object object, int maxChars, StringBuilder result) {
    
    try {
      if (object == null) {
        result.append(&quot;null&quot;);
      } else if (object.getClass().isArray()) {
        // handle arrays
        int length = Array.getLength(object);
        if (length == 0) {
          result.append(&quot;Empty array&quot;);
        } else {
          result.append(&quot;Array size: &quot;).append(length).append(&quot;: &quot;);
          for (int i = 0; i &lt; length; i++) {
            result.append(&quot;[&quot;).append(i).append(&quot;]: &quot;).append(
                Array.get(object, i)).append(&quot;\n&quot;);
            if (maxChars != -1 &amp;&amp; result.length() &gt; maxChars) {
              return;
            }
          }
        }
      } else if (object instanceof Collection) {
        //give size and type if collection
        Collection&lt;Object&gt; collection = (Collection&lt;Object&gt;) object;
        int collectionSize = collection.size();
        if (collectionSize == 0) {
          result.append(&quot;Empty &quot;).append(object.getClass().getSimpleName());
        } else {
          result.append(object.getClass().getSimpleName()).append(&quot; size: &quot;).append(collectionSize).append(&quot;: &quot;);
          int i=0;
          for (Object collectionObject : collection) {
            result.append(&quot;[&quot;).append(i).append(&quot;]: &quot;).append(
                collectionObject).append(&quot;\n&quot;);
            if (maxChars != -1 &amp;&amp; result.length() &gt; maxChars) {
              return;
            }
            i++;
          }
        }
      } else {
        result.append(object.toString());
      }
    } catch (Exception e) {
      result.append(&quot;&lt;&lt;exception&gt;&gt; &quot;).append(object.getClass()).append(&quot;:\n&quot;)
        .append(getFullStackTrace(e)).append(&quot;\n&quot;);
    }
  }

  /**
   * convert a set to a string (comma separate)
   * @param set
   * @return the String
   */
  public static String setToString(Set set) {</pre></div></td></tr></table>
<table border="0" class="bodyTable">
<tr class="b">
<th>File</th>
<th>Line</th></tr>
<tr class="a">
<td>edu\internet2\middleware\grouperClient\config\ConfigPropertiesCascadeCommonUtils.java</td>
<td><a href="./xref/edu/internet2/middleware/grouperClient/config/ConfigPropertiesCascadeCommonUtils.html#L8926">8926</a></td></tr>
<tr class="b">
<td>edu\internet2\middleware\grouperClient\util\GrouperClientCommonUtils.java</td>
<td><a href="./xref/edu/internet2/middleware/grouperClient/util/GrouperClientCommonUtils.html#L9036">9036</a></td></tr>
<tr class="a"><td colspan='2'>
<div>
<pre>        + &quot;, err: &quot; + (errorGobbler == null ? null : errorGobbler.getResultString());
      throw new RuntimeException(message);
    }

    int exitValue = process.exitValue();
    return new CommandResult(outputGobbler.getResultString(), errorGobbler.getResultString(), exitValue);
  }

  
  /**
   * The results of executing a command.
   */
  public static class CommandResult{
    /**
     * If any error text was generated by the call, it will be set here.
     */
    private String errorText;
    
    /**
     * If any output text was generated by the call, it will be set here.
     */
    private String outputText;
    
    /**
     * If any exit code was generated by the call, it will be set here.
     */
    private int exitCode;
    
    
    /**
     * Create a container to hold the results of an execution.
     * @param _errorText
     * @param _outputText
     * @param _exitCode
     */
    public CommandResult(String _errorText, String _outputText, int _exitCode){
      this.errorText = _errorText;
      this.outputText = _outputText;
      this.exitCode = _exitCode;
    }


    
    /**
     * If any error text was generated by the call, it will be set here.
     * @return the errorText
     */
    public String getErrorText() {
      return this.errorText;
    }


    
    /**
     * If any output text was generated by the call, it will be set here.
     * @return the outputText
     */
    public String getOutputText() {
      return this.outputText;
    }


    
    /**
     * If any exit code was generated by the call, it will be set here.
     * @return the exitCode
     */
    public int getExitCode() {
      return this.exitCode;
    }
    
    
    
  }

  /**
   * thread factory with daemon threads so the JVM exits
   * @author mchyzer
   *
   */
  private static class DaemonThreadFactory implements ThreadFactory {
    private ThreadFactory threadFactory = Executors.defaultThreadFactory();
  
    @Override
    public Thread newThread(Runnable r) {
      Thread thread = threadFactory.newThread(r);
      thread.setDaemon(true);
      return thread;
    }
  
  }

  /**
   * serialize an object to a file (create parent dir if necessary)
   * @param object
   * @param file
   */
  public static void serializeObjectToFile(Serializable object, File file) {

    //delete, make sure parents are there
    deleteCreateFile(file);

    FileOutputStream fos = null;
    ObjectOutputStream out = null;
    try {
      fos = new FileOutputStream(file);
      out = new ObjectOutputStream(fos);
      out.writeObject(object);
    } catch(IOException ex) {
      //we had a problem, dont leave the file partway created...
      closeQuietly(out);
      out = null;
      deleteFile(file);
      throw new RuntimeException(&quot;Error writing file: &quot; + absolutePath(file)
          + &quot;, &quot; + className(object), ex);
    } finally {
      closeQuietly(out);
    }
    
  }

  /**
   * unserialize an object from a file if it exists
   * @param file
   * @param nullIfException true if null should be returned instead of exception
   * @param deleteFileOnException true if file should be deleted on exception
   * @return the object or null
   */
  public static Serializable unserializeObjectFromFile(File file, boolean nullIfException,
      boolean deleteFileOnException) {
    
    if (!file.exists() || file.length() == 0) {
      return null;
    }
    
    FileInputStream fis = null;
    ObjectInputStream ois = null;
    try {
      fis = new FileInputStream(file);
      ois = new ObjectInputStream(fis);
      return (Serializable)ois.readObject();
    } catch(Exception ex) {
      String error = &quot;Error writing file: &quot; + absolutePath(file);
      if (!nullIfException) {
        throw new RuntimeException(error, ex);
      }</pre></div></td></tr></table>
<table border="0" class="bodyTable">
<tr class="b">
<th>File</th>
<th>Line</th></tr>
<tr class="a">
<td>edu\internet2\middleware\grouperClient\config\ConfigPropertiesCascadeCommonUtils.java</td>
<td><a href="./xref/edu/internet2/middleware/grouperClient/config/ConfigPropertiesCascadeCommonUtils.html#L7363">7363</a></td></tr>
<tr class="b">
<td>edu\internet2\middleware\grouperClient\util\GrouperClientCommonUtils.java</td>
<td><a href="./xref/edu/internet2/middleware/grouperClient/util/GrouperClientCommonUtils.html#L7461">7461</a></td></tr>
<tr class="a"><td colspan='2'>
<div>
<pre>      InputStreamReader in = new InputStreamReader(input, charsetName);
      copy(in, output);
  }
  
  /**
   * Copy bytes from an &lt;code&gt;InputStream&lt;/code&gt; to an
   * &lt;code&gt;OutputStream&lt;/code&gt;.
   * &lt;p&gt;
   * This method buffers the input internally, so there is no need to use a
   * &lt;code&gt;BufferedInputStream&lt;/code&gt;.
   * &lt;p&gt;
   * Large streams (over 2GB) will return a bytes copied value of
   * &lt;code&gt;-1&lt;/code&gt; after the copy has completed since the correct
   * number of bytes cannot be returned as an int. For large streams
   * use the &lt;code&gt;copyLarge(InputStream, OutputStream)&lt;/code&gt; method.
   * 
   * @param input  the &lt;code&gt;InputStream&lt;/code&gt; to read from
   * @param output  the &lt;code&gt;OutputStream&lt;/code&gt; to write to
   * @return the number of bytes copied
   * @throws NullPointerException if the input or output is null
   * @throws IOException if an I/O error occurs
   * @throws ArithmeticException if the byte count is too large
   * @since Commons IO 1.1
   */
  public static int copy(InputStream input, OutputStream output) throws IOException {
      long count = copyLarge(input, output);
      if (count &gt; Integer.MAX_VALUE) {
          return -1;
      }
      return (int) count;
  }

  /**
   * Copy bytes from a large (over 2GB) &lt;code&gt;InputStream&lt;/code&gt; to an
   * &lt;code&gt;OutputStream&lt;/code&gt;.
   * &lt;p&gt;
   * This method buffers the input internally, so there is no need to use a
   * &lt;code&gt;BufferedInputStream&lt;/code&gt;.
   * 
   * @param input  the &lt;code&gt;InputStream&lt;/code&gt; to read from
   * @param output  the &lt;code&gt;OutputStream&lt;/code&gt; to write to
   * @return the number of bytes copied
   * @throws NullPointerException if the input or output is null
   * @throws IOException if an I/O error occurs
   * @since Commons IO 1.3
   */
  public static long copyLarge(InputStream input, OutputStream output)
          throws IOException {
      byte[] buffer = new byte[DEFAULT_BUFFER_SIZE];
      long count = 0;
      int n = 0;
      while (-1 != (n = input.read(buffer))) {
          output.write(buffer, 0, n);
          count += n;
      }
      return count;
  }

  /**
   * get a jar file from a sample class
   * @param sampleClass
   * @return the jar file
   */
  public static File jarFile(Class sampleClass) {
    try {
      CodeSource codeSource = sampleClass.getProtectionDomain().getCodeSource();
      if (codeSource != null &amp;&amp; codeSource.getLocation() != null) {
        String fileName = URLDecoder.decode(codeSource.getLocation().getFile(), &quot;UTF-8&quot;);
        return new File(fileName);
      }
      String resourcePath = sampleClass.getName();
      resourcePath = resourcePath.replace('.', '/') + &quot;.class&quot;;
      URL url = computeUrl(resourcePath, true);
      String urlPath = url.toString();
      
      if (urlPath.startsWith(&quot;jar:&quot;)) {
        urlPath = urlPath.substring(4);
      }
      if (urlPath.startsWith(&quot;file:&quot;)) {
        urlPath = urlPath.substring(5);
      }
      urlPath = prefixOrSuffix(urlPath, &quot;!&quot;, true); 
  
      urlPath = URLDecoder.decode(urlPath, &quot;UTF-8&quot;);
  
      File file = new File(urlPath);
      if (urlPath.endsWith(&quot;.jar&quot;) &amp;&amp; file.exists() &amp;&amp; file.isFile()) {
        return file;
      }
    } catch (Exception e) {</pre></div></td></tr></table>
<table border="0" class="bodyTable">
<tr class="b">
<th>File</th>
<th>Line</th></tr>
<tr class="a">
<td>edu\internet2\middleware\grouperClient\util\GrouperClientLdapUtils.java</td>
<td><a href="./xref/edu/internet2/middleware/grouperClient/util/GrouperClientLdapUtils.html#L363">363</a></td></tr>
<tr class="b">
<td>edu\internet2\middleware\grouperClient\ws\GrouperClientWs.java</td>
<td><a href="./xref/edu/internet2/middleware/grouperClient/ws/GrouperClientWs.html#L165">165</a></td></tr>
<tr class="a"><td colspan='2'>
<div>
<pre>      debugLog.put(&quot;method&quot;, &quot;GrouperClientLdapUtils.configureFailoverClient&quot;);
    }
  
    //see if we know how often to check for new config
    if (configureEverySeconds == null) {
  
      //configure every x/5 (at least 20 seconds)
      int cacheForSeconds = GrouperClientConfig.retrieveConfig().propertyValueInt(&quot;grouperClient.cacheDiscoveryPropertiesForSeconds&quot;, 120);
      configureEverySeconds = cacheForSeconds / 5;
      if (configureEverySeconds &lt; 20) {
        configureEverySeconds = 20;
      }
    }
  
    //if the amount of time since the last configure is greater than the max, then reconfigure
    boolean needsReconfigure = needsReconfigure();
  
    if (debugLog != null) {
      debugLog.put(&quot;needsReconfigure&quot;, needsReconfigure);
    }
  
    if (needsReconfigure) {
      try {
  
        synchronized (GrouperClientWs.class) {
          
          if (needsReconfigure()) {
            
            //see if the discovery file has changed...
            String fileName = &quot;grouper.client.discovery.properties&quot;;
            String directoryName = GrouperClientConfig.retrieveConfig().propertyValueString(&quot;grouperClient.discoveryGrouperClientPropertiesDirectory&quot;);
            if (!GrouperClientUtils.isBlank(directoryName)) {
              directoryName = GrouperClientUtils.stripLastSlashIfExists(directoryName);
              fileName = directoryName + &quot;/&quot; + fileName;
            }
            File discoveryFile = DiscoveryClient.retrieveFile(fileName, false);

            if (discoveryFile == null) {

              if (debugLog != null) {
                if (DiscoveryClient.hasDiscovery()) {
                  debugLog.put(&quot;discoveryFile&quot;, &quot;not found&quot;);
                } else {
                  debugLog.put(&quot;discoveryFile&quot;, &quot;not configured to use&quot;);
                }
              }

              //if we have reconfigured before, we dont need to do this again
              if (lastFailoverConfigure != null) {
                needsReconfigure = false;
              }
              
              if (DiscoveryClient.hasDiscovery()) {
                LOG.error(&quot;Cant find discovery file: '&quot; + fileName + &quot;'!!!!!!!&quot;);
              }
            } else {
  
              if (debugLog != null) {
                debugLog.put(&quot;discoveryFile&quot;, discoveryFile.getAbsolutePath());
              }
            
              //see if the same as before
              if (lastDiscoveryConfigFile != null &amp;&amp; lastDiscoveryConfigFile.equals(discoveryFile)) {
                needsReconfigure = false;
              }
            }
            
            if (debugLog != null) {
              debugLog.put(&quot;needsReconfigureFile&quot;, needsReconfigure);
            }
            
            if (needsReconfigure) {
              
              //register the failover client
              FailoverConfig failoverConfig = new FailoverConfig();
              
              //lets get the defaults
              
              
              {
                boolean foundOne = false;
                //grouperClient.discoveryDefault.ldap.0.url = 
                List&lt;String&gt; ldapUrls = new ArrayList&lt;String&gt;();</pre></div></td></tr></table>
<table border="0" class="bodyTable">
<tr class="b">
<th>File</th>
<th>Line</th></tr>
<tr class="a">
<td>edu\internet2\middleware\grouperClient\config\ConfigPropertiesCascadeCommonUtils.java</td>
<td><a href="./xref/edu/internet2/middleware/grouperClient/config/ConfigPropertiesCascadeCommonUtils.html#L3972">3972</a></td></tr>
<tr class="b">
<td>edu\internet2\middleware\grouperClient\util\GcElUtilsSafe.java</td>
<td><a href="./xref/edu/internet2/middleware/grouperClient/util/GcElUtilsSafe.html#L2277">2277</a></td></tr>
<tr class="a">
<td>edu\internet2\middleware\grouperClient\util\GrouperClientCommonUtils.java</td>
<td><a href="./xref/edu/internet2/middleware/grouperClient/util/GrouperClientCommonUtils.html#L4035">4035</a></td></tr>
<tr class="b"><td colspan='2'>
<div>
<pre>  }
  
  /**
   * &lt;pre&gt;
   * Convert an object to a java.util.Date.  allows, dates, null, blank, 
   * yyyymmdd or yyyymmdd hh24:mm:ss
   * or yyyy/MM/dd HH:mm:ss.SSS
   * &lt;/pre&gt;
   * @param inputObject
   *          is the String or Date to convert
   * 
   * @return the Date
   */
  public static Date dateValue(Object inputObject) {
    if (inputObject == null) {
      return null;
    } 

    if (inputObject instanceof java.util.Date) {
      return (Date)inputObject;
    }

    if (inputObject instanceof String) {
      String input = (String)inputObject;
      //trim and handle null and empty
      if (isBlank(input)) {
        return null;
      }

      try {
        if (input.length() == 8) {
          
          return dateFormat().parse(input);
        }
        if (!contains(input, '.')) {
          if (contains(input, '/')) {
            return dateMinutesSecondsFormat.parse(input);
          }
          //else no slash
          return dateMinutesSecondsNoSlashFormat.parse(input);
        }
        if (contains(input, '/')) {
          //see if the period is 6 back
          int lastDotIndex = input.lastIndexOf('.');
          if (lastDotIndex == input.length() - 7) {
            String nonNanoInput = input.substring(0,input.length()-3);
            Date date = timestampFormat.parse(nonNanoInput);
            //get the last 3
            String lastThree = input.substring(input.length()-3,input.length());
            int lastThreeInt = Integer.parseInt(lastThree);
            Timestamp timestamp = new Timestamp(date.getTime());
            timestamp.setNanos(timestamp.getNanos() + (lastThreeInt * 1000));
            return timestamp;
          }
          return timestampFormat.parse(input);
        }
        //else no slash
        return timestampNoSlashFormat.parse(input);
      } catch (ParseException pe) {
        throw new RuntimeException(errorStart + toStringForLog(input));
      }
    }
    
    throw new RuntimeException(&quot;Cannot convert Object to date : &quot; + toStringForLog(inputObject));
  }</pre></div></td></tr></table>
<table border="0" class="bodyTable">
<tr class="a">
<th>File</th>
<th>Line</th></tr>
<tr class="b">
<td>edu\internet2\middleware\grouperClient\config\ConfigPropertiesCascadeCommonUtils.java</td>
<td><a href="./xref/edu/internet2/middleware/grouperClient/config/ConfigPropertiesCascadeCommonUtils.html#L808">808</a></td></tr>
<tr class="a">
<td>edu\internet2\middleware\grouperClient\util\GcElUtilsSafe.java</td>
<td><a href="./xref/edu/internet2/middleware/grouperClient/util/GcElUtilsSafe.html#L855">855</a></td></tr>
<tr class="b">
<td>edu\internet2\middleware\grouperClient\util\GrouperClientCommonUtils.java</td>
<td><a href="./xref/edu/internet2/middleware/grouperClient/util/GrouperClientCommonUtils.html#L871">871</a></td></tr>
<tr class="a"><td colspan='2'>
<div>
<pre>    int batches = 1 + ((count - 1) / batchSize);
    return batches;

  }

  /**
   * If batching this is the number of batches
   * @param collection
   * @param batchSize
   * @return the number of batches
   */
  public static int batchNumberOfBatches(Collection&lt;?&gt; collection, int batchSize) {
    int arrraySize = length(collection);
    return batchNumberOfBatches(arrraySize, batchSize);

  }

  /**
   * retrieve a batch by 0 index. Will return an array of size batchSize or
   * the remainder. the array will be full of elements. Note, this requires an
   * ordered input (so use linkedhashset not hashset if doing sets)
   * @param &lt;T&gt; template type
   * @param collection
   * @param batchSize
   * @param batchIndex
   * @return the list
   *         This never returns null, only empty list
   */
  @SuppressWarnings(&quot;unchecked&quot;)
  public static &lt;T&gt; List&lt;T&gt; batchList(Collection&lt;T&gt; collection, int batchSize,
      int batchIndex) {

    int numberOfBatches = batchNumberOfBatches(collection, batchSize);
    int arraySize = length(collection);

    // short circuit
    if (arraySize == 0) {
      return new ArrayList&lt;T&gt;();
    }

    List&lt;T&gt; theBatchObjects = new ArrayList&lt;T&gt;();

    // lets get the type of the first element if possible
//    Object first = get(arrayOrCollection, 0);
//
//    Class theType = first == null ? Object.class : first.getClass();

    // if last batch
    if (batchIndex == numberOfBatches - 1) {

      // needs to work to 1-n
      //int thisBatchSize = 1 + ((arraySize - 1) % batchSize);

      int collectionIndex = 0;
      for (T t : collection) {
        if (collectionIndex++ &lt; batchIndex * batchSize) {
          continue;
        }
        //just copy the rest
        //if (collectionIndex &gt;= (batchIndex * batchSize) + arraySize) {
        //  break;
        //}
        //we are in the copy mode
        theBatchObjects.add(t);
      }

    } else {
      // if non-last batch
      //int newIndex = 0;
      int collectionIndex = 0;
      for (T t : collection) {
        if (collectionIndex &lt; batchIndex * batchSize) {
          collectionIndex++;
          continue;
        }
        //done with batch
        if (collectionIndex &gt;= (batchIndex + 1) * batchSize) {
          break;
        }
        theBatchObjects.add(t);
        collectionIndex++;
      }
    }
    return theBatchObjects;
  }
  
  /**
   * split a string based on a separator into an array, and trim each entry (see
   * the Commons Util trim() for more details)
   * 
   * @param input
   *          is the delimited input to split and trim
   * @param separator
   *          is what to split on
   * 
   * @return the array of items after split and trimmed, or null if input is null.  will be trimmed to empty
   */
  public static String[] splitTrim(String input, String separator) {
    return splitTrim(input, separator, true);
  }

  /**
   * split a string based on a separator into an array, and trim each entry (see
   * the Commons Util trim() for more details)
   * 
   * @param input
   *          is the delimited input to split and trim
   * @param separator
   *          is what to split on
   * 
   * @return the list of items after split and trimmed, or null if input is null.  will be trimmed to empty
   */
  public static List&lt;String&gt; splitTrimToList(String input, String separator) {
    if (isBlank(input)) {
      return null;
    }
    String[] array =  splitTrim(input, separator);
    return toList(array);
  }

  /**
   * split a string based on a separator into an array, and trim each entry (see
   * the Commons Util trim() for more details)
   * 
   * @param input
   *          is the delimited input to split and trim
   * @param separator
   *          is what to split on
   * @param treatAdjacentSeparatorsAsOne
   * @return the array of items after split and trimmed, or null if input is null.  will be trimmed to empty
   */
  public static String[] splitTrim(String input, String separator, boolean treatAdjacentSeparatorsAsOne) {</pre></div></td></tr></table>
<table border="0" class="bodyTable">
<tr class="b">
<th>File</th>
<th>Line</th></tr>
<tr class="a">
<td>edu\internet2\middleware\grouperClient\config\ConfigPropertiesCascadeCommonUtils.java</td>
<td><a href="./xref/edu/internet2/middleware/grouperClient/config/ConfigPropertiesCascadeCommonUtils.html#L8228">8228</a></td></tr>
<tr class="b">
<td>edu\internet2\middleware\grouperClient\util\GcElUtilsSafe.java</td>
<td><a href="./xref/edu/internet2/middleware/grouperClient/util/GcElUtilsSafe.html#L4997">4997</a></td></tr>
<tr class="a">
<td>edu\internet2\middleware\grouperClient\util\GrouperClientCommonUtils.java</td>
<td><a href="./xref/edu/internet2/middleware/grouperClient/util/GrouperClientCommonUtils.html#L8331">8331</a></td></tr>
<tr class="b"><td colspan='2'>
<div>
<pre>  }

  /**
   * &lt;p&gt;Gets the substring before the first occurrence of a separator.
   * The separator is not returned.&lt;/p&gt;
   *
   * &lt;p&gt;A &lt;code&gt;null&lt;/code&gt; string input will return &lt;code&gt;null&lt;/code&gt;.
   * An empty (&quot;&quot;) string input will return the empty string.
   * A &lt;code&gt;null&lt;/code&gt; separator will return the input string.&lt;/p&gt;
   *
   * &lt;pre&gt;
   * StringUtils.substringBefore(null, *)      = null
   * StringUtils.substringBefore(&quot;&quot;, *)        = &quot;&quot;
   * StringUtils.substringBefore(&quot;abc&quot;, &quot;a&quot;)   = &quot;&quot;
   * StringUtils.substringBefore(&quot;abcba&quot;, &quot;b&quot;) = &quot;a&quot;
   * StringUtils.substringBefore(&quot;abc&quot;, &quot;c&quot;)   = &quot;ab&quot;
   * StringUtils.substringBefore(&quot;abc&quot;, &quot;d&quot;)   = &quot;abc&quot;
   * StringUtils.substringBefore(&quot;abc&quot;, &quot;&quot;)    = &quot;&quot;
   * StringUtils.substringBefore(&quot;abc&quot;, null)  = &quot;abc&quot;
   * &lt;/pre&gt;
   *
   * @param str  the String to get a substring from, may be null
   * @param separator  the String to search for, may be null
   * @return the substring before the first occurrence of the separator,
   *  &lt;code&gt;null&lt;/code&gt; if null String input
   * @since 2.0
   */
  public static String substringBefore(String str, String separator) {
    if (isEmpty(str) || separator == null) {
      return str;
    }
    if (separator.length() == 0) {
      return EMPTY;
    }
    int pos = str.indexOf(separator);
    if (pos == -1) {
      return str;
    }
    return str.substring(0, pos);
  }

  /**
   * &lt;p&gt;Gets the substring after the first occurrence of a separator.
   * The separator is not returned.&lt;/p&gt;
   *
   * &lt;p&gt;A &lt;code&gt;null&lt;/code&gt; string input will return &lt;code&gt;null&lt;/code&gt;.
   * An empty (&quot;&quot;) string input will return the empty string.
   * A &lt;code&gt;null&lt;/code&gt; separator will return the empty string if the
   * input string is not &lt;code&gt;null&lt;/code&gt;.&lt;/p&gt;
   *
   * &lt;pre&gt;
   * StringUtils.substringAfter(null, *)      = null
   * StringUtils.substringAfter(&quot;&quot;, *)        = &quot;&quot;
   * StringUtils.substringAfter(*, null)      = &quot;&quot;
   * StringUtils.substringAfter(&quot;abc&quot;, &quot;a&quot;)   = &quot;bc&quot;
   * StringUtils.substringAfter(&quot;abcba&quot;, &quot;b&quot;) = &quot;cba&quot;
   * StringUtils.substringAfter(&quot;abc&quot;, &quot;c&quot;)   = &quot;&quot;
   * StringUtils.substringAfter(&quot;abc&quot;, &quot;d&quot;)   = &quot;&quot;
   * StringUtils.substringAfter(&quot;abc&quot;, &quot;&quot;)    = &quot;abc&quot;
   * &lt;/pre&gt;
   *
   * @param str  the String to get a substring from, may be null
   * @param separator  the String to search for, may be null
   * @return the substring after the first occurrence of the separator,
   *  &lt;code&gt;null&lt;/code&gt; if null String input
   * @since 2.0
   */
  public static String substringAfter(String str, String separator) {
    if (isEmpty(str)) {
      return str;
    }
    if (separator == null) {
      return EMPTY;
    }
    int pos = str.indexOf(separator);
    if (pos == -1) {
      return EMPTY;
    }
    return str.substring(pos + separator.length());
  }

  /**
   * &lt;p&gt;Gets the substring before the last occurrence of a separator.
   * The separator is not returned.&lt;/p&gt;
   *
   * &lt;p&gt;A &lt;code&gt;null&lt;/code&gt; string input will return &lt;code&gt;null&lt;/code&gt;.
   * An empty (&quot;&quot;) string input will return the empty string.
   * An empty or &lt;code&gt;null&lt;/code&gt; separator will return the input string.&lt;/p&gt;
   *
   * &lt;pre&gt;
   * StringUtils.substringBeforeLast(null, *)      = null
   * StringUtils.substringBeforeLast(&quot;&quot;, *)        = &quot;&quot;
   * StringUtils.substringBeforeLast(&quot;abcba&quot;, &quot;b&quot;) = &quot;abc&quot;
   * StringUtils.substringBeforeLast(&quot;abc&quot;, &quot;c&quot;)   = &quot;ab&quot;
   * StringUtils.substringBeforeLast(&quot;a&quot;, &quot;a&quot;)     = &quot;&quot;
   * StringUtils.substringBeforeLast(&quot;a&quot;, &quot;z&quot;)     = &quot;a&quot;
   * StringUtils.substringBeforeLast(&quot;a&quot;, null)    = &quot;a&quot;
   * StringUtils.substringBeforeLast(&quot;a&quot;, &quot;&quot;)      = &quot;a&quot;
   * &lt;/pre&gt;
   *
   * @param str  the String to get a substring from, may be null
   * @param separator  the String to search for, may be null
   * @return the substring before the last occurrence of the separator,
   *  &lt;code&gt;null&lt;/code&gt; if null String input
   * @since 2.0
   */
  public static String substringBeforeLast(String str, String separator) {
    if (isEmpty(str) || isEmpty(separator)) {
      return str;
    }
    int pos = str.lastIndexOf(separator);
    if (pos == -1) {
      return str;
    }
    return str.substring(0, pos);
  }

  /**
   * &lt;p&gt;Gets the substring after the last occurrence of a separator.
   * The separator is not returned.&lt;/p&gt;
   *
   * &lt;p&gt;A &lt;code&gt;null&lt;/code&gt; string input will return &lt;code&gt;null&lt;/code&gt;.
   * An empty (&quot;&quot;) string input will return the empty string.
   * An empty or &lt;code&gt;null&lt;/code&gt; separator will return the empty string if
   * the input string is not &lt;code&gt;null&lt;/code&gt;.&lt;/p&gt;
   *
   * &lt;pre&gt;
   * StringUtils.substringAfterLast(null, *)      = null
   * StringUtils.substringAfterLast(&quot;&quot;, *)        = &quot;&quot;
   * StringUtils.substringAfterLast(*, &quot;&quot;)        = &quot;&quot;
   * StringUtils.substringAfterLast(*, null)      = &quot;&quot;
   * StringUtils.substringAfterLast(&quot;abc&quot;, &quot;a&quot;)   = &quot;bc&quot;
   * StringUtils.substringAfterLast(&quot;abcba&quot;, &quot;b&quot;) = &quot;a&quot;
   * StringUtils.substringAfterLast(&quot;abc&quot;, &quot;c&quot;)   = &quot;&quot;
   * StringUtils.substringAfterLast(&quot;a&quot;, &quot;a&quot;)     = &quot;&quot;
   * StringUtils.substringAfterLast(&quot;a&quot;, &quot;z&quot;)     = &quot;&quot;
   * &lt;/pre&gt;
   *
   * @param str  the String to get a substring from, may be null
   * @param separator  the String to search for, may be null
   * @return the substring after the last occurrence of the separator,
   *  &lt;code&gt;null&lt;/code&gt; if null String input
   * @since 2.0
   */
  public static String substringAfterLast(String str, String separator) {
    if (isEmpty(str)) {
      return str;
    }
    if (isEmpty(separator)) {
      return EMPTY;
    }
    int pos = str.lastIndexOf(separator);
    if (pos == -1 || pos == (str.length() - separator.length())) {
      return EMPTY;
    }
    return str.substring(pos + separator.length());
  }

  /**
   * get the value from the argMap, throw exception if not there and required
   * @param argMap
   * @param argMapNotUsed 
   * @param key
   * @param required
   * @param defaultValue 
   * @return the value or null or exception
   */
  public static Integer argMapInteger(Map&lt;String, String&gt; argMap, Map&lt;String, String&gt; argMapNotUsed, </pre></div></td></tr></table>
<table border="0" class="bodyTable">
<tr class="a">
<th>File</th>
<th>Line</th></tr>
<tr class="b">
<td>edu\internet2\middleware\grouperClient\ws\beans\WsRestAssignAttributesLiteRequest.java</td>
<td><a href="./xref/edu/internet2/middleware/grouperClient/ws/beans/WsRestAssignAttributesLiteRequest.html#L664">664</a></td></tr>
<tr class="a">
<td>edu\internet2\middleware\grouperClient\ws\beans\WsRestGetPermissionAssignmentsLiteRequest.java</td>
<td><a href="./xref/edu/internet2/middleware/grouperClient/ws/beans/WsRestGetPermissionAssignmentsLiteRequest.html#L583">583</a></td></tr>
<tr class="b"><td colspan='2'>
<div>
<pre>  }

  /** if acting as another user */
  private String actAsSubjectId; 

  /** if acting as another user */
  private String actAsSubjectSourceId;
  
  /** if acting as another user */
  private String actAsSubjectIdentifier; 

  /**
   * if acting as another user
   * @return id
   */
  public String getActAsSubjectId() {
    return this.actAsSubjectId;
  }

  /**
   * if acting as another user
   * @param actAsSubjectId1
   */
  public void setActAsSubjectId(String actAsSubjectId1) {
    this.actAsSubjectId = actAsSubjectId1;
  }

  /**
   * if acting as another user
   * @return source id 
   */
  public String getActAsSubjectSourceId() {
    return this.actAsSubjectSourceId;
  }

  /**
   * if acting as another user
   * @param actAsSubjectSourceId1
   */
  public void setActAsSubjectSourceId(String actAsSubjectSourceId1) {
    this.actAsSubjectSourceId = actAsSubjectSourceId1;
  }

  /**
   * if acting as another user
   * @return subject identifier
   */
  public String getActAsSubjectIdentifier() {
    return this.actAsSubjectIdentifier;
  }

  /**
   * if acting as another user
   * @param actAsSubjectIdentifier1
   */
  public void setActAsSubjectIdentifier(String actAsSubjectIdentifier1) {
    this.actAsSubjectIdentifier = actAsSubjectIdentifier1;
  }


  /**
   * T|F, for if the extended subject information should be
   * returned (anything more than just the id)
   */
  private String includeSubjectDetail;
  
  /**
   * T|F, for if the extended subject information should be
   * returned (anything more than just the id)
   * @return T|F
   */
  public String getIncludeSubjectDetail() {
    return this.includeSubjectDetail;
  }

  /**
   * T|F, for if the extended subject information should be
   * returned (anything more than just the id)
   * @param includeSubjectDetail1
   */
  public void setIncludeSubjectDetail(String includeSubjectDetail1) {
    this.includeSubjectDetail = includeSubjectDetail1;
  }

  /**
   * are the additional subject attributes (data) to return (comma separated)
   * If blank, whatever is configured in the grouper-ws.properties will be sent   
   */
  private String subjectAttributeNames;
  
  /**
   * are the additional subject attributes (data) to return (comma separated)
   * If blank, whatever is configured in the grouper-ws.properties will be sent   
   * @return subject attribute names
   */
  public String getSubjectAttributeNames() {
    return this.subjectAttributeNames;
  }

  /**
   * are the additional subject attributes (data) to return (comma separated)
   * If blank, whatever is configured in the grouper-ws.properties will be sent   
   * @param subjectAttributeNames1
   */
  public void setSubjectAttributeNames(String subjectAttributeNames1) {
    this.subjectAttributeNames = subjectAttributeNames1;
  }


  /** T or F as to if the group detail should be returned */
  private String includeGroupDetail;
  
  /**
   * T or F as to if the group detail should be returned
   * @return T|F
   */
  public String getIncludeGroupDetail() {
    return this.includeGroupDetail;
  }

  /**
   * T or F as to if the group detail should be returned
   * @param includeGroupDetail1
   */
  public void setIncludeGroupDetail(String includeGroupDetail1) {
    this.includeGroupDetail = includeGroupDetail1;
  }

  /** reserved for future use */
  private String paramName0;
  
  /** reserved for future use */
  private String paramValue0;
  
  /** reserved for future use */
  private String paramName1; 

  /** reserved for future use */
  private String paramValue1; 

  /**
   * reserved for future use
   * @return param name 0
   */
  public String getParamName0() {
    return this.paramName0;
  }

  /**
   * reserved for future use
   * @param _paramName0
   */
  public void setParamName0(String _paramName0) {
    this.paramName0 = _paramName0;
  }

  /**
   * reserved for future use
   * @return param value 0
   */
  public String getParamValue0() {
    return this.paramValue0;
  }

  /**
   * reserved for future use
   * @param _paramValue0
   */
  public void setParamValue0(String _paramValue0) {
    this.paramValue0 = _paramValue0;
  }

  /**
   * reserved for future use
   * @return paramname1
   */
  public String getParamName1() {
    return this.paramName1;
  }

  /**
   * reserved for future use
   * @param _paramName1
   */
  public void setParamName1(String _paramName1) {
    this.paramName1 = _paramName1;
  }

  /**
   * reserved for future use
   * @return param value 1
   */
  public String getParamValue1() {
    return this.paramValue1;
  }

  /**
   * reserved for future use
   * @param _paramValue1
   */
  public void setParamValue1(String _paramValue1) {
    this.paramValue1 = _paramValue1;
  }</pre></div></td></tr></table>
<table border="0" class="bodyTable">
<tr class="a">
<th>File</th>
<th>Line</th></tr>
<tr class="b">
<td>edu\internet2\middleware\grouperClient\config\ConfigPropertiesCascadeCommonUtils.java</td>
<td><a href="./xref/edu/internet2/middleware/grouperClient/config/ConfigPropertiesCascadeCommonUtils.html#L102">102</a></td></tr>
<tr class="a">
<td>edu\internet2\middleware\grouperClient\util\GcElUtilsSafe.java</td>
<td><a href="./xref/edu/internet2/middleware/grouperClient/util/GcElUtilsSafe.html#L274">274</a></td></tr>
<tr class="b">
<td>edu\internet2\middleware\grouperClient\util\GrouperClientCommonUtils.java</td>
<td><a href="./xref/edu/internet2/middleware/grouperClient/util/GrouperClientCommonUtils.html#L106">106</a></td></tr>
<tr class="a"><td colspan='2'>
<div>
<pre>  public static String argAfter(String[] args, String argBefore) {
    if (length(args) &lt;= 1) {
      return null;
    }
    int argBeforeIndex = -1;
    for (int i=0;i&lt;args.length;i++) {
      if (equals(args[i], argBefore)) {
        argBeforeIndex = i;
        break;
      }
    }
    if (argBeforeIndex == -1) {
      throw new RuntimeException(&quot;Cant find arg before&quot;);
    }
    if (argBeforeIndex &lt; args.length - 1) {
      return args[argBeforeIndex + 1];
    }
    return null;
  }
  
  /**
   * append and maybe put a separator in there
   * @param result
   * @param separatorIfResultNotEmpty
   * @param stringToAppend
   */
  public static void append(StringBuilder result, 
      String separatorIfResultNotEmpty, String stringToAppend) {
    if (result.length() != 0) {
      result.append(separatorIfResultNotEmpty);
    }
    result.append(stringToAppend);
  }
  
  /**
   * 
   */
  public static final String LOG_ERROR = &quot;Error trying to make parent dirs for logger or logging first statement, check to make &quot; +
                &quot;sure you have proper file permissions, and that your servlet container is giving &quot; +
                &quot;your app rights to access the log directory (e.g. for tomcat set TOMCAT5_SECURITY=no), g&quot; +
                &quot;oogle it for more info&quot;;

  /**
   * The number of bytes in a kilobyte.
   */
  public static final long ONE_KB = 1024;

  /**
   * The number of bytes in a megabyte.
   */
  public static final long ONE_MB = ONE_KB * ONE_KB;

  /**
   * The number of bytes in a gigabyte.
   */
  public static final long ONE_GB = ONE_KB * ONE_MB;

  /**
   * Returns a human-readable version of the file size (original is in
   * bytes).
   *
   * @param size The number of bytes.
   * @return     A human-readable display value (includes units).
   * @todo need for I18N?
   */
  public static String byteCountToDisplaySize(long size) {
    String displaySize;

    if (size / ONE_GB &gt; 0) {
      displaySize = String.valueOf(size / ONE_GB) + &quot; GB&quot;;
    } else if (size / ONE_MB &gt; 0) {
      displaySize = String.valueOf(size / ONE_MB) + &quot; MB&quot;;
    } else if (size / ONE_KB &gt; 0) {
      displaySize = String.valueOf(size / ONE_KB) + &quot; KB&quot;;
    } else {
      displaySize = String.valueOf(size) + &quot; bytes&quot;;
    }

    return displaySize;
  }
  /**
   * see if options have a specific option by int bits
   * @param options
   * @param option
   * @return if the option is there
   */
  public static boolean hasOption(int options, int option) {</pre></div></td></tr></table>
<table border="0" class="bodyTable">
<tr class="b">
<th>File</th>
<th>Line</th></tr>
<tr class="a">
<td>edu\internet2\middleware\grouperClient\config\ConfigPropertiesCascadeCommonUtils.java</td>
<td><a href="./xref/edu/internet2/middleware/grouperClient/config/ConfigPropertiesCascadeCommonUtils.html#L6165">6165</a></td></tr>
<tr class="b">
<td>edu\internet2\middleware\grouperClient\util\GcElUtilsSafe.java</td>
<td><a href="./xref/edu/internet2/middleware/grouperClient/util/GcElUtilsSafe.html#L3845">3845</a></td></tr>
<tr class="a">
<td>edu\internet2\middleware\grouperClient\util\GrouperClientCommonUtils.java</td>
<td><a href="./xref/edu/internet2/middleware/grouperClient/util/GrouperClientCommonUtils.html#L6242">6242</a></td></tr>
<tr class="b"><td colspan='2'>
<div>
<pre>  public static String[] splitByWholeSeparator(String str, String separator, int max) {
    if (str == null) {
      return null;
    }

    int len = str.length();

    if (len == 0) {
      return EMPTY_STRING_ARRAY;
    }

    if ((separator == null) || (&quot;&quot;.equals(separator))) {
      // Split on whitespace.
      return split(str, null, max);
    }

    int separatorLength = separator.length();

    ArrayList substrings = new ArrayList();
    int numberOfSubstrings = 0;
    int beg = 0;
    int end = 0;
    while (end &lt; len) {
      end = str.indexOf(separator, beg);

      if (end &gt; -1) {
        if (end &gt; beg) {
          numberOfSubstrings += 1;

          if (numberOfSubstrings == max) {
            end = len;
            substrings.add(str.substring(beg));
          } else {
            // The following is OK, because String.substring( beg, end ) excludes
            // the character at the position 'end'.
            substrings.add(str.substring(beg, end));

            // Set the starting point for the next search.
            // The following is equivalent to beg = end + (separatorLength - 1) + 1,
            // which is the right calculation:
            beg = end + separatorLength;
          }
        } else {
          // We found a consecutive occurrence of the separator, so skip it.
          beg = end + separatorLength;
        }
      } else {
        // String.substring( beg ) goes from 'beg' to the end of the String.
        substrings.add(str.substring(beg));
        end = len;
      }
    }

    return (String[]) substrings.toArray(new String[substrings.size()]);
  }

  //-----------------------------------------------------------------------
  /**
   * &lt;p&gt;Splits the provided text into an array, using whitespace as the
   * separator, preserving all tokens, including empty tokens created by 
   * adjacent separators. This is an alternative to using StringTokenizer.
   * Whitespace is defined by {@link Character#isWhitespace(char)}.&lt;/p&gt;
   *
   * &lt;p&gt;The separator is not included in the returned String array.
   * Adjacent separators are treated as separators for empty tokens.
   * For more control over the split use the StrTokenizer class.&lt;/p&gt;
   *
   * &lt;p&gt;A &lt;code&gt;null&lt;/code&gt; input String returns &lt;code&gt;null&lt;/code&gt;.&lt;/p&gt;
   *
   * &lt;pre&gt;
   * StringUtils.splitPreserveAllTokens(null)       = null
   * StringUtils.splitPreserveAllTokens(&quot;&quot;)         = []
   * StringUtils.splitPreserveAllTokens(&quot;abc def&quot;)  = [&quot;abc&quot;, &quot;def&quot;]
   * StringUtils.splitPreserveAllTokens(&quot;abc  def&quot;) = [&quot;abc&quot;, &quot;&quot;, &quot;def&quot;]
   * StringUtils.splitPreserveAllTokens(&quot; abc &quot;)    = [&quot;&quot;, &quot;abc&quot;, &quot;&quot;]
   * &lt;/pre&gt;
   *
   * @param str  the String to parse, may be &lt;code&gt;null&lt;/code&gt;
   * @return an array of parsed Strings, &lt;code&gt;null&lt;/code&gt; if null String input
   * @since 2.1
   */
  public static String[] splitPreserveAllTokens(String str) {
    return splitWorker(str, null, -1, true);
  }

  /**
   * &lt;p&gt;Splits the provided text into an array, separator specified,
   * preserving all tokens, including empty tokens created by adjacent
   * separators. This is an alternative to using StringTokenizer.&lt;/p&gt;
   *
   * &lt;p&gt;The separator is not included in the returned String array.
   * Adjacent separators are treated as separators for empty tokens.
   * For more control over the split use the StrTokenizer class.&lt;/p&gt;
   *
   * &lt;p&gt;A &lt;code&gt;null&lt;/code&gt; input String returns &lt;code&gt;null&lt;/code&gt;.&lt;/p&gt;
   *
   * &lt;pre&gt;
   * StringUtils.splitPreserveAllTokens(null, *)         = null
   * StringUtils.splitPreserveAllTokens(&quot;&quot;, *)           = []
   * StringUtils.splitPreserveAllTokens(&quot;a.b.c&quot;, '.')    = [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;]
   * StringUtils.splitPreserveAllTokens(&quot;a..b.c&quot;, '.')   = [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;]
   * StringUtils.splitPreserveAllTokens(&quot;a:b:c&quot;, '.')    = [&quot;a:b:c&quot;]
   * StringUtils.splitPreserveAllTokens(&quot;a\tb\nc&quot;, null) = [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;]
   * StringUtils.splitPreserveAllTokens(&quot;a b c&quot;, ' ')    = [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;]
   * StringUtils.splitPreserveAllTokens(&quot;a b c &quot;, ' ')   = [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;&quot;]
   * StringUtils.splitPreserveAllTokens(&quot;a b c &quot;, ' ')   = [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;&quot;, &quot;&quot;]
   * StringUtils.splitPreserveAllTokens(&quot; a b c&quot;, ' ')   = [&quot;&quot;, a&quot;, &quot;b&quot;, &quot;c&quot;]
   * StringUtils.splitPreserveAllTokens(&quot;  a b c&quot;, ' ')  = [&quot;&quot;, &quot;&quot;, a&quot;, &quot;b&quot;, &quot;c&quot;]
   * StringUtils.splitPreserveAllTokens(&quot; a b c &quot;, ' ')  = [&quot;&quot;, a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;&quot;]
   * &lt;/pre&gt;
   *
   * @param str  the String to parse, may be &lt;code&gt;null&lt;/code&gt;
   * @param separatorChar  the character used as the delimiter,
   *  &lt;code&gt;null&lt;/code&gt; splits on whitespace
   * @return an array of parsed Strings, &lt;code&gt;null&lt;/code&gt; if null String input
   * @since 2.1
   */
  public static String[] splitPreserveAllTokens(String str, char separatorChar) {
    return splitWorker(str, separatorChar, true);
  }</pre></div></td></tr></table>
<table border="0" class="bodyTable">
<tr class="a">
<th>File</th>
<th>Line</th></tr>
<tr class="b">
<td>edu\internet2\middleware\grouperClient\ws\beans\WsRestAssignAttributesRequest.java</td>
<td><a href="./xref/edu/internet2/middleware/grouperClient/ws/beans/WsRestAssignAttributesRequest.html#L261">261</a></td></tr>
<tr class="a">
<td>edu\internet2\middleware\grouperClient\ws\beans\WsRestGetAttributeAssignmentsRequest.java</td>
<td><a href="./xref/edu/internet2/middleware/grouperClient/ws/beans/WsRestGetAttributeAssignmentsRequest.html#L195">195</a></td></tr>
<tr class="b"><td colspan='2'>
<div>
<pre>  }

  /**
   * find assignments in these attribute def names (optional)
   */
  private WsAttributeDefNameLookup[] wsAttributeDefNameLookups;
  
  /**
   *  find assignments in these attribute def names (optional)
   *  @return def name lookups
   */
  public WsAttributeDefNameLookup[] getWsAttributeDefNameLookups() {
    return this.wsAttributeDefNameLookups;
  }

  /**
   * find assignments in these attribute def names (optional)
   * @param wsAttributeDefNameLookups1
   */
  public void setWsAttributeDefNameLookups(
      WsAttributeDefNameLookup[] wsAttributeDefNameLookups1) {
    this.wsAttributeDefNameLookups = wsAttributeDefNameLookups1;
  }
  
  /** wsOwnerGroupLookups are groups to look in */
  private WsGroupLookup[] wsOwnerGroupLookups;
  
  /**
   * wsOwnerGroupLookups are groups to look in
   * @return owner group lookups
   */
  public WsGroupLookup[] getWsOwnerGroupLookups() {
    return this.wsOwnerGroupLookups;
  }

  /**
   * wsOwnerGroupLookups are groups to look in
   * @param wsOwnerGroupLookups1
   */
  public void setWsOwnerGroupLookups(WsGroupLookup[] wsOwnerGroupLookups1) {
    this.wsOwnerGroupLookups = wsOwnerGroupLookups1;
  }

  /** are stems to look in */
  private WsStemLookup[] wsOwnerStemLookups;
  
  /**
   * are stems to look in
   * @return are stems to look in
   */
  public WsStemLookup[] getWsOwnerStemLookups() {
    return this.wsOwnerStemLookups;
  }

  /**
   * are stems to look in
   * @param wsOwnerStemLookups1
   */
  public void setWsOwnerStemLookups(WsStemLookup[] wsOwnerStemLookups1) {
    this.wsOwnerStemLookups = wsOwnerStemLookups1;
  }

  /** are subjects to look in */
  private WsSubjectLookup[] wsOwnerSubjectLookups;
  
  
  
  /**
   * are subjects to look in
   * @return subject
   */
  public WsSubjectLookup[] getWsOwnerSubjectLookups() {
    return this.wsOwnerSubjectLookups;
  }

  /**
   * are subjects to look in
   * @param wsOwnerSubjectLookups1
   */
  public void setWsOwnerSubjectLookups(WsSubjectLookup[] wsOwnerSubjectLookups1) {
    this.wsOwnerSubjectLookups = wsOwnerSubjectLookups1;
  }
  
  /** to query attributes on immediate memberships */
  private WsMembershipLookup[] wsOwnerMembershipLookups;
  
  /** to query attributes in &quot;any&quot; memberships which are on immediate or effective memberships */
  private WsMembershipAnyLookup[] wsOwnerMembershipAnyLookups;
  
  
  
  /**
   * to query attributes on immediate memberships
   * @return owner memberships
   */
  public WsMembershipLookup[] getWsOwnerMembershipLookups() {
    return this.wsOwnerMembershipLookups;
  }

  /**
   * to query attributes on immediate memberships
   * @param wsOwnerMembershipLookups1
   */
  public void setWsOwnerMembershipLookups(WsMembershipLookup[] wsOwnerMembershipLookups1) {
    this.wsOwnerMembershipLookups = wsOwnerMembershipLookups1;
  }

  /**
   * to query attributes in &quot;any&quot; memberships which are on immediate or effective memberships
   * @return any memberships
   */
  public WsMembershipAnyLookup[] getWsOwnerMembershipAnyLookups() {
    return this.wsOwnerMembershipAnyLookups;
  }

  /**
   * to query attributes in &quot;any&quot; memberships which are on immediate or effective memberships
   * @param wsOwnerMembershipAnyLookups1
   */
  public void setWsOwnerMembershipAnyLookups(
      WsMembershipAnyLookup[] wsOwnerMembershipAnyLookups1) {
    this.wsOwnerMembershipAnyLookups = wsOwnerMembershipAnyLookups1;
  }
  
  /**
   * to query attributes assigned on attribute defs
   */
  private WsAttributeDefLookup[] wsOwnerAttributeDefLookups;
  
  /**
   * to query attributes assigned on attribute defs
   * @return attribute def
   */
  public WsAttributeDefLookup[] getWsOwnerAttributeDefLookups() {
    return this.wsOwnerAttributeDefLookups;
  }

  /**
   * to query attributes assigned on attribute defs
   * @param wsOwnerAttributeDefLookups1
   */
  public void setWsOwnerAttributeDefLookups(
      WsAttributeDefLookup[] wsOwnerAttributeDefLookups1) {
    this.wsOwnerAttributeDefLookups = wsOwnerAttributeDefLookups1;
  }

  /**
   * actions to query, or none to query all actions
   */
  private String[] actions; 
  
  /**
   * actions to query, or none to query all actions
   * @return actions
   */
  public String[] getActions() {
    return this.actions;
  }

  /**
   * actions to query, or none to query all actions
   * @param actions1
   */
  public void setActions(String[] actions1) {
    this.actions = actions1;
  }

  /** if acting as someone else */
  private WsSubjectLookup actAsSubjectLookup;</pre></div></td></tr></table>
<table border="0" class="bodyTable">
<tr class="a">
<th>File</th>
<th>Line</th></tr>
<tr class="b">
<td>edu\internet2\middleware\grouperClient\ws\beans\WsRestGetMembershipsRequest.java</td>
<td><a href="./xref/edu/internet2/middleware/grouperClient/ws/beans/WsRestGetMembershipsRequest.html#L280">280</a></td></tr>
<tr class="a">
<td>edu\internet2\middleware\grouperClient\ws\beans\WsRestGetMembersRequest.java</td>
<td><a href="./xref/edu/internet2/middleware/grouperClient/ws/beans/WsRestGetMembersRequest.html#L170">170</a></td></tr>
<tr class="b"><td colspan='2'>
<div>
<pre>  }

  /**
   * sourceIds are sources to look in for memberships, or null if all
   * @return the sourceIds
   */
  public String[] getSourceIds() {
    return this.sourceIds;
  }
  
  /**
   * sourceIds are sources to look in for memberships, or null if all
   * @param sourceIds1 the sourceIds to set
   */
  public void setSourceIds(String[] sourceIds1) {
    this.sourceIds = sourceIds1;
  }

  /**
   * is the version of the client.  Must be in GrouperWsVersion, e.g. v1_3_000
   * @return the clientVersion
   */
  public String getClientVersion() {
    return this.clientVersion;
  }

  
  /**
   * is the version of the client.  Must be in GrouperWsVersion, e.g. v1_3_000
   * @param clientVersion1 the clientVersion to set
   */
  public void setClientVersion(String clientVersion1) {
    this.clientVersion = clientVersion1;
  }

  
  /**
   * are groups to look in
   * @return the wsGroupLookups
   */
  public WsGroupLookup[] getWsGroupLookups() {
    return this.wsGroupLookups;
  }

  
  /**
   * are groups to look in
   * @param wsGroupLookups1 the wsGroupLookup to set
   */
  public void setWsGroupLookups(WsGroupLookup[] wsGroupLookups1) {
    this.wsGroupLookups = wsGroupLookups1;
  }

  
  /**
   * must be one of All, Effective, Immediate, Composite, NonImmediate
   * @return the replaceAllExisting
   */
  public String getMemberFilter() {
    return this.memberFilter;
  }

  
  /**
   * must be one of All, Effective, Immediate, Composite, NonImmediate
   * @param replaceAllExisting1 the replaceAllExisting to set
   */
  public void setMemberFilter(String replaceAllExisting1) {
    this.memberFilter = replaceAllExisting1;
  }

  
  /**
   * subject to act as instead of logged in user
   * @return the actAsSubjectLookup
   */
  public WsSubjectLookup getActAsSubjectLookup() {
    return this.actAsSubjectLookup;
  }

  
  /**
   * subject to act as instead of logged in user
   * @param actAsSubjectLookup1 the actAsSubjectLookup to set
   */
  public void setActAsSubjectLookup(WsSubjectLookup actAsSubjectLookup1) {
    this.actAsSubjectLookup = actAsSubjectLookup1;
  }

  
  /**
   * is if the memberships should be retrieved from a certain field membership
   * of the group (certain list)
   * @return the fieldName
   */
  public String getFieldName() {
    return this.fieldName;
  }

  
  /**
   * is if the memberships should be retrieved from a certain field membership
   * of the group (certain list)
   * @param fieldName1 the fieldName to set
   */
  public void setFieldName(String fieldName1) {
    this.fieldName = fieldName1;
  }

  
  /**
   * T or F as to if the group detail should be returned
   * @return the includeGroupDetail
   */
  public String getIncludeGroupDetail() {
    return this.includeGroupDetail;
  }

  
  /**
   * T or F as to if the group detail should be returned
   * @param includeGroupDetail1 the includeGroupDetail to set
   */
  public void setIncludeGroupDetail(String includeGroupDetail1) {
    this.includeGroupDetail = includeGroupDetail1;
  }

  
  /**
   * T|F, for if the extended subject information should be
   * returned (anything more than just the id)
   * @return the includeSubjectDetail
   */
  public String getIncludeSubjectDetail() {
    return this.includeSubjectDetail;
  }

  
  /**
   * T|F, for if the extended subject information should be
   * returned (anything more than just the id)
   * @param includeSubjectDetail1 the includeSubjectDetail to set
   */
  public void setIncludeSubjectDetail(String includeSubjectDetail1) {
    this.includeSubjectDetail = includeSubjectDetail1;
  }

  
  /**
   *  are the additional subject attributes (data) to return.
   * If blank, whatever is configured in the grouper-ws.properties will be sent
   * @return the subjectAttributeNames
   */
  public String[] getSubjectAttributeNames() {
    return this.subjectAttributeNames;
  }

  
  /**
   *  are the additional subject attributes (data) to return.
   * If blank, whatever is configured in the grouper-ws.properties will be sent
   * @param subjectAttributeNames1 the subjectAttributeNames to set
   */
  public void setSubjectAttributeNames(String[] subjectAttributeNames1) {
    this.subjectAttributeNames = subjectAttributeNames1;
  }


  
  /**
   * optional: reserved for future use
   * @return the params
   */
  public WsParam[] getParams() {
    return this.params;
  }


  
  /**
   * optional: reserved for future use
   * @param params1 the params to set
   */
  public void setParams(WsParam[] params1) {
    this.params = params1;
  }</pre></div></td></tr></table>
<table border="0" class="bodyTable">
<tr class="a">
<th>File</th>
<th>Line</th></tr>
<tr class="b">
<td>edu\internet2\middleware\grouperClient\ws\beans\WsAssignAttributesBatchResults.java</td>
<td><a href="./xref/edu/internet2/middleware/grouperClient/ws/beans/WsAssignAttributesBatchResults.html#L94">94</a></td></tr>
<tr class="a">
<td>edu\internet2\middleware\grouperClient\ws\beans\WsAssignAttributesResults.java</td>
<td><a href="./xref/edu/internet2/middleware/grouperClient/ws/beans/WsAssignAttributesResults.html#L93">93</a></td></tr>
<tr class="b"><td colspan='2'>
<div>
<pre>    this.wsAssignAttributeBatchResultArray = wsAttributeAssignResults1;
  }

  /**
   * attributes of subjects returned, in same order as the data
   */
  private String[] subjectAttributeNames;

  /**
   * attributes of subjects returned, in same order as the data
   * @return the attributeNames
   */
  public String[] getSubjectAttributeNames() {
    return this.subjectAttributeNames;
  }

  /**
   * attributes of subjects returned, in same order as the data
   * @param attributeNamesa the attributeNames to set
   */
  public void setSubjectAttributeNames(String[] attributeNamesa) {
    this.subjectAttributeNames = attributeNamesa;
  }

  /**
   * metadata about the result
   */
  private WsResultMeta resultMetadata = new WsResultMeta();

  /**
   * @return the resultMetadata
   */
  public WsResultMeta getResultMetadata() {
    return this.resultMetadata;
  }

  /**
   * metadata about the result
   */
  private WsResponseMeta responseMetadata = new WsResponseMeta();

  /**
   * groups that are in the results
   */
  private WsGroup[] wsGroups;

  /**
   * stems that are in the results
   */
  private WsStem[] wsStems;

  /**
   * stems that are in the results
   * @return stems
   */
  public WsStem[] getWsStems() {
    return this.wsStems;
  }

  /**
   * stems that are in the results
   * @param wsStems1
   */
  public void setWsStems(WsStem[] wsStems1) {
    this.wsStems = wsStems1;
  }

  /**
   * results for each assignment sent in
   */
  private WsMembership[] wsMemberships;

  /**
   * subjects that are in the results
   */
  private WsSubject[] wsSubjects;

  /**
   * @see edu.internet2.middleware.grouper.ws.rest.WsResponseBean#getResponseMetadata()
   * @return the response metadata
   */
  public WsResponseMeta getResponseMetadata() {
    return this.responseMetadata;
  }

  
  /**
   * @param resultMetadata1 the resultMetadata to set
   */
  public void setResultMetadata(WsResultMeta resultMetadata1) {
    this.resultMetadata = resultMetadata1;
  }

  
  /**
   * @param responseMetadata1 the responseMetadata to set
   */
  public void setResponseMetadata(WsResponseMeta responseMetadata1) {
    this.responseMetadata = responseMetadata1;
  }

  /**
   * @return the wsGroups
   */
  public WsGroup[] getWsGroups() {
    return this.wsGroups;
  }

  /**
   * results for each assignment sent in
   * @return the results
   */
  public WsMembership[] getWsMemberships() {
    return this.wsMemberships;
  }

  /**
   * subjects that are in the results
   * @return the subjects
   */
  public WsSubject[] getWsSubjects() {
    return this.wsSubjects;
  }

  /**
   * @param wsGroup1 the wsGroups to set
   */
  public void setWsGroups(WsGroup[] wsGroup1) {
    this.wsGroups = wsGroup1;
  }

  /**
   * results for each assignment sent in
   * @param results1 the results to set
   */
  public void setWsMemberships(WsMembership[] results1) {
    this.wsMemberships = results1;
  }

  /**
   * subjects that are in the results
   * @param wsSubjects1
   */
  public void setWsSubjects(WsSubject[] wsSubjects1) {
    this.wsSubjects = wsSubjects1;
  }
  
  
}</pre></div></td></tr></table>
<table border="0" class="bodyTable">
<tr class="a">
<th>File</th>
<th>Line</th></tr>
<tr class="b">
<td>edu\internet2\middleware\grouperClient\ws\beans\WsAssignAttributesBatchResults.java</td>
<td><a href="./xref/edu/internet2/middleware/grouperClient/ws/beans/WsAssignAttributesBatchResults.html#L95">95</a></td></tr>
<tr class="a">
<td>edu\internet2\middleware\grouperClient\ws\beans\WsAssignAttributesResults.java</td>
<td><a href="./xref/edu/internet2/middleware/grouperClient/ws/beans/WsAssignAttributesResults.html#L94">94</a></td></tr>
<tr class="b">
<td>edu\internet2\middleware\grouperClient\ws\beans\WsGetAttributeAssignmentsResults.java</td>
<td><a href="./xref/edu/internet2/middleware/grouperClient/ws/beans/WsGetAttributeAssignmentsResults.html#L95">95</a></td></tr>
<tr class="a"><td colspan='2'>
<div>
<pre>  }

  /**
   * attributes of subjects returned, in same order as the data
   */
  private String[] subjectAttributeNames;

  /**
   * attributes of subjects returned, in same order as the data
   * @return the attributeNames
   */
  public String[] getSubjectAttributeNames() {
    return this.subjectAttributeNames;
  }

  /**
   * attributes of subjects returned, in same order as the data
   * @param attributeNamesa the attributeNames to set
   */
  public void setSubjectAttributeNames(String[] attributeNamesa) {
    this.subjectAttributeNames = attributeNamesa;
  }

  /**
   * metadata about the result
   */
  private WsResultMeta resultMetadata = new WsResultMeta();

  /**
   * @return the resultMetadata
   */
  public WsResultMeta getResultMetadata() {
    return this.resultMetadata;
  }

  /**
   * metadata about the result
   */
  private WsResponseMeta responseMetadata = new WsResponseMeta();

  /**
   * groups that are in the results
   */
  private WsGroup[] wsGroups;

  /**
   * stems that are in the results
   */
  private WsStem[] wsStems;

  /**
   * stems that are in the results
   * @return stems
   */
  public WsStem[] getWsStems() {
    return this.wsStems;
  }

  /**
   * stems that are in the results
   * @param wsStems1
   */
  public void setWsStems(WsStem[] wsStems1) {
    this.wsStems = wsStems1;
  }

  /**
   * results for each assignment sent in
   */
  private WsMembership[] wsMemberships;

  /**
   * subjects that are in the results
   */
  private WsSubject[] wsSubjects;

  /**
   * @see edu.internet2.middleware.grouper.ws.rest.WsResponseBean#getResponseMetadata()
   * @return the response metadata
   */
  public WsResponseMeta getResponseMetadata() {
    return this.responseMetadata;
  }

  
  /**
   * @param resultMetadata1 the resultMetadata to set
   */
  public void setResultMetadata(WsResultMeta resultMetadata1) {
    this.resultMetadata = resultMetadata1;
  }

  
  /**
   * @param responseMetadata1 the responseMetadata to set
   */
  public void setResponseMetadata(WsResponseMeta responseMetadata1) {
    this.responseMetadata = responseMetadata1;
  }

  /**
   * @return the wsGroups
   */
  public WsGroup[] getWsGroups() {
    return this.wsGroups;
  }

  /**
   * results for each assignment sent in
   * @return the results
   */
  public WsMembership[] getWsMemberships() {
    return this.wsMemberships;
  }

  /**
   * subjects that are in the results
   * @return the subjects
   */
  public WsSubject[] getWsSubjects() {
    return this.wsSubjects;
  }

  /**
   * @param wsGroup1 the wsGroups to set
   */
  public void setWsGroups(WsGroup[] wsGroup1) {
    this.wsGroups = wsGroup1;
  }

  /**
   * results for each assignment sent in
   * @param results1 the results to set
   */
  public void setWsMemberships(WsMembership[] results1) {
    this.wsMemberships = results1;
  }

  /**
   * subjects that are in the results
   * @param wsSubjects1
   */
  public void setWsSubjects(WsSubject[] wsSubjects1) {
    this.wsSubjects = wsSubjects1;
  }
  
  
}</pre></div></td></tr></table>
<table border="0" class="bodyTable">
<tr class="b">
<th>File</th>
<th>Line</th></tr>
<tr class="a">
<td>edu\internet2\middleware\grouperClient\ws\beans\WsRestGetMembersRequest.java</td>
<td><a href="./xref/edu/internet2/middleware/grouperClient/ws/beans/WsRestGetMembersRequest.html#L218">218</a></td></tr>
<tr class="b">
<td>edu\internet2\middleware\grouperClient\ws\beans\WsRestHasMemberRequest.java</td>
<td><a href="./xref/edu/internet2/middleware/grouperClient/ws/beans/WsRestHasMemberRequest.html#L122">122</a></td></tr>
<tr class="a"><td colspan='2'>
<div>
<pre>  }

  
  /**
   * @return the replaceAllExisting
   */
  public String getMemberFilter() {
    return this.memberFilter;
  }

  
  /**
   * @param replaceAllExisting1 the replaceAllExisting to set
   */
  public void setMemberFilter(String replaceAllExisting1) {
    this.memberFilter = replaceAllExisting1;
  }

  
  /**
   * @return the actAsSubjectLookup
   */
  public WsSubjectLookup getActAsSubjectLookup() {
    return this.actAsSubjectLookup;
  }

  
  /**
   * @param actAsSubjectLookup1 the actAsSubjectLookup to set
   */
  public void setActAsSubjectLookup(WsSubjectLookup actAsSubjectLookup1) {
    this.actAsSubjectLookup = actAsSubjectLookup1;
  }

  
  /**
   * @return the fieldName
   */
  public String getFieldName() {
    return this.fieldName;
  }

  
  /**
   * @param fieldName1 the fieldName to set
   */
  public void setFieldName(String fieldName1) {
    this.fieldName = fieldName1;
  }

  
  /**
   * @return the includeGroupDetail
   */
  public String getIncludeGroupDetail() {
    return this.includeGroupDetail;
  }

  
  /**
   * @param includeGroupDetail1 the includeGroupDetail to set
   */
  public void setIncludeGroupDetail(String includeGroupDetail1) {
    this.includeGroupDetail = includeGroupDetail1;
  }

  
  /**
   * @return the includeSubjectDetail
   */
  public String getIncludeSubjectDetail() {
    return this.includeSubjectDetail;
  }

  
  /**
   * @param includeSubjectDetail1 the includeSubjectDetail to set
   */
  public void setIncludeSubjectDetail(String includeSubjectDetail1) {
    this.includeSubjectDetail = includeSubjectDetail1;
  }

  
  /**
   * @return the subjectAttributeNames
   */
  public String[] getSubjectAttributeNames() {
    return this.subjectAttributeNames;
  }

  
  /**
   * @param subjectAttributeNames1 the subjectAttributeNames to set
   */
  public void setSubjectAttributeNames(String[] subjectAttributeNames1) {
    this.subjectAttributeNames = subjectAttributeNames1;
  }


  
  /**
   * @return the params
   */
  public WsParam[] getParams() {
    return this.params;
  }


  
  /**
   * @param params1 the params to set
   */
  public void setParams(WsParam[] params1) {
    this.params = params1;
  }
  
  /**
   * To query members at a certain point in time or time range in the past, set this value
   * and/or the value of pointInTimeTo.  This parameter specifies the start of the range
   * of the point in time query.  If this is specified but pointInTimeTo is not specified, 
   * then the point in time query range will be from the time specified to now.  
   * Format:  yyyy/MM/dd HH:mm:ss.SSS
   * @return the pointInTimeFrom
   */
  public String getPointInTimeFrom() {
    return this.pointInTimeFrom;
  }

  
  /**
   * To query members at a certain point in time or time range in the past, set this value
   * and/or the value of pointInTimeTo.  This parameter specifies the start of the range
   * of the point in time query.  If this is specified but pointInTimeTo is not specified, 
   * then the point in time query range will be from the time specified to now.  
   * Format:  yyyy/MM/dd HH:mm:ss.SSS
   * @param pointInTimeFrom1 the pointInTimeFrom to set
   */
  public void setPointInTimeFrom(String pointInTimeFrom1) {
    this.pointInTimeFrom = pointInTimeFrom1;
  }

  
  /**
   * To query members at a certain point in time or time range in the past, set this value
   * and/or the value of pointInTimeFrom.  This parameter specifies the end of the range 
   * of the point in time query.  If this is the same as pointInTimeFrom, then the query 
   * will be done at a single point in time rather than a range.  If this is specified but 
   * pointInTimeFrom is not specified, then the point in time query range will be from the 
   * minimum point in time to the time specified.  Format: yyyy/MM/dd HH:mm:ss.SSS 
   * @return the pointInTimeTo
   */
  public String getPointInTimeTo() {
    return this.pointInTimeTo;
  }

  
  /**
   * To query members at a certain point in time or time range in the past, set this value
   * and/or the value of pointInTimeFrom.  This parameter specifies the end of the range 
   * of the point in time query.  If this is the same as pointInTimeFrom, then the query 
   * will be done at a single point in time rather than a range.  If this is specified but 
   * pointInTimeFrom is not specified, then the point in time query range will be from the 
   * minimum point in time to the time specified.  Format: yyyy/MM/dd HH:mm:ss.SSS 
   * @param pointInTimeTo1 the pointInTimeTo to set
   */
  public void setPointInTimeTo(String pointInTimeTo1) {
    this.pointInTimeTo = pointInTimeTo1;
  }
}</pre></div></td></tr></table>
<table border="0" class="bodyTable">
<tr class="b">
<th>File</th>
<th>Line</th></tr>
<tr class="a">
<td>edu\internet2\middleware\grouperClient\config\ConfigPropertiesCascadeCommonUtils.java</td>
<td><a href="./xref/edu/internet2/middleware/grouperClient/config/ConfigPropertiesCascadeCommonUtils.html#L6299">6299</a></td></tr>
<tr class="b">
<td>edu\internet2\middleware\grouperClient\util\GcElUtilsSafe.java</td>
<td><a href="./xref/edu/internet2/middleware/grouperClient/util/GcElUtilsSafe.html#L3978">3978</a></td></tr>
<tr class="a">
<td>edu\internet2\middleware\grouperClient\util\GrouperClientCommonUtils.java</td>
<td><a href="./xref/edu/internet2/middleware/grouperClient/util/GrouperClientCommonUtils.html#L6376">6376</a></td></tr>
<tr class="b"><td colspan='2'>
<div>
<pre>  private static String[] splitWorker(String str, char separatorChar,
      boolean preserveAllTokens) {
    // Performance tuned for 2.0 (JDK1.4)

    if (str == null) {
      return null;
    }
    int len = str.length();
    if (len == 0) {
      return EMPTY_STRING_ARRAY;
    }
    List list = new ArrayList();
    int i = 0, start = 0;
    boolean match = false;
    boolean lastMatch = false;
    while (i &lt; len) {
      if (str.charAt(i) == separatorChar) {
        if (match || preserveAllTokens) {
          list.add(str.substring(start, i));
          match = false;
          lastMatch = true;
        }
        start = ++i;
        continue;
      }
      lastMatch = false;
      match = true;
      i++;
    }
    if (match || (preserveAllTokens &amp;&amp; lastMatch)) {
      list.add(str.substring(start, i));
    }
    return (String[]) list.toArray(new String[list.size()]);
  }

  /**
   * &lt;p&gt;Splits the provided text into an array, separators specified, 
   * preserving all tokens, including empty tokens created by adjacent
   * separators. This is an alternative to using StringTokenizer.&lt;/p&gt;
   *
   * &lt;p&gt;The separator is not included in the returned String array.
   * Adjacent separators are treated as separators for empty tokens.
   * For more control over the split use the StrTokenizer class.&lt;/p&gt;
   *
   * &lt;p&gt;A &lt;code&gt;null&lt;/code&gt; input String returns &lt;code&gt;null&lt;/code&gt;.
   * A &lt;code&gt;null&lt;/code&gt; separatorChars splits on whitespace.&lt;/p&gt;
   *
   * &lt;pre&gt;
   * StringUtils.splitPreserveAllTokens(null, *)           = null
   * StringUtils.splitPreserveAllTokens(&quot;&quot;, *)             = []
   * StringUtils.splitPreserveAllTokens(&quot;abc def&quot;, null)   = [&quot;abc&quot;, &quot;def&quot;]
   * StringUtils.splitPreserveAllTokens(&quot;abc def&quot;, &quot; &quot;)    = [&quot;abc&quot;, &quot;def&quot;]
   * StringUtils.splitPreserveAllTokens(&quot;abc  def&quot;, &quot; &quot;)   = [&quot;abc&quot;, &quot;&quot;, def&quot;]
   * StringUtils.splitPreserveAllTokens(&quot;ab:cd:ef&quot;, &quot;:&quot;)   = [&quot;ab&quot;, &quot;cd&quot;, &quot;ef&quot;]
   * StringUtils.splitPreserveAllTokens(&quot;ab:cd:ef:&quot;, &quot;:&quot;)  = [&quot;ab&quot;, &quot;cd&quot;, &quot;ef&quot;, &quot;&quot;]
   * StringUtils.splitPreserveAllTokens(&quot;ab:cd:ef::&quot;, &quot;:&quot;) = [&quot;ab&quot;, &quot;cd&quot;, &quot;ef&quot;, &quot;&quot;, &quot;&quot;]
   * StringUtils.splitPreserveAllTokens(&quot;ab::cd:ef&quot;, &quot;:&quot;)  = [&quot;ab&quot;, &quot;&quot;, cd&quot;, &quot;ef&quot;]
   * StringUtils.splitPreserveAllTokens(&quot;:cd:ef&quot;, &quot;:&quot;)     = [&quot;&quot;, cd&quot;, &quot;ef&quot;]
   * StringUtils.splitPreserveAllTokens(&quot;::cd:ef&quot;, &quot;:&quot;)    = [&quot;&quot;, &quot;&quot;, cd&quot;, &quot;ef&quot;]
   * StringUtils.splitPreserveAllTokens(&quot;:cd:ef:&quot;, &quot;:&quot;)    = [&quot;&quot;, cd&quot;, &quot;ef&quot;, &quot;&quot;]
   * &lt;/pre&gt;
   *
   * @param str  the String to parse, may be &lt;code&gt;null&lt;/code&gt;
   * @param separatorChars  the characters used as the delimiters,
   *  &lt;code&gt;null&lt;/code&gt; splits on whitespace
   * @return an array of parsed Strings, &lt;code&gt;null&lt;/code&gt; if null String input
   * @since 2.1
   */
  public static String[] splitPreserveAllTokens(String str, String separatorChars) {
    return splitWorker(str, separatorChars, -1, true);
  }

  /**
   * &lt;p&gt;Splits the provided text into an array with a maximum length,
   * separators specified, preserving all tokens, including empty tokens 
   * created by adjacent separators.&lt;/p&gt;
   *
   * &lt;p&gt;The separator is not included in the returned String array.
   * Adjacent separators are treated as separators for empty tokens.
   * Adjacent separators are treated as one separator.&lt;/p&gt;
   *
   * &lt;p&gt;A &lt;code&gt;null&lt;/code&gt; input String returns &lt;code&gt;null&lt;/code&gt;.
   * A &lt;code&gt;null&lt;/code&gt; separatorChars splits on whitespace.&lt;/p&gt;
   *
   * &lt;p&gt;If more than &lt;code&gt;max&lt;/code&gt; delimited substrings are found, the last
   * returned string includes all characters after the first &lt;code&gt;max - 1&lt;/code&gt;
   * returned strings (including separator characters).&lt;/p&gt;
   *
   * &lt;pre&gt;
   * StringUtils.splitPreserveAllTokens(null, *, *)            = null
   * StringUtils.splitPreserveAllTokens(&quot;&quot;, *, *)              = []
   * StringUtils.splitPreserveAllTokens(&quot;ab de fg&quot;, null, 0)   = [&quot;ab&quot;, &quot;cd&quot;, &quot;ef&quot;]
   * StringUtils.splitPreserveAllTokens(&quot;ab   de fg&quot;, null, 0) = [&quot;ab&quot;, &quot;cd&quot;, &quot;ef&quot;]
   * StringUtils.splitPreserveAllTokens(&quot;ab:cd:ef&quot;, &quot;:&quot;, 0)    = [&quot;ab&quot;, &quot;cd&quot;, &quot;ef&quot;]
   * StringUtils.splitPreserveAllTokens(&quot;ab:cd:ef&quot;, &quot;:&quot;, 2)    = [&quot;ab&quot;, &quot;cd:ef&quot;]
   * StringUtils.splitPreserveAllTokens(&quot;ab   de fg&quot;, null, 2) = [&quot;ab&quot;, &quot;  de fg&quot;]
   * StringUtils.splitPreserveAllTokens(&quot;ab   de fg&quot;, null, 3) = [&quot;ab&quot;, &quot;&quot;, &quot; de fg&quot;]
   * StringUtils.splitPreserveAllTokens(&quot;ab   de fg&quot;, null, 4) = [&quot;ab&quot;, &quot;&quot;, &quot;&quot;, &quot;de fg&quot;]
   * &lt;/pre&gt;
   *
   * @param str  the String to parse, may be &lt;code&gt;null&lt;/code&gt;
   * @param separatorChars  the characters used as the delimiters,
   *  &lt;code&gt;null&lt;/code&gt; splits on whitespace
   * @param max  the maximum number of elements to include in the
   *  array. A zero or negative value implies no limit
   * @return an array of parsed Strings, &lt;code&gt;null&lt;/code&gt; if null String input
   * @since 2.1
   */
  public static String[] splitPreserveAllTokens(String str, String separatorChars, int max) {
    return splitWorker(str, separatorChars, max, true);
  }</pre></div></td></tr></table>
<table border="0" class="bodyTable">
<tr class="a">
<th>File</th>
<th>Line</th></tr>
<tr class="b">
<td>edu\internet2\middleware\grouperClient\config\ConfigPropertiesCascadeCommonUtils.java</td>
<td><a href="./xref/edu/internet2/middleware/grouperClient/config/ConfigPropertiesCascadeCommonUtils.html#L6924">6924</a></td></tr>
<tr class="a">
<td>edu\internet2\middleware\grouperClient\util\GcElUtilsSafe.java</td>
<td><a href="./xref/edu/internet2/middleware/grouperClient/util/GcElUtilsSafe.html#L5822">5822</a></td></tr>
<tr class="b">
<td>edu\internet2\middleware\grouperClient\util\GrouperClientCommonUtils.java</td>
<td><a href="./xref/edu/internet2/middleware/grouperClient/util/GrouperClientCommonUtils.html#L7001">7001</a></td></tr>
<tr class="a"><td colspan='2'>
<div>
<pre>  };

  /**
   * &lt;p&gt;Checks whether this &lt;code&gt;Throwable&lt;/code&gt; class can store a cause.&lt;/p&gt;
   * 
   * &lt;p&gt;This method does &lt;b&gt;not&lt;/b&gt; check whether it actually does store a cause.&lt;p&gt;
   *
   * @param throwable  the &lt;code&gt;Throwable&lt;/code&gt; to examine, may be null
   * @return boolean &lt;code&gt;true&lt;/code&gt; if nested otherwise &lt;code&gt;false&lt;/code&gt;
   * @since 2.0
   */
  public static boolean isNestedThrowable(Throwable throwable) {
      if (throwable == null) {
          return false;
      }

      if (throwable instanceof SQLException) {
          return true;
      } else if (throwable instanceof InvocationTargetException) {
          return true;
      } else if (isThrowableNested()) {
          return true;
      }

      Class cls = throwable.getClass();
      for (int i = 0, isize = CAUSE_METHOD_NAMES.length; i &lt; isize; i++) {
          try {
              Method method = cls.getMethod(CAUSE_METHOD_NAMES[i], (Class[])null);
              if (method != null &amp;&amp; Throwable.class.isAssignableFrom(method.getReturnType())) {
                  return true;
              }
          } catch (NoSuchMethodException ignored) {
          } catch (SecurityException ignored) {
          }
      }

      try {
          Field field = cls.getField(&quot;detail&quot;);
          if (field != null) {
              return true;
          }
      } catch (NoSuchFieldException ignored) {
      } catch (SecurityException ignored) {
      }

      return false;
  }

  /**
   * &lt;p&gt;The Method object for JDK1.4 getCause.&lt;/p&gt;
   */
  private static final Method THROWABLE_CAUSE_METHOD;
  static {
      Method getCauseMethod;
      try {
          getCauseMethod = Throwable.class.getMethod(&quot;getCause&quot;, (Class[])null);
      } catch (Exception e) {
          getCauseMethod = null;
      }
      THROWABLE_CAUSE_METHOD = getCauseMethod;
  }
  
  /**
   * &lt;p&gt;Checks if the Throwable class has a &lt;code&gt;getCause&lt;/code&gt; method.&lt;/p&gt;
   * 
   * &lt;p&gt;This is true for JDK 1.4 and above.&lt;/p&gt;
   * 
   * @return true if Throwable is nestable
   * @since 2.0
   */
  public static boolean isThrowableNested() {</pre></div></td></tr></table>
<table border="0" class="bodyTable">
<tr class="b">
<th>File</th>
<th>Line</th></tr>
<tr class="a">
<td>edu\internet2\middleware\grouperClient\config\ConfigPropertiesCascadeCommonUtils.java</td>
<td><a href="./xref/edu/internet2/middleware/grouperClient/config/ConfigPropertiesCascadeCommonUtils.html#L734">734</a></td></tr>
<tr class="b">
<td>edu\internet2\middleware\grouperClient\util\GcElUtilsSafe.java</td>
<td><a href="./xref/edu/internet2/middleware/grouperClient/util/GcElUtilsSafe.html#L777">777</a></td></tr>
<tr class="a">
<td>edu\internet2\middleware\grouperClient\util\GrouperClientCommonUtils.java</td>
<td><a href="./xref/edu/internet2/middleware/grouperClient/util/GrouperClientCommonUtils.html#L797">797</a></td></tr>
<tr class="b"><td colspan='2'>
<div>
<pre>    return result.toString();
  }
  
  /**
   * convert a set to a string (comma separate)
   * @param map
   * @return the String
   * @deprecated use mapToString(map)
   */
  @Deprecated
  public static String MapToString(Map map) {
    return mapToString(map);
  }

  /**
   * convert a set to a string (comma separate)
   * @param map
   * @return the String
   */
  public static String mapToString(Map map) {
    if (map == null) {
      return &quot;null&quot;;
    }
    if (map.size() == 0) {
      return &quot;empty&quot;;
    }
    StringBuilder result = new StringBuilder();
    boolean first = true;
    for (Object object : map.keySet()) {
      if (!first) {
        result.append(&quot;, &quot;);
      }
      first = false;
      result.append(object).append(&quot;: &quot;).append(map.get(object));
    }
    return result.toString();
  }

  /**
   * print out various types of objects
   * 
   * @param object
   * @return the string value
   */
  public static String toStringForLog(Object object) {
    StringBuilder result = new StringBuilder();
    toStringForLogHelper(object, -1, result);
    return result.toString();
  }

  /**
   * print out various types of objects
   * 
   * @param object
   * @param maxChars is the max chars that should be returned (abbreviate if longer), or -1 for any amount
   * @return the string value
   */
  public static String toStringForLog(Object object, int maxChars) {
    StringBuilder result = new StringBuilder();
    toStringForLogHelper(object, -1, result);
    String resultString = result.toString();
    if (maxChars != -1) {
      return abbreviate(resultString, maxChars);
    }
    return resultString;
  }

  /**
   * If batching this is the number of batches
   * @param count is size of set
   * @param batchSize
   * @return the number of batches
   */
  public static int batchNumberOfBatches(int count, int batchSize) {</pre></div></td></tr></table>
<table border="0" class="bodyTable">
<tr class="a">
<th>File</th>
<th>Line</th></tr>
<tr class="b">
<td>edu\internet2\middleware\grouperClient\ws\beans\WsRestGetAttributeAssignmentsRequest.java</td>
<td><a href="./xref/edu/internet2/middleware/grouperClient/ws/beans/WsRestGetAttributeAssignmentsRequest.html#L339">339</a></td></tr>
<tr class="a">
<td>edu\internet2\middleware\grouperClient\ws\beans\WsRestGetPermissionAssignmentsRequest.java</td>
<td><a href="./xref/edu/internet2/middleware/grouperClient/ws/beans/WsRestGetPermissionAssignmentsRequest.html#L307">307</a></td></tr>
<tr class="b"><td colspan='2'>
<div>
<pre>  }

  /**
   * actions to query, or none to query all actions
   */
  private String[] actions; 
  
  /**
   * actions to query, or none to query all actions
   * @return actions
   */
  public String[] getActions() {
    return this.actions;
  }

  /**
   * actions to query, or none to query all actions
   * @param actions1
   */
  public void setActions(String[] actions1) {
    this.actions = actions1;
  }

  /**
   * if this is not querying assignments on assignments directly, but the assignments
   * and assignments on those assignments should be returned, enter true.  default to false.
   */
  private String includeAssignmentsOnAssignments;

  
  
  /**
   * if this is not querying assignments on assignments directly, but the assignments
   * and assignments on those assignments should be returned, enter true.  default to false.
   * @return if include assignments on assignments
   */
  public String getIncludeAssignmentsOnAssignments() {
    return this.includeAssignmentsOnAssignments;
  }

  /**
   * if this is not querying assignments on assignments directly, but the assignments
   * and assignments on those assignments should be returned, enter true.  default to false.
   * @param includeAssignmentsOnAssignments1
   */
  public void setIncludeAssignmentsOnAssignments(String includeAssignmentsOnAssignments1) {
    this.includeAssignmentsOnAssignments = includeAssignmentsOnAssignments1;
  }

  /** if acting as someone else */
  private WsSubjectLookup actAsSubjectLookup;
  
  /**
   * if acting as someone else
   * @return act as subject
   */
  public WsSubjectLookup getActAsSubjectLookup() {
    return this.actAsSubjectLookup;
  }

  /**
   * if acting as someone else
   * @param actAsSubjectLookup1
   */
  public void setActAsSubjectLookup(WsSubjectLookup actAsSubjectLookup1) {
    this.actAsSubjectLookup = actAsSubjectLookup1;
  }

  /**
   * T|F, for if the extended subject information should be
   * returned (anything more than just the id)
   */
  private String includeSubjectDetail;
  
  /**
   * T|F, for if the extended subject information should be
   * returned (anything more than just the id)
   * @return T|F
   */
  public String getIncludeSubjectDetail() {
    return this.includeSubjectDetail;
  }
  
  /**
   * T|F, for if the extended subject information should be
   * returned (anything more than just the id)
   * @param includeSubjectDetail1
   */
  public void setIncludeSubjectDetail(String includeSubjectDetail1) {
    this.includeSubjectDetail = includeSubjectDetail1;
  }

  /** are the additional subject attributes (data) to return. 
   * If blank, whatever is configured in the grouper-ws.properties will be sent
   */
  private String[] subjectAttributeNames;

  
  
  /**
   * are the additional subject attributes (data) to return.
   * If blank, whatever is configured in the grouper-ws.properties will be sent
   * @return subject attribute names
   */
  public String[] getSubjectAttributeNames() {
    return this.subjectAttributeNames;
  }

  /**
   * are the additional subject attributes (data) to return.
   * If blank, whatever is configured in the grouper-ws.properties will be sent
   * @param subjectAttributeNames1
   */
  public void setSubjectAttributeNames(String[] subjectAttributeNames1) {
    this.subjectAttributeNames = subjectAttributeNames1;
  }

  /** T or F as to if the group detail should be returned */
  private String includeGroupDetail;
  
  
  
  /**
   * T or F as to if the group detail should be returned
   * @return T|F
   */
  public String getIncludeGroupDetail() {
    return this.includeGroupDetail;
  }

  /**
   * T or F as to if the group detail should be returned
   * @param includeGroupDetail1
   */
  public void setIncludeGroupDetail(String includeGroupDetail1) {
    this.includeGroupDetail = includeGroupDetail1;
  }

  /** optional: reserved for future use */
  private  WsParam[] params;

  
  
  /**
   * optional: reserved for future use
   * @return params
   */
  public WsParam[] getParams() {
    return this.params;
  }

  /**
   * optional: reserved for future use
   * @param params1
   */
  public void setParams(WsParam[] params1) {
    this.params = params1;
  }

  /** A for all, T or null for enabled only, F for disabled  */
  private String enabled;</pre></div></td></tr></table>
<table border="0" class="bodyTable">
<tr class="a">
<th>File</th>
<th>Line</th></tr>
<tr class="b">
<td>edu\internet2\middleware\grouperClient\ws\beans\WsRestAssignAttributesLiteRequest.java</td>
<td><a href="./xref/edu/internet2/middleware/grouperClient/ws/beans/WsRestAssignAttributesLiteRequest.html#L648">648</a></td></tr>
<tr class="a">
<td>edu\internet2\middleware\grouperClient\ws\beans\WsRestAssignPermissionsLiteRequest.java</td>
<td><a href="./xref/edu/internet2/middleware/grouperClient/ws/beans/WsRestAssignPermissionsLiteRequest.html#L375">375</a></td></tr>
<tr class="b"><td colspan='2'>
<div>
<pre>  }

  /**
   * action to query, or none to query all actions
   * @return action
   */
  public String getAction() {
    return this.action;
  }

  /**
   * action to query, or none to query all actions
   * @param action1
   */
  public void setAction(String action1) {
    this.action = action1;
  }

  /** if acting as another user */
  private String actAsSubjectId; 

  /** if acting as another user */
  private String actAsSubjectSourceId;
  
  /** if acting as another user */
  private String actAsSubjectIdentifier; 

  /**
   * if acting as another user
   * @return id
   */
  public String getActAsSubjectId() {
    return this.actAsSubjectId;
  }

  /**
   * if acting as another user
   * @param actAsSubjectId1
   */
  public void setActAsSubjectId(String actAsSubjectId1) {
    this.actAsSubjectId = actAsSubjectId1;
  }

  /**
   * if acting as another user
   * @return source id 
   */
  public String getActAsSubjectSourceId() {
    return this.actAsSubjectSourceId;
  }

  /**
   * if acting as another user
   * @param actAsSubjectSourceId1
   */
  public void setActAsSubjectSourceId(String actAsSubjectSourceId1) {
    this.actAsSubjectSourceId = actAsSubjectSourceId1;
  }

  /**
   * if acting as another user
   * @return subject identifier
   */
  public String getActAsSubjectIdentifier() {
    return this.actAsSubjectIdentifier;
  }

  /**
   * if acting as another user
   * @param actAsSubjectIdentifier1
   */
  public void setActAsSubjectIdentifier(String actAsSubjectIdentifier1) {
    this.actAsSubjectIdentifier = actAsSubjectIdentifier1;
  }


  /**
   * T|F, for if the extended subject information should be
   * returned (anything more than just the id)
   */
  private String includeSubjectDetail;
  
  /**
   * T|F, for if the extended subject information should be
   * returned (anything more than just the id)
   * @return T|F
   */
  public String getIncludeSubjectDetail() {
    return this.includeSubjectDetail;
  }

  /**
   * T|F, for if the extended subject information should be
   * returned (anything more than just the id)
   * @param includeSubjectDetail1
   */
  public void setIncludeSubjectDetail(String includeSubjectDetail1) {
    this.includeSubjectDetail = includeSubjectDetail1;
  }

  /**
   * are the additional subject attributes (data) to return (comma separated)
   * If blank, whatever is configured in the grouper-ws.properties will be sent   
   */
  private String subjectAttributeNames;
  
  /**
   * are the additional subject attributes (data) to return (comma separated)
   * If blank, whatever is configured in the grouper-ws.properties will be sent   
   * @return subject attribute names
   */
  public String getSubjectAttributeNames() {
    return this.subjectAttributeNames;
  }

  /**
   * are the additional subject attributes (data) to return (comma separated)
   * If blank, whatever is configured in the grouper-ws.properties will be sent   
   * @param subjectAttributeNames1
   */
  public void setSubjectAttributeNames(String subjectAttributeNames1) {
    this.subjectAttributeNames = subjectAttributeNames1;
  }


  /** T or F as to if the group detail should be returned */
  private String includeGroupDetail;
  
  /**
   * T or F as to if the group detail should be returned
   * @return T|F
   */
  public String getIncludeGroupDetail() {
    return this.includeGroupDetail;
  }

  /**
   * T or F as to if the group detail should be returned
   * @param includeGroupDetail1
   */
  public void setIncludeGroupDetail(String includeGroupDetail1) {
    this.includeGroupDetail = includeGroupDetail1;
  }

  /** reserved for future use */
  private String paramName0;
  
  /** reserved for future use */
  private String paramValue0;
  
  /** reserved for future use */
  private String paramName1; 

  /** reserved for future use */
  private String paramValue1; </pre></div></td></tr></table>
<table border="0" class="bodyTable">
<tr class="a">
<th>File</th>
<th>Line</th></tr>
<tr class="b">
<td>edu\internet2\middleware\grouperClient\config\ConfigPropertiesCascadeCommonUtils.java</td>
<td><a href="./xref/edu/internet2/middleware/grouperClient/config/ConfigPropertiesCascadeCommonUtils.html#L4002">4002</a></td></tr>
<tr class="a">
<td>edu\internet2\middleware\grouperClient\config\ConfigPropertiesCascadeCommonUtils.java</td>
<td><a href="./xref/edu/internet2/middleware/grouperClient/config/ConfigPropertiesCascadeCommonUtils.html#L4331">4331</a></td></tr>
<tr class="b">
<td>edu\internet2\middleware\grouperClient\util\GcElUtilsSafe.java</td>
<td><a href="./xref/edu/internet2/middleware/grouperClient/util/GcElUtilsSafe.html#L2307">2307</a></td></tr>
<tr class="a">
<td>edu\internet2\middleware\grouperClient\util\GrouperClientCommonUtils.java</td>
<td><a href="./xref/edu/internet2/middleware/grouperClient/util/GrouperClientCommonUtils.html#L4065">4065</a></td></tr>
<tr class="b">
<td>edu\internet2\middleware\grouperClient\util\GrouperClientCommonUtils.java</td>
<td><a href="./xref/edu/internet2/middleware/grouperClient/util/GrouperClientCommonUtils.html#L4394">4394</a></td></tr>
<tr class="a"><td colspan='2'>
<div>
<pre>        if (input.length() == 8) {
          
          return dateFormat().parse(input);
        }
        if (!contains(input, '.')) {
          if (contains(input, '/')) {
            return dateMinutesSecondsFormat.parse(input);
          }
          //else no slash
          return dateMinutesSecondsNoSlashFormat.parse(input);
        }
        if (contains(input, '/')) {
          //see if the period is 6 back
          int lastDotIndex = input.lastIndexOf('.');
          if (lastDotIndex == input.length() - 7) {
            String nonNanoInput = input.substring(0,input.length()-3);
            Date date = timestampFormat.parse(nonNanoInput);
            //get the last 3
            String lastThree = input.substring(input.length()-3,input.length());
            int lastThreeInt = Integer.parseInt(lastThree);
            Timestamp timestamp = new Timestamp(date.getTime());
            timestamp.setNanos(timestamp.getNanos() + (lastThreeInt * 1000));
            return timestamp;
          }
          return timestampFormat.parse(input);
        }
        //else no slash
        return timestampNoSlashFormat.parse(input);
      } catch (ParseException pe) {
        throw new RuntimeException(errorStart + toStringForLog(input));</pre></div></td></tr></table>
<table border="0" class="bodyTable">
<tr class="b">
<th>File</th>
<th>Line</th></tr>
<tr class="a">
<td>edu\internet2\middleware\grouperClient\config\ConfigPropertiesCascadeCommonUtils.java</td>
<td><a href="./xref/edu/internet2/middleware/grouperClient/config/ConfigPropertiesCascadeCommonUtils.html#L2517">2517</a></td></tr>
<tr class="b">
<td>edu\internet2\middleware\grouperClient\util\GcElUtilsSafe.java</td>
<td><a href="./xref/edu/internet2/middleware/grouperClient/util/GcElUtilsSafe.html#L1443">1443</a></td></tr>
<tr class="a">
<td>edu\internet2\middleware\grouperClient\util\GrouperClientCommonUtils.java</td>
<td><a href="./xref/edu/internet2/middleware/grouperClient/util/GrouperClientCommonUtils.html#L2580">2580</a></td></tr>
<tr class="b"><td colspan='2'>
<div>
<pre>  }

  /**
   * Convert a list to an array with the type of the first element e.g. if it
   * is a list of Person objects, then the array is Person[]
   * 
   * @param objectOrArrayOrCollection
   *            is a list
   * @return the array of objects with type of the first element in the list
   */
  public static Object toArray(Object objectOrArrayOrCollection) {
    // do this before length since if array with null in it, we want ti get
    // it back
    if (objectOrArrayOrCollection != null
        &amp;&amp; objectOrArrayOrCollection.getClass().isArray()) {
      return objectOrArrayOrCollection;
    }
    int length = length(objectOrArrayOrCollection);
    if (length == 0) {
      return null;
    }

    if (objectOrArrayOrCollection instanceof Collection) {
      Collection collection = (Collection) objectOrArrayOrCollection;
      Object first = collection.iterator().next();
      return toArray(collection, first == null ? Object.class : first
          .getClass());
    }
    // make an array of the type of object passed in, size one
    Object array = Array.newInstance(objectOrArrayOrCollection.getClass(),
        1);
    Array.set(array, 0, objectOrArrayOrCollection);
    return array;
  }

  /**
   * convert a list into an array of type of theClass
   * @param &lt;T&gt; is the type of the array
   * @param collection list to convert
   * @param theClass type of array to return
   * @return array of type theClass[] filled with the objects from list
   */
  @SuppressWarnings(&quot;unchecked&quot;)
  public static &lt;T&gt; T[] toArray(Collection collection, Class&lt;T&gt; theClass) {
    if (collection == null || collection.size() == 0) {
      return null;
    }

    return (T[])collection.toArray((Object[]) Array.newInstance(theClass,
        collection.size()));

  }

  /**
   * helper method for calling a static method up the stack. method takes no
   * args (could be in superclass)
   * 
   * @param theClass
   *            the class which has the method
   * @param methodName
   *            method name to call
   * @return the data
   */
  public static Object callMethod(Class theClass, String methodName) {</pre></div></td></tr></table>
<table border="0" class="bodyTable">
<tr class="a">
<th>File</th>
<th>Line</th></tr>
<tr class="b">
<td>edu\internet2\middleware\grouperClient\api\GcAssignAttributes.java</td>
<td><a href="./xref/edu/internet2/middleware/grouperClient/api/GcAssignAttributes.html#L221">221</a></td></tr>
<tr class="a">
<td>edu\internet2\middleware\grouperClient\api\GcGetAttributeAssignments.java</td>
<td><a href="./xref/edu/internet2/middleware/grouperClient/api/GcGetAttributeAssignments.html#L399">399</a></td></tr>
<tr class="b"><td colspan='2'>
<div>
<pre>  public GcAssignAttributes assignActAsSubject(WsSubjectLookup theActAsSubject) {
    this.actAsSubject = theActAsSubject;
    return this;
  }
  
  /**
   * validate this call
   */
  private void validate() {
    if (GrouperClientUtils.isBlank(this.attributeAssignType)) {
      throw new RuntimeException(&quot;attributeAssignType is required: &quot; + this);
    }
  }
  
  /** if the group detail should be sent back */
  private Boolean includeGroupDetail;
  
  /** if the subject detail should be sent back */
  private Boolean includeSubjectDetail;

  /** subject attribute names to return */
  private Set&lt;String&gt; subjectAttributeNames = new LinkedHashSet&lt;String&gt;();

  /** stem names to query */
  private Set&lt;String&gt; ownerStemNames = new LinkedHashSet&lt;String&gt;();

  /** stem uuids to query */
  private Set&lt;String&gt; ownerStemUuids = new LinkedHashSet&lt;String&gt;();

  /** stem id index to query */
  private Set&lt;Long&gt; ownerStemIdIndexes = new LinkedHashSet&lt;Long&gt;();

  /** attribute def names to query */
  private Set&lt;String&gt; ownerAttributeDefNames = new LinkedHashSet&lt;String&gt;();

  /** attribute def uuids to query */
  private Set&lt;String&gt; ownerAttributeDefUuids = new LinkedHashSet&lt;String&gt;();

  /** attribute def id indexes to query */
  private Set&lt;Long&gt; ownerAttributeDefIdIndexes = new LinkedHashSet&lt;Long&gt;();

  /** owner membership any lookup */
  private Set&lt;WsMembershipAnyLookup&gt; ownerMembershipAnyLookups = new LinkedHashSet&lt;WsMembershipAnyLookup&gt;();
  
  /** owner membership lookup */
  private Set&lt;WsMembershipLookup&gt; ownerMembershipLookups = new LinkedHashSet&lt;WsMembershipLookup&gt;();
  
  /** owner membership lookup */
  private Set&lt;WsAttributeAssignLookup&gt; attributeAssignLookups = new LinkedHashSet&lt;WsAttributeAssignLookup&gt;();

  /** attributeDefName names to query */
  private Set&lt;String&gt; attributeDefNameNames = new LinkedHashSet&lt;String&gt;();</pre></div></td></tr></table>
<table border="0" class="bodyTable">
<tr class="a">
<th>File</th>
<th>Line</th></tr>
<tr class="b">
<td>edu\internet2\middleware\grouperClient\config\ConfigPropertiesCascadeCommonUtils.java</td>
<td><a href="./xref/edu/internet2/middleware/grouperClient/config/ConfigPropertiesCascadeCommonUtils.html#L4004">4004</a></td></tr>
<tr class="a">
<td>edu\internet2\middleware\grouperClient\util\GcElUtilsSafe.java</td>
<td><a href="./xref/edu/internet2/middleware/grouperClient/util/GcElUtilsSafe.html#L2309">2309</a></td></tr>
<tr class="b">
<td>edu\internet2\middleware\grouperClient\util\GcElUtilsSafe.java</td>
<td><a href="./xref/edu/internet2/middleware/grouperClient/util/GcElUtilsSafe.html#L2811">2811</a></td></tr>
<tr class="a">
<td>edu\internet2\middleware\grouperClient\util\GrouperClientCommonUtils.java</td>
<td><a href="./xref/edu/internet2/middleware/grouperClient/util/GrouperClientCommonUtils.html#L4067">4067</a></td></tr>
<tr class="b"><td colspan='2'>
<div>
<pre>          return dateFormat().parse(input);
        }
        if (!contains(input, '.')) {
          if (contains(input, '/')) {
            return dateMinutesSecondsFormat.parse(input);
          }
          //else no slash
          return dateMinutesSecondsNoSlashFormat.parse(input);
        }
        if (contains(input, '/')) {
          //see if the period is 6 back
          int lastDotIndex = input.lastIndexOf('.');
          if (lastDotIndex == input.length() - 7) {
            String nonNanoInput = input.substring(0,input.length()-3);
            Date date = timestampFormat.parse(nonNanoInput);
            //get the last 3
            String lastThree = input.substring(input.length()-3,input.length());
            int lastThreeInt = Integer.parseInt(lastThree);
            Timestamp timestamp = new Timestamp(date.getTime());
            timestamp.setNanos(timestamp.getNanos() + (lastThreeInt * 1000));
            return timestamp;
          }
          return timestampFormat.parse(input);
        }
        //else no slash
        return timestampNoSlashFormat.parse(input);
      } catch (ParseException pe) {
        throw new RuntimeException(errorStart + toStringForLog(input));</pre></div></td></tr></table>
<table border="0" class="bodyTable">
<tr class="a">
<th>File</th>
<th>Line</th></tr>
<tr class="b">
<td>edu\internet2\middleware\grouperClient\config\ConfigPropertiesCascadeCommonUtils.java</td>
<td><a href="./xref/edu/internet2/middleware/grouperClient/config/ConfigPropertiesCascadeCommonUtils.html#L391">391</a></td></tr>
<tr class="a">
<td>edu\internet2\middleware\grouperClient\util\GrouperClientCommonUtils.java</td>
<td><a href="./xref/edu/internet2/middleware/grouperClient/util/GrouperClientCommonUtils.html#L395">395</a></td></tr>
<tr class="b"><td colspan='2'>
<div>
<pre>    synchronized (ConfigPropertiesCascadeCommonUtils.class) {
      lastId = incrementStringInt(lastId);
    }

    return String.valueOf(lastId);
  }

  /**
   * get a file name from a resource name
   * 
   * @param resourceName
   *          is the classpath location
   * 
   * @return the file path on the system
   */
  public static File fileFromResourceName(String resourceName) {
    
    URL url = computeUrl(resourceName, true);

    if (url == null) {
      return null;
    }

    try {
      String fileName = URLDecoder.decode(url.getFile(), &quot;UTF-8&quot;);
  
      File configFile = new File(fileName);

      return configFile;
    } catch (UnsupportedEncodingException uee) {
      throw new RuntimeException(uee);
    }
  }
  

  /**
   * compute a url of a resource
   * @param resourceName
   * @param canBeNull if cant be null, throw runtime
   * @return the URL
   */
  public static URL computeUrl(String resourceName, boolean canBeNull) {
    //get the url of the navigation file
    ClassLoader cl = classLoader();

    URL url = null;

    try {
      //CH 20081012: sometimes it starts with slash and it shouldnt...
      String newResourceName = resourceName.startsWith(&quot;/&quot;) 
        ? resourceName.substring(1) : resourceName;
      url = cl.getResource(newResourceName);
    } catch (NullPointerException npe) {
      String error = &quot;computeUrl() Could not find resource file: &quot; + resourceName;
      throw new RuntimeException(error, npe);
    }

    if (!canBeNull &amp;&amp; url == null) {
      throw new RuntimeException(&quot;Cant find resource: &quot; + resourceName);
    }

    return url;
  }


  /**
   * fast class loader
   * @return the class loader
   */
  public static ClassLoader classLoader() {
    return ConfigPropertiesCascadeCommonUtils.class.getClassLoader();</pre></div></td></tr></table>
<table border="0" class="bodyTable">
<tr class="a">
<th>File</th>
<th>Line</th></tr>
<tr class="b">
<td>edu\internet2\middleware\grouperClient\config\ConfigPropertiesCascadeCommonUtils.java</td>
<td><a href="./xref/edu/internet2/middleware/grouperClient/config/ConfigPropertiesCascadeCommonUtils.html#L7734">7734</a></td></tr>
<tr class="a">
<td>edu\internet2\middleware\grouperClient\util\GrouperClientCommonUtils.java</td>
<td><a href="./xref/edu/internet2/middleware/grouperClient/util/GrouperClientCommonUtils.html#L7836">7836</a></td></tr>
<tr class="b"><td colspan='2'>
<div>
<pre>    System.err.println(&quot;Grouper error: &quot; + error);
    return false;
  }

  /**
   * make sure a property is a class of a certain type
   * @param resourceName
   * @param properties 
   * @param overrideMap
   * @param key
   * @param classType
   * @param required 
   * @param exceptionOnError
   * @return true if ok
   */
  public static boolean propertyValidateValueClass(String resourceName, Properties properties, 
      Map&lt;String, String&gt; overrideMap, String key, Class&lt;?&gt; classType, boolean required, boolean exceptionOnError) {
  
    if (required &amp;&amp; !propertyValidateValueRequired(resourceName, properties, 
        overrideMap, key, exceptionOnError)) {
      return false;
    }
    String value = propertiesValue(properties, overrideMap, key);
  
    //maybe ok not there
    if (!required &amp;&amp; isBlank(value)) {
      return true;
    }
    
    String extraError = &quot;&quot;;
    try {
      
      
      Class&lt;?&gt; theClass = forName(value);
      if (classType.isAssignableFrom(theClass)) {
        return true;
      }
      extraError = &quot; does not derive from class: &quot; + classType.getSimpleName();
      
    } catch (Exception e) {
      extraError = &quot;, &quot; + getFullStackTrace(e);
    }
    String error = &quot;Cant process property &quot; + key + &quot; in resource: &quot; + resourceName + &quot;, the current&quot; +
        &quot; value is '&quot; + value + &quot;', which should be of type: &quot; 
        + classType.getName() + extraError;
    if (exceptionOnError) {
      throw new RuntimeException(error);
    }
    System.err.println(&quot;Grouper error: &quot; + error);</pre></div></td></tr></table>
<table border="0" class="bodyTable">
<tr class="a">
<th>File</th>
<th>Line</th></tr>
<tr class="b">
<td>edu\internet2\middleware\grouperClient\ws\beans\WsRestGetMembersRequest.java</td>
<td><a href="./xref/edu/internet2/middleware/grouperClient/ws/beans/WsRestGetMembersRequest.html#L218">218</a></td></tr>
<tr class="a">
<td>edu\internet2\middleware\grouperClient\ws\beans\WsRestGetSubjectsRequest.java</td>
<td><a href="./xref/edu/internet2/middleware/grouperClient/ws/beans/WsRestGetSubjectsRequest.html#L132">132</a></td></tr>
<tr class="b">
<td>edu\internet2\middleware\grouperClient\ws\beans\WsRestHasMemberRequest.java</td>
<td><a href="./xref/edu/internet2/middleware/grouperClient/ws/beans/WsRestHasMemberRequest.html#L122">122</a></td></tr>
<tr class="a"><td colspan='2'>
<div>
<pre>  }

  
  /**
   * @return the replaceAllExisting
   */
  public String getMemberFilter() {
    return this.memberFilter;
  }

  
  /**
   * @param replaceAllExisting1 the replaceAllExisting to set
   */
  public void setMemberFilter(String replaceAllExisting1) {
    this.memberFilter = replaceAllExisting1;
  }

  
  /**
   * @return the actAsSubjectLookup
   */
  public WsSubjectLookup getActAsSubjectLookup() {
    return this.actAsSubjectLookup;
  }

  
  /**
   * @param actAsSubjectLookup1 the actAsSubjectLookup to set
   */
  public void setActAsSubjectLookup(WsSubjectLookup actAsSubjectLookup1) {
    this.actAsSubjectLookup = actAsSubjectLookup1;
  }

  
  /**
   * @return the fieldName
   */
  public String getFieldName() {
    return this.fieldName;
  }

  
  /**
   * @param fieldName1 the fieldName to set
   */
  public void setFieldName(String fieldName1) {
    this.fieldName = fieldName1;
  }

  
  /**
   * @return the includeGroupDetail
   */
  public String getIncludeGroupDetail() {
    return this.includeGroupDetail;
  }

  
  /**
   * @param includeGroupDetail1 the includeGroupDetail to set
   */
  public void setIncludeGroupDetail(String includeGroupDetail1) {
    this.includeGroupDetail = includeGroupDetail1;
  }

  
  /**
   * @return the includeSubjectDetail
   */
  public String getIncludeSubjectDetail() {
    return this.includeSubjectDetail;
  }

  
  /**
   * @param includeSubjectDetail1 the includeSubjectDetail to set
   */
  public void setIncludeSubjectDetail(String includeSubjectDetail1) {
    this.includeSubjectDetail = includeSubjectDetail1;
  }

  
  /**
   * @return the subjectAttributeNames
   */
  public String[] getSubjectAttributeNames() {
    return this.subjectAttributeNames;
  }

  
  /**
   * @param subjectAttributeNames1 the subjectAttributeNames to set
   */
  public void setSubjectAttributeNames(String[] subjectAttributeNames1) {
    this.subjectAttributeNames = subjectAttributeNames1;
  }


  
  /**
   * @return the params
   */
  public WsParam[] getParams() {
    return this.params;
  }


  
  /**
   * @param params1 the params to set
   */
  public void setParams(WsParam[] params1) {
    this.params = params1;
  }
  
  /**
   * To query members at a certain point in time or time range in the past, set this value
   * and/or the value of pointInTimeTo.  This parameter specifies the start of the range
   * of the point in time query.  If this is specified but pointInTimeTo is not specified, 
   * then the point in time query range will be from the time specified to now.  
   * Format:  yyyy/MM/dd HH:mm:ss.SSS
   * @return the pointInTimeFrom
   */
  public String getPointInTimeFrom() {</pre></div></td></tr></table>
<table border="0" class="bodyTable">
<tr class="b">
<th>File</th>
<th>Line</th></tr>
<tr class="a">
<td>edu\internet2\middleware\grouperClient\ws\beans\WsRestAddMemberRequest.java</td>
<td><a href="./xref/edu/internet2/middleware/grouperClient/ws/beans/WsRestAddMemberRequest.html#L170">170</a></td></tr>
<tr class="b">
<td>edu\internet2\middleware\grouperClient\ws\beans\WsRestDeleteMemberRequest.java</td>
<td><a href="./xref/edu/internet2/middleware/grouperClient/ws/beans/WsRestDeleteMemberRequest.html#L104">104</a></td></tr>
<tr class="a"><td colspan='2'>
<div>
<pre>  }

  
  /**
   * @return the actAsSubjectLookup
   */
  public WsSubjectLookup getActAsSubjectLookup() {
    return this.actAsSubjectLookup;
  }

  
  /**
   * @param actAsSubjectLookup1 the actAsSubjectLookup to set
   */
  public void setActAsSubjectLookup(WsSubjectLookup actAsSubjectLookup1) {
    this.actAsSubjectLookup = actAsSubjectLookup1;
  }

  
  /**
   * @return the fieldName
   */
  public String getFieldName() {
    return this.fieldName;
  }

  
  /**
   * @param fieldName1 the fieldName to set
   */
  public void setFieldName(String fieldName1) {
    this.fieldName = fieldName1;
  }

  
  /**
   * @return the txType
   */
  public String getTxType() {
    return this.txType;
  }

  
  /**
   * @param txType1 the txType to set
   */
  public void setTxType(String txType1) {
    this.txType = txType1;
  }

  
  /**
   * @return the includeGroupDetail
   */
  public String getIncludeGroupDetail() {
    return this.includeGroupDetail;
  }

  
  /**
   * who to act as if not the connecting user
   * @param includeGroupDetail1 the includeGroupDetail to set
   */
  public void setIncludeGroupDetail(String includeGroupDetail1) {
    this.includeGroupDetail = includeGroupDetail1;
  }

  
  /**
   * @return the includeSubjectDetail
   */
  public String getIncludeSubjectDetail() {
    return this.includeSubjectDetail;
  }

  
  /**
   * @param includeSubjectDetail1 the includeSubjectDetail to set
   */
  public void setIncludeSubjectDetail(String includeSubjectDetail1) {
    this.includeSubjectDetail = includeSubjectDetail1;
  }

  
  /**
   * @return the subjectAttributeNames
   */
  public String[] getSubjectAttributeNames() {
    return this.subjectAttributeNames;
  }

  
  /**
   * @param subjectAttributeNames1 the subjectAttributeNames to set
   */
  public void setSubjectAttributeNames(String[] subjectAttributeNames1) {
    this.subjectAttributeNames = subjectAttributeNames1;
  }


  
  /**
   * @return the params
   */
  public WsParam[] getParams() {
    return this.params;
  }


  
  /**
   * @param params1 the params to set
   */
  public void setParams(WsParam[] params1) {
    this.params = params1;
  }</pre></div></td></tr></table>
<table border="0" class="bodyTable">
<tr class="b">
<th>File</th>
<th>Line</th></tr>
<tr class="a">
<td>edu\internet2\middleware\grouperClient\ws\beans\WsRestGetMembershipsRequest.java</td>
<td><a href="./xref/edu/internet2/middleware/grouperClient/ws/beans/WsRestGetMembershipsRequest.html#L331">331</a></td></tr>
<tr class="b">
<td>edu\internet2\middleware\grouperClient\ws\beans\WsRestGetSubjectsRequest.java</td>
<td><a href="./xref/edu/internet2/middleware/grouperClient/ws/beans/WsRestGetSubjectsRequest.html#L132">132</a></td></tr>
<tr class="a">
<td>edu\internet2\middleware\grouperClient\ws\beans\WsRestHasMemberRequest.java</td>
<td><a href="./xref/edu/internet2/middleware/grouperClient/ws/beans/WsRestHasMemberRequest.html#L122">122</a></td></tr>
<tr class="b"><td colspan='2'>
<div>
<pre>  }

  
  /**
   * must be one of All, Effective, Immediate, Composite, NonImmediate
   * @return the replaceAllExisting
   */
  public String getMemberFilter() {
    return this.memberFilter;
  }

  
  /**
   * must be one of All, Effective, Immediate, Composite, NonImmediate
   * @param replaceAllExisting1 the replaceAllExisting to set
   */
  public void setMemberFilter(String replaceAllExisting1) {
    this.memberFilter = replaceAllExisting1;
  }

  
  /**
   * subject to act as instead of logged in user
   * @return the actAsSubjectLookup
   */
  public WsSubjectLookup getActAsSubjectLookup() {
    return this.actAsSubjectLookup;
  }

  
  /**
   * subject to act as instead of logged in user
   * @param actAsSubjectLookup1 the actAsSubjectLookup to set
   */
  public void setActAsSubjectLookup(WsSubjectLookup actAsSubjectLookup1) {
    this.actAsSubjectLookup = actAsSubjectLookup1;
  }

  
  /**
   * is if the memberships should be retrieved from a certain field membership
   * of the group (certain list)
   * @return the fieldName
   */
  public String getFieldName() {
    return this.fieldName;
  }

  
  /**
   * is if the memberships should be retrieved from a certain field membership
   * of the group (certain list)
   * @param fieldName1 the fieldName to set
   */
  public void setFieldName(String fieldName1) {
    this.fieldName = fieldName1;
  }

  
  /**
   * T or F as to if the group detail should be returned
   * @return the includeGroupDetail
   */
  public String getIncludeGroupDetail() {
    return this.includeGroupDetail;
  }

  
  /**
   * T or F as to if the group detail should be returned
   * @param includeGroupDetail1 the includeGroupDetail to set
   */
  public void setIncludeGroupDetail(String includeGroupDetail1) {
    this.includeGroupDetail = includeGroupDetail1;
  }

  
  /**
   * T|F, for if the extended subject information should be
   * returned (anything more than just the id)
   * @return the includeSubjectDetail
   */
  public String getIncludeSubjectDetail() {
    return this.includeSubjectDetail;
  }

  
  /**
   * T|F, for if the extended subject information should be
   * returned (anything more than just the id)
   * @param includeSubjectDetail1 the includeSubjectDetail to set
   */
  public void setIncludeSubjectDetail(String includeSubjectDetail1) {
    this.includeSubjectDetail = includeSubjectDetail1;
  }

  
  /**
   *  are the additional subject attributes (data) to return.
   * If blank, whatever is configured in the grouper-ws.properties will be sent
   * @return the subjectAttributeNames
   */
  public String[] getSubjectAttributeNames() {
    return this.subjectAttributeNames;
  }

  
  /**
   *  are the additional subject attributes (data) to return.
   * If blank, whatever is configured in the grouper-ws.properties will be sent
   * @param subjectAttributeNames1 the subjectAttributeNames to set
   */
  public void setSubjectAttributeNames(String[] subjectAttributeNames1) {
    this.subjectAttributeNames = subjectAttributeNames1;
  }


  
  /**
   * optional: reserved for future use
   * @return the params
   */
  public WsParam[] getParams() {
    return this.params;
  }


  
  /**
   * optional: reserved for future use
   * @param params1 the params to set
   */
  public void setParams(WsParam[] params1) {
    this.params = params1;
  }</pre></div></td></tr></table>
<table border="0" class="bodyTable">
<tr class="a">
<th>File</th>
<th>Line</th></tr>
<tr class="b">
<td>edu\internet2\middleware\grouperClient\config\ConfigPropertiesCascadeCommonUtils.java</td>
<td><a href="./xref/edu/internet2/middleware/grouperClient/config/ConfigPropertiesCascadeCommonUtils.html#L5247">5247</a></td></tr>
<tr class="a">
<td>edu\internet2\middleware\grouperClient\util\GrouperClientCommonUtils.java</td>
<td><a href="./xref/edu/internet2/middleware/grouperClient/util/GrouperClientCommonUtils.html#L5315">5315</a></td></tr>
<tr class="b"><td colspan='2'>
<div>
<pre>  public static void propertiesCacheClear() {
    resourcePropertiesCache.clear();
  }
  
  /**
   * read properties from file
   * @param file
   * @return properties
   */
  public static Properties propertiesFromFile(File file) {
    Properties properties = new Properties();
    FileInputStream fileInputStream = null;
    try {
      
      fileInputStream = new FileInputStream(file);
      properties.load(fileInputStream);
      
    } catch (IOException ioe) {
      throw new RuntimeException(&quot;Problem reading file into properties: &quot; + file.getAbsolutePath());
    } finally {
      closeQuietly(fileInputStream);
    }
    return properties;
  }
  
  /**
   * read properties from a resource, dont modify the properties returned since they are cached
   * @param resourceName
   * @param useCache 
   * @param exceptionIfNotExist 
   * @param classInJar if not null, then look for the jar where this file is, and look in the same dir
   * @param callingLog 
   * @return the properties or null if not exist
   */
  public synchronized static Properties propertiesFromResourceName(String resourceName, boolean useCache, 
      boolean exceptionIfNotExist, Class&lt;?&gt; classInJar, StringBuilder callingLog) {

    Properties properties = resourcePropertiesCache.get(resourceName);
    
    if (!useCache || !resourcePropertiesCache.containsKey(resourceName)) {
  
      properties = new Properties();

      boolean success = false;
      
      URL url = computeUrl(resourceName, true);
      InputStream inputStream = null;
      try {
        inputStream = url.openStream();
        properties.load(inputStream);
        success = true;
        String theLog = &quot;Reading resource: &quot; + resourceName + &quot;, from: &quot; + url.toURI();
        if (callingLog != null) {</pre></div></td></tr></table>
<table border="0" class="bodyTable">
<tr class="a">
<th>File</th>
<th>Line</th></tr>
<tr class="b">
<td>edu\internet2\middleware\grouperClient\ws\beans\WsRestAssignPermissionsLiteRequest.java</td>
<td><a href="./xref/edu/internet2/middleware/grouperClient/ws/beans/WsRestAssignPermissionsLiteRequest.html#L391">391</a></td></tr>
<tr class="a">
<td>edu\internet2\middleware\grouperClient\ws\beans\WsRestGetPermissionAssignmentsLiteRequest.java</td>
<td><a href="./xref/edu/internet2/middleware/grouperClient/ws/beans/WsRestGetPermissionAssignmentsLiteRequest.html#L583">583</a></td></tr>
<tr class="b"><td colspan='2'>
<div>
<pre>  }

  /** if acting as another user */
  private String actAsSubjectId; 

  /** if acting as another user */
  private String actAsSubjectSourceId;
  
  /** if acting as another user */
  private String actAsSubjectIdentifier; 

  /**
   * if acting as another user
   * @return id
   */
  public String getActAsSubjectId() {
    return this.actAsSubjectId;
  }

  /**
   * if acting as another user
   * @param actAsSubjectId1
   */
  public void setActAsSubjectId(String actAsSubjectId1) {
    this.actAsSubjectId = actAsSubjectId1;
  }

  /**
   * if acting as another user
   * @return source id 
   */
  public String getActAsSubjectSourceId() {
    return this.actAsSubjectSourceId;
  }

  /**
   * if acting as another user
   * @param actAsSubjectSourceId1
   */
  public void setActAsSubjectSourceId(String actAsSubjectSourceId1) {
    this.actAsSubjectSourceId = actAsSubjectSourceId1;
  }

  /**
   * if acting as another user
   * @return subject identifier
   */
  public String getActAsSubjectIdentifier() {
    return this.actAsSubjectIdentifier;
  }

  /**
   * if acting as another user
   * @param actAsSubjectIdentifier1
   */
  public void setActAsSubjectIdentifier(String actAsSubjectIdentifier1) {
    this.actAsSubjectIdentifier = actAsSubjectIdentifier1;
  }


  /**
   * T|F, for if the extended subject information should be
   * returned (anything more than just the id)
   */
  private String includeSubjectDetail;
  
  /**
   * T|F, for if the extended subject information should be
   * returned (anything more than just the id)
   * @return T|F
   */
  public String getIncludeSubjectDetail() {
    return this.includeSubjectDetail;
  }

  /**
   * T|F, for if the extended subject information should be
   * returned (anything more than just the id)
   * @param includeSubjectDetail1
   */
  public void setIncludeSubjectDetail(String includeSubjectDetail1) {
    this.includeSubjectDetail = includeSubjectDetail1;
  }

  /**
   * are the additional subject attributes (data) to return (comma separated)
   * If blank, whatever is configured in the grouper-ws.properties will be sent   
   */
  private String subjectAttributeNames;
  
  /**
   * are the additional subject attributes (data) to return (comma separated)
   * If blank, whatever is configured in the grouper-ws.properties will be sent   
   * @return subject attribute names
   */
  public String getSubjectAttributeNames() {
    return this.subjectAttributeNames;
  }

  /**
   * are the additional subject attributes (data) to return (comma separated)
   * If blank, whatever is configured in the grouper-ws.properties will be sent   
   * @param subjectAttributeNames1
   */
  public void setSubjectAttributeNames(String subjectAttributeNames1) {
    this.subjectAttributeNames = subjectAttributeNames1;
  }


  /** T or F as to if the group detail should be returned */
  private String includeGroupDetail;
  
  /**
   * T or F as to if the group detail should be returned
   * @return T|F
   */
  public String getIncludeGroupDetail() {
    return this.includeGroupDetail;
  }

  /**
   * T or F as to if the group detail should be returned
   * @param includeGroupDetail1
   */
  public void setIncludeGroupDetail(String includeGroupDetail1) {
    this.includeGroupDetail = includeGroupDetail1;
  }

  /** reserved for future use */
  private String paramName0;
  
  /** reserved for future use */
  private String paramValue0;
  
  /** reserved for future use */
  private String paramName1; 

  /** reserved for future use */
  private String paramValue1;</pre></div></td></tr></table>
<table border="0" class="bodyTable">
<tr class="a">
<th>File</th>
<th>Line</th></tr>
<tr class="b">
<td>edu\internet2\middleware\grouperClient\discovery\DiscoveryClient.java</td>
<td><a href="./xref/edu/internet2/middleware/grouperClient/discovery/DiscoveryClient.html#L103">103</a></td></tr>
<tr class="a">
<td>edu\internet2\middleware\grouperClient\GrouperClient.java</td>
<td><a href="./xref/edu/internet2/middleware/grouperClient/GrouperClient.html#L279">279</a></td></tr>
<tr class="b"><td colspan='2'>
<div>
<pre>    String operation = null;
    try {
      if (GrouperClientUtils.length(args) == 0) {
        usage();
        return;
      }
      
      //map of all command line args
      Map&lt;String, String&gt; argMap = GrouperClientUtils.argMap(args);
      
      Map&lt;String, String&gt; argMapNotUsed = new LinkedHashMap&lt;String, String&gt;(argMap);

      boolean debugMode = GrouperClientUtils.argMapBoolean(argMap, argMapNotUsed, &quot;debug&quot;, false, false);
      
      GrouperClientLog.assignDebugToConsole(debugMode);
      
      //init if not already
      GrouperClientConfig.retrieveConfig().properties();
      
      //see where log file came from
      StringBuilder callingLog = new StringBuilder();
      GrouperClientUtils.propertiesFromResourceName(&quot;grouper.client.properties&quot;, 
          false, true, GrouperClientCommonUtils.class, callingLog);
      
      //see if the message about where it came from is
      //log.debug(callingLog.toString());
      
      operation = GrouperClientUtils.argMapString(argMap, argMapNotUsed, &quot;operation&quot;, true);
      
      //where results should go if file
      String saveResultsToFile = GrouperClientUtils.argMapString(argMap, argMapNotUsed, &quot;saveResultsToFile&quot;, false);
      boolean shouldSaveResultsToFile = !GrouperClientUtils.isBlank(saveResultsToFile);
      
      if (shouldSaveResultsToFile) {
        log.debug(&quot;Will save results to file: &quot; + GrouperClientUtils.fileCanonicalPath(new File(saveResultsToFile)));
      }
      
      String result = null;
      
      if (GrouperClientUtils.equals(operation, &quot;getFile&quot;)) {</pre></div></td></tr></table>
<table border="0" class="bodyTable">
<tr class="a">
<th>File</th>
<th>Line</th></tr>
<tr class="b">
<td>edu\internet2\middleware\grouperClient\config\ConfigPropertiesCascadeCommonUtils.java</td>
<td><a href="./xref/edu/internet2/middleware/grouperClient/config/ConfigPropertiesCascadeCommonUtils.html#L4805">4805</a></td></tr>
<tr class="a">
<td>edu\internet2\middleware\grouperClient\util\GrouperClientCommonUtils.java</td>
<td><a href="./xref/edu/internet2/middleware/grouperClient/util/GrouperClientCommonUtils.html#L4868">4868</a></td></tr>
<tr class="b"><td colspan='2'>
<div>
<pre>      writeStringToFile(file, contents, &quot;UTF-8&quot;);
    } catch (IOException ioe) {
      throw new RuntimeException(ioe);
    }
  }

  /**
   * save a string into a file, file does not have to exist
   * 
   * @param file
   *          is the file to save to
   * @param contents
   *          is the contents of the file
   * @param onlyIfDifferentContents true if only saving due to different contents
   * @param ignoreWhitespace true to ignore whitespace
   * @return true if contents were saved (thus different if param set)
   */
  public static boolean saveStringIntoFile(File file, String contents, 
      boolean onlyIfDifferentContents, boolean ignoreWhitespace) {
    if (onlyIfDifferentContents &amp;&amp; file.exists()) {
      String fileContents = readFileIntoString(file);
      String compressedContents = contents;
      if (ignoreWhitespace) {
        compressedContents = replaceWhitespaceWithSpace(compressedContents);
        fileContents = replaceWhitespaceWithSpace(fileContents);
      }
      
      //they are the same, dont worry about it
      if (equals(fileContents, compressedContents)) {
        return false;
      }
  
    }
    saveStringIntoFile(file, contents);
    return true;
  }

  /**
   * &lt;p&gt;
   * Writes data to a file. The file will be created if it does not exist.
   * &lt;/p&gt;
   * &lt;p&gt;
   * There is no readFileToString method without encoding parameter because
   * the default encoding can differ between platforms and therefore results
   * in inconsistent results.
   * &lt;/p&gt;
   *
   * @param file the file to write.
   * @param data The content to write to the file.
   * @param encoding encoding to use
   * @throws IOException in case of an I/O error
   * @throws UnsupportedEncodingException if the encoding is not supported
   *   by the VM
   */
  public static void writeStringToFile(File file, String data, String encoding)
      throws IOException {
    OutputStream out = new java.io.FileOutputStream(file);
    try {
      out.write(data.getBytes(encoding));
    } finally {
      closeQuietly(out);
    }
  }

  /**
   * @param file
   *          is the file to read into a string
   * 
   * @return String
   */
  public static String readFileIntoString(File file) {
  
    if (file == null) {
      return null;
    }
    try {
      return readFileToString(file, &quot;UTF-8&quot;);</pre></div></td></tr></table>
<table border="0" class="bodyTable">
<tr class="a">
<th>File</th>
<th>Line</th></tr>
<tr class="b">
<td>edu\internet2\middleware\grouperClient\config\ConfigPropertiesCascadeCommonUtils.java</td>
<td><a href="./xref/edu/internet2/middleware/grouperClient/config/ConfigPropertiesCascadeCommonUtils.html#L946">946</a></td></tr>
<tr class="a">
<td>edu\internet2\middleware\grouperClient\util\GcElUtilsSafe.java</td>
<td><a href="./xref/edu/internet2/middleware/grouperClient/util/GcElUtilsSafe.html#L1014">1014</a></td></tr>
<tr class="b">
<td>edu\internet2\middleware\grouperClient\util\GrouperClientCommonUtils.java</td>
<td><a href="./xref/edu/internet2/middleware/grouperClient/util/GrouperClientCommonUtils.html#L1009">1009</a></td></tr>
<tr class="a"><td colspan='2'>
<div>
<pre>      splitPreserveAllTokens(input, separator);

    //then trim
    for (int i = 0; (items != null) &amp;&amp; (i &lt; items.length); i++) {
      items[i] = trim(items[i]);
    }

    //return the array
    return items;
  }

  /**
   * escape url chars (e.g. a # is %23)
   * @param string input
   * @return the encoded string
   */
  public static String escapeUrlEncode(String string) {
    String result = null;
    try {
      result = URLEncoder.encode(string, &quot;UTF-8&quot;);
    } catch (UnsupportedEncodingException ex) {
      throw new RuntimeException(&quot;UTF-8 not supported&quot;, ex);
    }
    return result;
  }
  
  /**
   * unescape url chars (e.g. a space is %20)
   * @param string input
   * @return the encoded string
   */
  public static String escapeUrlDecode(String string) {
    String result = null;
    try {
      result = URLDecoder.decode(string, &quot;UTF-8&quot;);
    } catch (UnsupportedEncodingException ex) {
      throw new RuntimeException(&quot;UTF-8 not supported&quot;, ex);
    }
    return result;
  }

  /**
   * make sure a list is non null.  If null, then return an empty list
   * @param &lt;T&gt;
   * @param list
   * @return the list or empty list if null
   */
  public static &lt;T&gt; List&lt;T&gt; nonNull(List&lt;T&gt; list) {
    return list == null ? new ArrayList&lt;T&gt;() : list;
  }
  
  /**
   * make sure a list is non null.  If null, then return an empty set
   * @param &lt;T&gt;
   * @param set
   * @return the set or empty set if null
   */
  public static &lt;T&gt; Set&lt;T&gt; nonNull(Set&lt;T&gt; set) {</pre></div></td></tr></table>
<table border="0" class="bodyTable">
<tr class="b">
<th>File</th>
<th>Line</th></tr>
<tr class="a">
<td>edu\internet2\middleware\grouperClient\ws\beans\WsAssignPermissionsResults.java</td>
<td><a href="./xref/edu/internet2/middleware/grouperClient/ws/beans/WsAssignPermissionsResults.html#L101">101</a></td></tr>
<tr class="b">
<td>edu\internet2\middleware\grouperClient\ws\beans\WsGetPermissionAssignmentsResults.java</td>
<td><a href="./xref/edu/internet2/middleware/grouperClient/ws/beans/WsGetPermissionAssignmentsResults.html#L117">117</a></td></tr>
<tr class="a"><td colspan='2'>
<div>
<pre>  }

  /**
   * attributes of subjects returned, in same order as the data
   */
  private String[] subjectAttributeNames;

  /**
   * attributes of subjects returned, in same order as the data
   * @return the attributeNames
   */
  public String[] getSubjectAttributeNames() {
    return this.subjectAttributeNames;
  }

  /**
   * attributes of subjects returned, in same order as the data
   * @param attributeNamesa the attributeNames to set
   */
  public void setSubjectAttributeNames(String[] attributeNamesa) {
    this.subjectAttributeNames = attributeNamesa;
  }

  /**
   * metadata about the result
   */
  private WsResultMeta resultMetadata = new WsResultMeta();

  /**
   * @return the resultMetadata
   */
  public WsResultMeta getResultMetadata() {
    return this.resultMetadata;
  }

  /**
   * metadata about the result
   */
  private WsResponseMeta responseMetadata = new WsResponseMeta();

  /**
   * groups that are in the results
   */
  private WsGroup[] wsGroups;

  /**
   * subjects that are in the results
   */
  private WsSubject[] wsSubjects;

  /**
   * @see edu.internet2.middleware.grouper.ws.rest.WsResponseBean#getResponseMetadata()
   * @return the response metadata
   */
  public WsResponseMeta getResponseMetadata() {
    return this.responseMetadata;
  }

  
  /**
   * @param resultMetadata1 the resultMetadata to set
   */
  public void setResultMetadata(WsResultMeta resultMetadata1) {
    this.resultMetadata = resultMetadata1;
  }

  
  /**
   * @param responseMetadata1 the responseMetadata to set
   */
  public void setResponseMetadata(WsResponseMeta responseMetadata1) {
    this.responseMetadata = responseMetadata1;
  }

  /**
   * @return the wsGroups
   */
  public WsGroup[] getWsGroups() {
    return this.wsGroups;
  }

  /**
   * subjects that are in the results
   * @return the subjects
   */
  public WsSubject[] getWsSubjects() {
    return this.wsSubjects;
  }

  /**
   * @param wsGroup1 the wsGroups to set
   */
  public void setWsGroups(WsGroup[] wsGroup1) {
    this.wsGroups = wsGroup1;
  }

  /**
   * subjects that are in the results
   * @param wsSubjects1
   */
  public void setWsSubjects(WsSubject[] wsSubjects1) {
    this.wsSubjects = wsSubjects1;
  }
}</pre></div></td></tr></table>
<table border="0" class="bodyTable">
<tr class="b">
<th>File</th>
<th>Line</th></tr>
<tr class="a">
<td>edu\internet2\middleware\grouperClient\ws\beans\WsRestAssignAttributesRequest.java</td>
<td><a href="./xref/edu/internet2/middleware/grouperClient/ws/beans/WsRestAssignAttributesRequest.html#L405">405</a></td></tr>
<tr class="b">
<td>edu\internet2\middleware\grouperClient\ws\beans\WsRestAssignPermissionsRequest.java</td>
<td><a href="./xref/edu/internet2/middleware/grouperClient/ws/beans/WsRestAssignPermissionsRequest.html#L254">254</a></td></tr>
<tr class="a"><td colspan='2'>
<div>
<pre>  }

  /**
   * actions to query, or none to query all actions
   */
  private String[] actions; 
  
  /**
   * actions to query, or none to query all actions
   * @return actions
   */
  public String[] getActions() {
    return this.actions;
  }

  /**
   * actions to query, or none to query all actions
   * @param actions1
   */
  public void setActions(String[] actions1) {
    this.actions = actions1;
  }

  /** if acting as someone else */
  private WsSubjectLookup actAsSubjectLookup;
  
  /**
   * if acting as someone else
   * @return act as subject
   */
  public WsSubjectLookup getActAsSubjectLookup() {
    return this.actAsSubjectLookup;
  }

  /**
   * if acting as someone else
   * @param actAsSubjectLookup1
   */
  public void setActAsSubjectLookup(WsSubjectLookup actAsSubjectLookup1) {
    this.actAsSubjectLookup = actAsSubjectLookup1;
  }

  /**
   * T|F, for if the extended subject information should be
   * returned (anything more than just the id)
   */
  private String includeSubjectDetail;
  
  /**
   * T|F, for if the extended subject information should be
   * returned (anything more than just the id)
   * @return T|F
   */
  public String getIncludeSubjectDetail() {
    return this.includeSubjectDetail;
  }
  
  /**
   * T|F, for if the extended subject information should be
   * returned (anything more than just the id)
   * @param includeSubjectDetail1
   */
  public void setIncludeSubjectDetail(String includeSubjectDetail1) {
    this.includeSubjectDetail = includeSubjectDetail1;
  }

  /** are the additional subject attributes (data) to return. 
   * If blank, whatever is configured in the grouper-ws.properties will be sent
   */
  private String[] subjectAttributeNames;

  
  
  /**
   * are the additional subject attributes (data) to return.
   * If blank, whatever is configured in the grouper-ws.properties will be sent
   * @return subject attribute names
   */
  public String[] getSubjectAttributeNames() {
    return this.subjectAttributeNames;
  }

  /**
   * are the additional subject attributes (data) to return.
   * If blank, whatever is configured in the grouper-ws.properties will be sent
   * @param subjectAttributeNames1
   */
  public void setSubjectAttributeNames(String[] subjectAttributeNames1) {
    this.subjectAttributeNames = subjectAttributeNames1;
  }

  /** T or F as to if the group detail should be returned */
  private String includeGroupDetail;
  
  
  
  /**
   * T or F as to if the group detail should be returned
   * @return T|F
   */
  public String getIncludeGroupDetail() {
    return this.includeGroupDetail;
  }

  /**
   * T or F as to if the group detail should be returned
   * @param includeGroupDetail1
   */
  public void setIncludeGroupDetail(String includeGroupDetail1) {
    this.includeGroupDetail = includeGroupDetail1;
  }

  /** optional: reserved for future use */
  private  WsParam[] params;

  /**
   * if replacing attributeDefNames, then these are the
   * related actions, if blank, then just do all
   */
  private String[] actionsToReplace;

  /**
   * if replacing attributeDefNames, then these 
   * are the related attributeDefs, if blank, then just do all
   */
  private WsAttributeDefLookup[] attributeDefsToReplace;

  /**
   * if replacing attributeDefNames, then these are the
   * related attributeDefTypes, if blank, then just do all
   */
  private String[] attributeDefTypesToReplace;</pre></div></td></tr></table>
<table border="0" class="bodyTable">
<tr class="b">
<th>File</th>
<th>Line</th></tr>
<tr class="a">
<td>edu\internet2\middleware\grouperClient\config\ConfigPropertiesCascadeCommonUtils.java</td>
<td><a href="./xref/edu/internet2/middleware/grouperClient/config/ConfigPropertiesCascadeCommonUtils.html#L1450">1450</a></td></tr>
<tr class="b">
<td>edu\internet2\middleware\grouperClient\util\GcElUtilsSafe.java</td>
<td><a href="./xref/edu/internet2/middleware/grouperClient/util/GcElUtilsSafe.html#L1401">1401</a></td></tr>
<tr class="a">
<td>edu\internet2\middleware\grouperClient\util\GrouperClientCommonUtils.java</td>
<td><a href="./xref/edu/internet2/middleware/grouperClient/util/GrouperClientCommonUtils.html#L1513">1513</a></td></tr>
<tr class="b"><td colspan='2'>
<div>
<pre>        result.append(((Class)object).getSimpleName());
        if (i &lt; length-1) {
          result.append(&quot;, &quot;);
        }
      }
      return result.toString();
    }
    
    throw new RuntimeException(&quot;Not implemented: &quot; + className(object));
  }
  
  /**
   * null safe classname method, max out at 20
   * 
   * @param object
   * @return the classname
   */
  public static String classNameCollection(Object object) {
    if (object == null) {
      return null;
    }
    StringBuffer result = new StringBuffer();
    
    Iterator iterator = iterator(object);
    int length = length(object);
    for (int i = 0; i &lt; length &amp;&amp; i &lt; 20; i++) {
      result.append(className(next(object, iterator, i)));
      if (i != length - 1) {
        result.append(&quot;, &quot;);
      }
    }
    return result.toString();
  }

  /**
   * null safe classname method, gets the unenhanced name
   * 
   * @param object
   * @return the classname
   */
  public static String className(Object object) {
    return object == null ? null : object.getClass().getName();
  }</pre></div></td></tr></table>
<table border="0" class="bodyTable">
<tr class="a">
<th>File</th>
<th>Line</th></tr>
<tr class="b">
<td>edu\internet2\middleware\grouperClient\config\ConfigPropertiesCascadeCommonUtils.java</td>
<td><a href="./xref/edu/internet2/middleware/grouperClient/config/ConfigPropertiesCascadeCommonUtils.html#L8421">8421</a></td></tr>
<tr class="a">
<td>edu\internet2\middleware\grouperClient\util\GcElUtilsSafe.java</td>
<td><a href="./xref/edu/internet2/middleware/grouperClient/util/GcElUtilsSafe.html#L5424">5424</a></td></tr>
<tr class="b">
<td>edu\internet2\middleware\grouperClient\util\GrouperClientCommonUtils.java</td>
<td><a href="./xref/edu/internet2/middleware/grouperClient/util/GrouperClientCommonUtils.html#L8524">8524</a></td></tr>
<tr class="a"><td colspan='2'>
<div>
<pre>  }

  /**
   * &lt;p&gt;Find the index of the given object in the array.&lt;/p&gt;
   *
   * &lt;p&gt;This method returns &lt;code&gt;-1&lt;/code&gt; if &lt;code&gt;null&lt;/code&gt; array input.&lt;/p&gt;
   * 
   * @param array  the array to search through for the object, may be &lt;code&gt;null&lt;/code&gt;
   * @param objectToFind  the object to find, may be &lt;code&gt;null&lt;/code&gt;
   * @return the index of the object within the array, 
   *  &lt;code&gt;-1&lt;/code&gt; if not found or &lt;code&gt;null&lt;/code&gt; array input
   */
  public static int indexOf(Object[] array, Object objectToFind) {
    return indexOf(array, objectToFind, 0);
  }

  /**
   * &lt;p&gt;Checks if the object is in the given array.&lt;/p&gt;
   *
   * &lt;p&gt;The method returns &lt;code&gt;false&lt;/code&gt; if a &lt;code&gt;null&lt;/code&gt; array is passed in.&lt;/p&gt;
   * 
   * @param array  the array to search through
   * @param objectToFind  the object to find
   * @return &lt;code&gt;true&lt;/code&gt; if the array contains the object
   */
  public static boolean contains(Object[] array, Object objectToFind) {
    return indexOf(array, objectToFind) != -1;
  }

  /**
   * &lt;p&gt;Find the index of the given object in the array starting at the given index.&lt;/p&gt;
   *
   * &lt;p&gt;This method returns &lt;code&gt;-1&lt;/code&gt; if &lt;code&gt;null&lt;/code&gt; array input.&lt;/p&gt;
   *
   * &lt;p&gt;A negative startIndex is treated as zero. A startIndex larger than the array
   * length will return &lt;code&gt;-1&lt;/code&gt;.&lt;/p&gt;
   * 
   * @param array  the array to search through for the object, may be &lt;code&gt;null&lt;/code&gt;
   * @param objectToFind  the object to find, may be &lt;code&gt;null&lt;/code&gt;
   * @param startIndex  the index to start searching at
   * @return the index of the object within the array starting at the index,
   *  &lt;code&gt;-1&lt;/code&gt; if not found or &lt;code&gt;null&lt;/code&gt; array input
   */
  public static int indexOf(Object[] array, Object objectToFind, int startIndex) {
    if (array == null) {
      return -1;
    }
    if (startIndex &lt; 0) {
      startIndex = 0;
    }
    if (objectToFind == null) {
      for (int i = startIndex; i &lt; array.length; i++) {
        if (array[i] == null) {
          return i;
        }
      }
    } else {
      for (int i = startIndex; i &lt; array.length; i++) {
        if (objectToFind.equals(array[i])) {
          return i;
        }
      }
    }
    return -1;
  }</pre></div></td></tr></table>
<table border="0" class="bodyTable">
<tr class="b">
<th>File</th>
<th>Line</th></tr>
<tr class="a">
<td>edu\internet2\middleware\grouperClient\examples\LdapExample.java</td>
<td><a href="./xref/edu/internet2/middleware/grouperClient/examples/LdapExample.html#L334">334</a></td></tr>
<tr class="b">
<td>edu\internet2\middleware\grouperClient\util\GrouperClientLdapUtils.java</td>
<td><a href="./xref/edu/internet2/middleware/grouperClient/util/GrouperClientLdapUtils.html#L175">175</a></td></tr>
<tr class="a"><td colspan='2'>
<div>
<pre>  public static void printNamingEnumeration(NamingEnumeration namingEnumeration) throws NamingException {
    while (namingEnumeration.hasMore()) {
      Object nextElement = namingEnumeration.next();
      if (nextElement instanceof Attribute) {
        Attribute attribute = (Attribute)nextElement;
        printAttribute(attribute);
      } else if (nextElement instanceof SearchResult) {
        SearchResult searchResult = (SearchResult)nextElement;
        System.out.println(&quot;Search result: &quot; + searchResult.getNameInNamespace());
        Attributes attributes = searchResult.getAttributes();
        printAttributes(attributes);
      } else if (nextElement instanceof NameClassPair) {
        NameClassPair nameClassPair = (NameClassPair)namingEnumeration.nextElement();
        System.out.println(&quot;Name class pair: &quot; + nameClassPair.getClassName() + &quot;, &quot; + nameClassPair.getNameInNamespace());
      } else {
        throw new RuntimeException(&quot;Not expecting type: &quot; + nextElement);
      }
      
    }
    
  }
  
  /**
   * retrieve a single valued attribute as string
   * @param object
   * @param attributeName 
   * @throws NamingException 
   * @return the attribute value or null if not there
   */
  public static String retrieveAttributeStringValue(Object object, 
      String attributeName) throws NamingException {
    if (object == null) {
      return null;
    }</pre></div></td></tr></table>
<table border="0" class="bodyTable">
<tr class="b">
<th>File</th>
<th>Line</th></tr>
<tr class="a">
<td>edu\internet2\middleware\grouperClient\ws\beans\WsRestGetGroupsRequest.java</td>
<td><a href="./xref/edu/internet2/middleware/grouperClient/ws/beans/WsRestGetGroupsRequest.html#L319">319</a></td></tr>
<tr class="b">
<td>edu\internet2\middleware\grouperClient\ws\beans\WsRestGetMembersRequest.java</td>
<td><a href="./xref/edu/internet2/middleware/grouperClient/ws/beans/WsRestGetMembersRequest.html#L265">265</a></td></tr>
<tr class="a">
<td>edu\internet2\middleware\grouperClient\ws\beans\WsRestHasMemberRequest.java</td>
<td><a href="./xref/edu/internet2/middleware/grouperClient/ws/beans/WsRestHasMemberRequest.html#L169">169</a></td></tr>
<tr class="b"><td colspan='2'>
<div>
<pre>    this.memberFilter = fieldName1;
  }

  
  /**
   * @return the includeGroupDetail
   */
  public String getIncludeGroupDetail() {
    return this.includeGroupDetail;
  }

  
  /**
   * @param includeGroupDetail1 the includeGroupDetail to set
   */
  public void setIncludeGroupDetail(String includeGroupDetail1) {
    this.includeGroupDetail = includeGroupDetail1;
  }

  
  /**
   * @return the includeSubjectDetail
   */
  public String getIncludeSubjectDetail() {
    return this.includeSubjectDetail;
  }

  
  /**
   * @param includeSubjectDetail1 the includeSubjectDetail to set
   */
  public void setIncludeSubjectDetail(String includeSubjectDetail1) {
    this.includeSubjectDetail = includeSubjectDetail1;
  }

  
  /**
   * @return the subjectAttributeNames
   */
  public String[] getSubjectAttributeNames() {
    return this.subjectAttributeNames;
  }

  
  /**
   * @param subjectAttributeNames1 the subjectAttributeNames to set
   */
  public void setSubjectAttributeNames(String[] subjectAttributeNames1) {
    this.subjectAttributeNames = subjectAttributeNames1;
  }


  
  /**
   * @return the params
   */
  public WsParam[] getParams() {
    return this.params;
  }


  
  /**
   * @param params1 the params to set
   */
  public void setParams(WsParam[] params1) {
    this.params = params1;
  }

  /**
   * To query members at a certain point in time or time range in the past, set this value
   * and/or the value of pointInTimeTo.  This parameter specifies the start of the range
   * of the point in time query.  If this is specified but pointInTimeTo is not specified, 
   * then the point in time query range will be from the time specified to now.  
   * Format:  yyyy/MM/dd HH:mm:ss.SSS
   * @return the pointInTimeFrom
   */
  public String getPointInTimeFrom() {
    return this.pointInTimeFrom;
  }

  
  /**
   * To query members at a certain point in time or time range in the past, set this value
   * and/or the value of pointInTimeTo.  This parameter specifies the start of the range
   * of the point in time query.  If this is specified but pointInTimeTo is not specified, 
   * then the point in time query range will be from the time specified to now.  
   * Format:  yyyy/MM/dd HH:mm:ss.SSS
   * @param pointInTimeFrom1 the pointInTimeFrom to set
   */
  public void setPointInTimeFrom(String pointInTimeFrom1) {
    this.pointInTimeFrom = pointInTimeFrom1;
  }

  
  /**
   * To query members at a certain point in time or time range in the past, set this value
   * and/or the value of pointInTimeFrom.  This parameter specifies the end of the range 
   * of the point in time query.  If this is the same as pointInTimeFrom, then the query 
   * will be done at a single point in time rather than a range.  If this is specified but 
   * pointInTimeFrom is not specified, then the point in time query range will be from the 
   * minimum point in time to the time specified.  Format: yyyy/MM/dd HH:mm:ss.SSS 
   * @return the pointInTimeTo
   */
  public String getPointInTimeTo() {
    return this.pointInTimeTo;
  }

  
  /**
   * To query members at a certain point in time or time range in the past, set this value
   * and/or the value of pointInTimeFrom.  This parameter specifies the end of the range 
   * of the point in time query.  If this is the same as pointInTimeFrom, then the query 
   * will be done at a single point in time rather than a range.  If this is specified but 
   * pointInTimeFrom is not specified, then the point in time query range will be from the 
   * minimum point in time to the time specified.  Format: yyyy/MM/dd HH:mm:ss.SSS 
   * @param pointInTimeTo1 the pointInTimeTo to set
   */
  public void setPointInTimeTo(String pointInTimeTo1) {
    this.pointInTimeTo = pointInTimeTo1;
  }
}</pre></div></td></tr></table>
<table border="0" class="bodyTable">
<tr class="a">
<th>File</th>
<th>Line</th></tr>
<tr class="b">
<td>edu\internet2\middleware\grouperClient\config\ConfigPropertiesCascadeCommonUtils.java</td>
<td><a href="./xref/edu/internet2/middleware/grouperClient/config/ConfigPropertiesCascadeCommonUtils.html#L461">461</a></td></tr>
<tr class="a">
<td>edu\internet2\middleware\grouperClient\util\GrouperClientCommonUtils.java</td>
<td><a href="./xref/edu/internet2/middleware/grouperClient/util/GrouperClientCommonUtils.html#L465">465</a></td></tr>
<tr class="b"><td colspan='2'>
<div>
<pre>    return ConfigPropertiesCascadeCommonUtils.class.getClassLoader();
  }

  /**
   * make sure a array is non null.  If null, then return an empty array.
   * Note: this will probably not work for primitive arrays (e.g. int[])
   * @param &lt;T&gt;
   * @param array
   * @param theClass to make array from
   * @return the list or empty list if null
   */
  @SuppressWarnings(&quot;unchecked&quot;)
  public static &lt;T&gt; T[] nonNull(T[] array, Class&lt;?&gt; theClass) {
    return array == null ? ((T[])Array.newInstance(theClass, 0)) : array;
  }
  
  /**
   * get the prefix or suffix of a string based on a separator
   * 
   * @param startString
   *          is the string to start with
   * @param separator
   *          is the separator to split on
   * @param isPrefix
   *          if thre prefix or suffix should be returned
   * 
   * @return the prefix or suffix, if the separator isnt there, return the
   *         original string
   */
  public static String prefixOrSuffix(String startString, String separator,
      boolean isPrefix) {
    String prefixOrSuffix = null;

    //no nulls
    if (startString == null) {
      return startString;
    }

    //where is the separator
    int separatorIndex = startString.indexOf(separator);

    //if none exists, dont proceed
    if (separatorIndex == -1) {
      return startString;
    }

    //maybe the separator isnt on character
    int separatorLength = separator.length();

    if (isPrefix) {
      prefixOrSuffix = startString.substring(0, separatorIndex);
    } else {
      prefixOrSuffix = startString.substring(separatorIndex + separatorLength,
          startString.length());
    }

    return prefixOrSuffix;
  }

  /**
   * get the extension from name.  if name is a:b:c, name is c
   * @param name
   * @return the name
   */
  public static String extensionFromName(String name) {</pre></div></td></tr></table>
<table border="0" class="bodyTable">
<tr class="a">
<th>File</th>
<th>Line</th></tr>
<tr class="b">
<td>edu\internet2\middleware\grouperClient\config\ConfigPropertiesCascadeCommonUtils.java</td>
<td><a href="./xref/edu/internet2/middleware/grouperClient/config/ConfigPropertiesCascadeCommonUtils.html#L3257">3257</a></td></tr>
<tr class="a">
<td>edu\internet2\middleware\grouperClient\util\GcElUtilsSafe.java</td>
<td><a href="./xref/edu/internet2/middleware/grouperClient/util/GcElUtilsSafe.html#L5746">5746</a></td></tr>
<tr class="b">
<td>edu\internet2\middleware\grouperClient\util\GrouperClientCommonUtils.java</td>
<td><a href="./xref/edu/internet2/middleware/grouperClient/util/GrouperClientCommonUtils.html#L3320">3320</a></td></tr>
<tr class="a"><td colspan='2'>
<div>
<pre>  }

  /**
   * Get a specific index of an array or collection (note for collections and
   * iterating, it is more efficient to get an iterator and iterate
   * 
   * @param arrayOrCollection
   * @param index
   * @return the object at that index
   */
  public static Object get(Object arrayOrCollection, int index) {

    if (arrayOrCollection == null) {
      if (index == 0) {
        return null;
      }
      throw new RuntimeException(&quot;Trying to access index &quot; + index
          + &quot; of null&quot;);
    }

    // no need to iterator on list (e.g. FastProxyList has no iterator
    if (arrayOrCollection instanceof List) {
      return ((List) arrayOrCollection).get(index);
    }
    if (arrayOrCollection instanceof Collection) {
      Iterator iterator = iterator(arrayOrCollection);
      for (int i = 0; i &lt; index; i++) {
        next(arrayOrCollection, iterator, i);
      }
      return next(arrayOrCollection, iterator, index);
    }

    if (arrayOrCollection.getClass().isArray()) {
      return Array.get(arrayOrCollection, index);
    }

    if (index == 0) {
      return arrayOrCollection;
    }

    throw new RuntimeException(&quot;Trying to access index &quot; + index
        + &quot; of and object: &quot; + arrayOrCollection);
  }</pre></div></td></tr></table>
<table border="0" class="bodyTable">
<tr class="b">
<th>File</th>
<th>Line</th></tr>
<tr class="a">
<td>edu\internet2\middleware\grouperClient\ws\beans\WsRestAssignAttributesBatchRequest.java</td>
<td><a href="./xref/edu/internet2/middleware/grouperClient/ws/beans/WsRestAssignAttributesBatchRequest.html#L97">97</a></td></tr>
<tr class="b">
<td>edu\internet2\middleware\grouperClient\ws\beans\WsRestGetAttributeAssignmentsRequest.java</td>
<td><a href="./xref/edu/internet2/middleware/grouperClient/ws/beans/WsRestGetAttributeAssignmentsRequest.html#L386">386</a></td></tr>
<tr class="a">
<td>edu\internet2\middleware\grouperClient\ws\beans\WsRestGetPermissionAssignmentsRequest.java</td>
<td><a href="./xref/edu/internet2/middleware/grouperClient/ws/beans/WsRestGetPermissionAssignmentsRequest.html#L354">354</a></td></tr>
<tr class="b"><td colspan='2'>
<div>
<pre>  }

  /** if acting as someone else */
  private WsSubjectLookup actAsSubjectLookup;
  
  /**
   * if acting as someone else
   * @return act as subject
   */
  public WsSubjectLookup getActAsSubjectLookup() {
    return this.actAsSubjectLookup;
  }

  /**
   * if acting as someone else
   * @param actAsSubjectLookup1
   */
  public void setActAsSubjectLookup(WsSubjectLookup actAsSubjectLookup1) {
    this.actAsSubjectLookup = actAsSubjectLookup1;
  }

  /**
   * T|F, for if the extended subject information should be
   * returned (anything more than just the id)
   */
  private String includeSubjectDetail;
  
  /**
   * T|F, for if the extended subject information should be
   * returned (anything more than just the id)
   * @return T|F
   */
  public String getIncludeSubjectDetail() {
    return this.includeSubjectDetail;
  }
  
  /**
   * T|F, for if the extended subject information should be
   * returned (anything more than just the id)
   * @param includeSubjectDetail1
   */
  public void setIncludeSubjectDetail(String includeSubjectDetail1) {
    this.includeSubjectDetail = includeSubjectDetail1;
  }

  /** are the additional subject attributes (data) to return. 
   * If blank, whatever is configured in the grouper-ws.properties will be sent
   */
  private String[] subjectAttributeNames;

  
  
  /**
   * are the additional subject attributes (data) to return.
   * If blank, whatever is configured in the grouper-ws.properties will be sent
   * @return subject attribute names
   */
  public String[] getSubjectAttributeNames() {
    return this.subjectAttributeNames;
  }

  /**
   * are the additional subject attributes (data) to return.
   * If blank, whatever is configured in the grouper-ws.properties will be sent
   * @param subjectAttributeNames1
   */
  public void setSubjectAttributeNames(String[] subjectAttributeNames1) {
    this.subjectAttributeNames = subjectAttributeNames1;
  }

  /** T or F as to if the group detail should be returned */
  private String includeGroupDetail;
  
  
  
  /**
   * T or F as to if the group detail should be returned
   * @return T|F
   */
  public String getIncludeGroupDetail() {
    return this.includeGroupDetail;
  }

  /**
   * T or F as to if the group detail should be returned
   * @param includeGroupDetail1
   */
  public void setIncludeGroupDetail(String includeGroupDetail1) {
    this.includeGroupDetail = includeGroupDetail1;
  }

  /** optional: reserved for future use */
  private  WsParam[] params;

  
  
  /**
   * optional: reserved for future use
   * @return params
   */
  public WsParam[] getParams() {
    return this.params;
  }

  /**
   * optional: reserved for future use
   * @param params1
   */
  public void setParams(WsParam[] params1) {
    this.params = params1;
  }</pre></div></td></tr></table>
<table border="0" class="bodyTable">
<tr class="a">
<th>File</th>
<th>Line</th></tr>
<tr class="b">
<td>edu\internet2\middleware\grouperClient\ws\beans\WsRestAssignGrouperPrivilegesLiteRequest.java</td>
<td><a href="./xref/edu/internet2/middleware/grouperClient/ws/beans/WsRestAssignGrouperPrivilegesLiteRequest.html#L378">378</a></td></tr>
<tr class="a">
<td>edu\internet2\middleware\grouperClient\ws\beans\WsRestGetSubjectsLiteRequest.java</td>
<td><a href="./xref/edu/internet2/middleware/grouperClient/ws/beans/WsRestGetSubjectsLiteRequest.html#L242">242</a></td></tr>
<tr class="b"><td colspan='2'>
<div>
<pre>  }

  /**
   * additional subject attributes (data) to return.
   * If blank, whatever is configured in the grouper-ws.properties will be sent (comma separated)
   * @return names to return
   */
  public String getSubjectAttributeNames() {
    return this.subjectAttributeNames;
  }

  /**
   * additional subject attributes (data) to return.
   * If blank, whatever is configured in the grouper-ws.properties will be sent (comma separated)
   * @param subjectAttributeNames1
   */
  public void setSubjectAttributeNames(String subjectAttributeNames1) {
    this.subjectAttributeNames = subjectAttributeNames1;
  }

  /**
   * T or F as for if group detail should be included
   * @return T of F
   */
  public String getIncludeGroupDetail() {
    return this.includeGroupDetail;
  }

  /**
   * T or F as for if group detail should be included
   * @param includeGroupDetail1
   */
  public void setIncludeGroupDetail(String includeGroupDetail1) {
    this.includeGroupDetail = includeGroupDetail1;
  }

  /**
   * reserved for future use
   * @return param
   */
  public String getParamName0() {
    return this.paramName0;
  }

  /**
   * reserved for future use
   * @param _paramName0
   */
  public void setParamName0(String _paramName0) {
    this.paramName0 = _paramName0;
  }

  /**
   * reserved for future use
   * @return param
   */
  public String getParamValue0() {
    return this.paramValue0;
  }

  /**
   * reserved for future use
   * @param _paramValue0
   */
  public void setParamValue0(String _paramValue0) {
    this.paramValue0 = _paramValue0;
  }

  /**
   * reserved for future use
   * @return param
   */
  public String getParamName1() {
    return this.paramName1;
  }

  /**
   * reserved for future use
   * @param _paramName1
   */
  public void setParamName1(String _paramName1) {
    this.paramName1 = _paramName1;
  }

  /**
   * reserved for future use
   * @return param
   */
  public String getParamValue1() {
    return this.paramValue1;
  }

  /**
   * reserved for future use
   * @param _paramValue1
   */
  public void setParamValue1(String _paramValue1) {
    this.paramValue1 = _paramValue1;
  }

  /**
   * T or F as to whether this privilege is being assigned or removed
   * @return is allowed
   */
  public String getAllowed() {</pre></div></td></tr></table>
<table border="0" class="bodyTable">
<tr class="a">
<th>File</th>
<th>Line</th></tr>
<tr class="b">
<td>edu\internet2\middleware\grouperClient\ws\beans\WsRestGetGrouperPrivilegesLiteRequest.java</td>
<td><a href="./xref/edu/internet2/middleware/grouperClient/ws/beans/WsRestGetGrouperPrivilegesLiteRequest.html#L373">373</a></td></tr>
<tr class="a">
<td>edu\internet2\middleware\grouperClient\ws\beans\WsRestGetSubjectsLiteRequest.java</td>
<td><a href="./xref/edu/internet2/middleware/grouperClient/ws/beans/WsRestGetSubjectsLiteRequest.html#L242">242</a></td></tr>
<tr class="b"><td colspan='2'>
<div>
<pre>  }

  /**
   * additional subject attributes (data) to return.
   * If blank, whatever is configured in the grouper-ws.properties will be sent (comma separated)
   * @return names to return
   */
  public String getSubjectAttributeNames() {
    return this.subjectAttributeNames;
  }

  /**
   * additional subject attributes (data) to return.
   * If blank, whatever is configured in the grouper-ws.properties will be sent (comma separated)
   * @param subjectAttributeNames1
   */
  public void setSubjectAttributeNames(String subjectAttributeNames1) {
    this.subjectAttributeNames = subjectAttributeNames1;
  }

  /**
   * T or F as for if group detail should be included
   * @return T of F
   */
  public String getIncludeGroupDetail() {
    return this.includeGroupDetail;
  }

  /**
   * T or F as for if group detail should be included
   * @param includeGroupDetail1
   */
  public void setIncludeGroupDetail(String includeGroupDetail1) {
    this.includeGroupDetail = includeGroupDetail1;
  }

  /**
   * reserved for future use
   * @return param
   */
  public String getParamName0() {
    return this.paramName0;
  }

  /**
   * reserved for future use
   * @param _paramName0
   */
  public void setParamName0(String _paramName0) {
    this.paramName0 = _paramName0;
  }

  /**
   * reserved for future use
   * @return param
   */
  public String getParamValue0() {
    return this.paramValue0;
  }

  /**
   * reserved for future use
   * @param _paramValue0
   */
  public void setParamValue0(String _paramValue0) {
    this.paramValue0 = _paramValue0;
  }

  /**
   * reserved for future use
   * @return param
   */
  public String getParamName1() {
    return this.paramName1;
  }

  /**
   * reserved for future use
   * @param _paramName1
   */
  public void setParamName1(String _paramName1) {
    this.paramName1 = _paramName1;
  }

  /**
   * reserved for future use
   * @return param
   */
  public String getParamValue1() {
    return this.paramValue1;
  }

  /**
   * reserved for future use
   * @param _paramValue1
   */
  public void setParamValue1(String _paramValue1) {
    this.paramValue1 = _paramValue1;
  }</pre></div></td></tr></table>
<table border="0" class="bodyTable">
<tr class="a">
<th>File</th>
<th>Line</th></tr>
<tr class="b">
<td>edu\internet2\middleware\grouperClient\config\ConfigPropertiesCascadeCommonUtils.java</td>
<td><a href="./xref/edu/internet2/middleware/grouperClient/config/ConfigPropertiesCascadeCommonUtils.html#L7653">7653</a></td></tr>
<tr class="a">
<td>edu\internet2\middleware\grouperClient\util\GrouperClientCommonUtils.java</td>
<td><a href="./xref/edu/internet2/middleware/grouperClient/util/GrouperClientCommonUtils.html#L7753">7753</a></td></tr>
<tr class="b"><td colspan='2'>
<div>
<pre>    System.err.println(&quot;Grouper error: &quot; + error);
    return false;
  }

  /**
   * make sure a value is boolean in properties
   * @param resourceName
   * @param properties 
   * @param overrideMap
   * @param key
   * @param required
   * @param exceptionOnError 
   * @return true if ok, false if not
   */
  public static boolean propertyValidateValueBoolean(String resourceName, Properties properties, 
      Map&lt;String, String&gt; overrideMap, String key, 
      boolean required, boolean exceptionOnError) {
    
    if (required &amp;&amp; !propertyValidateValueRequired(resourceName, properties, 
        overrideMap, key, exceptionOnError)) {
      return false;
    }
  
    Map&lt;String, String&gt; threadLocalMap = propertiesThreadLocalOverrideMap(resourceName);

    String value = propertiesValue(properties, threadLocalMap, overrideMap, key);
    //maybe ok not there
    if (!required &amp;&amp; isBlank(value)) {
      return true;
    }
    try {
      booleanValue(value);
      return true;
    } catch (Exception e) {
      
    }
    String error = &quot;Expecting true or false property &quot; + key + &quot; in resource: &quot; + resourceName + &quot;, but is '&quot; + value + &quot;'&quot;;
    if (exceptionOnError) {
      throw new RuntimeException(error);
    }
    System.err.println(&quot;Grouper error: &quot; + error);</pre></div></td></tr></table>
<table border="0" class="bodyTable">
<tr class="a">
<th>File</th>
<th>Line</th></tr>
<tr class="b">
<td>edu\internet2\middleware\grouperClient\config\ConfigPropertiesCascadeCommonUtils.java</td>
<td><a href="./xref/edu/internet2/middleware/grouperClient/config/ConfigPropertiesCascadeCommonUtils.html#L7693">7693</a></td></tr>
<tr class="a">
<td>edu\internet2\middleware\grouperClient\util\GrouperClientCommonUtils.java</td>
<td><a href="./xref/edu/internet2/middleware/grouperClient/util/GrouperClientCommonUtils.html#L7794">7794</a></td></tr>
<tr class="b"><td colspan='2'>
<div>
<pre>    System.err.println(&quot;Grouper error: &quot; + error);
    return false;
  }

  
  /**
   * make sure a value is int in properties
   * @param resourceName
   * @param properties 
   * @param overrideMap
   * @param key
   * @param required
   * @param exceptionOnError 
   * @return true if ok, false if not
   */
  public static boolean propertyValidateValueInt(String resourceName, Properties properties, 
      Map&lt;String, String&gt; overrideMap, String key, 
      boolean required, boolean exceptionOnError) {
    
    if (required &amp;&amp; !propertyValidateValueRequired(resourceName, properties, 
        overrideMap, key, exceptionOnError)) {
      return false;
    }
  
    Map&lt;String, String&gt; threadLocalMap = propertiesThreadLocalOverrideMap(resourceName);
    
    String value = propertiesValue(properties, threadLocalMap, overrideMap, key);
    //maybe ok not there
    if (!required &amp;&amp; isBlank(value)) {
      return true;
    }
    try {
      intValue(value);
      return true;
    } catch (Exception e) {
      
    }
    String error = &quot;Expecting integer property &quot; + key + &quot; in resource: &quot; + resourceName + &quot;, but is '&quot; + value + &quot;'&quot;;
    if (exceptionOnError) {
      throw new RuntimeException(error);
    }
    System.err.println(&quot;Grouper error: &quot; + error);</pre></div></td></tr></table>
<table border="0" class="bodyTable">
<tr class="a">
<th>File</th>
<th>Line</th></tr>
<tr class="b">
<td>edu\internet2\middleware\grouperClient\util\GcElUtilsSafe.java</td>
<td><a href="./xref/edu/internet2/middleware/grouperClient/util/GcElUtilsSafe.html#L489">489</a></td></tr>
<tr class="a">
<td>edu\internet2\middleware\grouperClient\util\GrouperClientCommonUtils.java</td>
<td><a href="./xref/edu/internet2/middleware/grouperClient/util/GrouperClientCommonUtils.html#L479">479</a></td></tr>
<tr class="b"><td colspan='2'>
<div>
<pre>  }

  /**
   * get the prefix or suffix of a string based on a separator
   * 
   * @param startString
   *          is the string to start with
   * @param separator
   *          is the separator to split on
   * @param isPrefix
   *          if thre prefix or suffix should be returned
   * 
   * @return the prefix or suffix, if the separator isnt there, return the
   *         original string
   */
  public static String prefixOrSuffix(String startString, String separator,
      boolean isPrefix) {
    String prefixOrSuffix = null;

    //no nulls
    if (startString == null) {
      return startString;
    }

    //where is the separator
    int separatorIndex = startString.indexOf(separator);

    //if none exists, dont proceed
    if (separatorIndex == -1) {
      return startString;
    }

    //maybe the separator isnt on character
    int separatorLength = separator.length();

    if (isPrefix) {
      prefixOrSuffix = startString.substring(0, separatorIndex);
    } else {
      prefixOrSuffix = startString.substring(separatorIndex + separatorLength,
          startString.length());
    }

    return prefixOrSuffix;
  }

  /**
   * &lt;pre&gt;
   * this method will indent xml or json.
   * this is for logging or documentations purposes only and should
   * not be used for a production use (since it is not 100% tested
   * or compliant with all constructs like xml CDATA
   * 
   * For xml, assumes elements either have text or sub elements, not both.
   * No cdata, nothing fancy.
   * 
   * If the input is &amp;lt;a&amp;gt;&amp;lt;b&amp;gt;&amp;lt;c&amp;gt;hey&amp;lt;/c&amp;gt;&amp;lt;d&amp;gt;&amp;lt;e&amp;gt;there&amp;lt;/e&amp;gt;&amp;lt;/d&amp;gt;&amp;lt;/b&amp;gt;&amp;lt;/a&amp;gt;
   * It would output:
   * &amp;lt;a&amp;gt;
   *   &amp;lt;b&amp;gt;
   *     &amp;lt;c&amp;gt;hey&amp;lt;/c&amp;gt;
   *     &amp;lt;d&amp;gt;
   *       &amp;lt;e&amp;gt;there&amp;lt;/e&amp;gt;
   *     &amp;lt;/d&amp;gt;
   *   &amp;lt;/b&amp;gt;
   * &amp;lt;/a&amp;gt;
   * 
   * For , if the input is: {&quot;a&quot;:{&quot;b\&quot;b&quot;:{&quot;c\\&quot;:&quot;d&quot;},&quot;e&quot;:&quot;f&quot;,&quot;g&quot;:[&quot;h&quot;:&quot;i&quot;]}}
   * It would output:
   * {
   *   &quot;a&quot;:{
   *     &quot;b\&quot;b&quot;:{
   *       &quot;c\\&quot;:&quot;d&quot;
   *     },
   *     &quot;e&quot;:&quot;f&quot;,
   *     &quot;g&quot;:[
   *       &quot;h&quot;:&quot;i&quot;
   *     ]
   *   }
   * }
   * 
   * 
   * &lt;pre&gt;
   * @param string
   * @param failIfTypeNotFound
   * @return the indented string, 2 spaces per line
   */
  public static String indent(String string, boolean failIfTypeNotFound) {
    if (string == null) {
      return null;
    }
    string = trim(string);
    if (string.startsWith(&quot;&lt;&quot;)) {
      //this is xml
      return new XmlIndenter(string).result();
    }
    if (string.startsWith(&quot;{&quot;)) {</pre></div></td></tr></table>
<table border="0" class="bodyTable">
<tr class="a">
<th>File</th>
<th>Line</th></tr>
<tr class="b">
<td>edu\internet2\middleware\grouperClient\GrouperClient.java</td>
<td><a href="./xref/edu/internet2/middleware/grouperClient/GrouperClient.html#L3296">3296</a></td></tr>
<tr class="a">
<td>edu\internet2\middleware\grouperClient\GrouperClient.java</td>
<td><a href="./xref/edu/internet2/middleware/grouperClient/GrouperClient.html#L3783">3783</a></td></tr>
<tr class="b"><td colspan='2'>
<div>
<pre>    GcGetAttributeAssignments gcGetAttributeAssignments = new GcGetAttributeAssignments();        

    for (int i=0;i&lt;10;i++) {
      WsSubjectLookup ownerMembershipAnySubjectLookup = retrieveSuffixSubjectFromArgs(argMap, argMapNotUsed, &quot;ownerMembershipAny&quot; + i, false);
      String ownerMembershipAnyGroupUuid = GrouperClientUtils.argMapString(argMap, argMapNotUsed, &quot;ownerMembershipAny&quot; + i + &quot;GroupUuid&quot;, false);
      String ownerMembershipAnyGroupName = GrouperClientUtils.argMapString(argMap, argMapNotUsed, &quot;ownerMembershipAny&quot; + i + &quot;GroupName&quot;, false);
      String ownerMembershipAnyGroupIdIndex = GrouperClientUtils.argMapString(argMap, argMapNotUsed, &quot;ownerMembershipAny&quot; + i + &quot;GroupIdIndex&quot;, false);
      if (ownerMembershipAnySubjectLookup != null || !GrouperClientUtils.isBlank(ownerMembershipAnyGroupName) 
          || !GrouperClientUtils.isBlank(ownerMembershipAnyGroupUuid) || !GrouperClientUtils.isBlank(ownerMembershipAnyGroupIdIndex)) {
        WsMembershipAnyLookup wsMembershipAnyLookup = new WsMembershipAnyLookup();
        wsMembershipAnyLookup.setWsGroupLookup(new WsGroupLookup(ownerMembershipAnyGroupName, ownerMembershipAnyGroupUuid, ownerMembershipAnyGroupIdIndex));
        wsMembershipAnyLookup.setWsSubjectLookup(ownerMembershipAnySubjectLookup);</pre></div></td></tr></table>
<table border="0" class="bodyTable">
<tr class="a">
<th>File</th>
<th>Line</th></tr>
<tr class="b">
<td>edu\internet2\middleware\grouperClient\config\ConfigPropertiesCascadeCommonUtils.java</td>
<td><a href="./xref/edu/internet2/middleware/grouperClient/config/ConfigPropertiesCascadeCommonUtils.html#L5299">5299</a></td></tr>
<tr class="a">
<td>edu\internet2\middleware\grouperClient\util\GrouperClientCommonUtils.java</td>
<td><a href="./xref/edu/internet2/middleware/grouperClient/util/GrouperClientCommonUtils.html#L5370">5370</a></td></tr>
<tr class="b"><td colspan='2'>
<div>
<pre>        if (callingLog != null) {
          callingLog.append(theLog);
        }
      } catch (Exception e) {
        
        //clear out just in case
        properties.clear();

        //lets look next to jar
        File jarFile = classInJar == null ? null : jarFile(classInJar);
        File parentDir = jarFile == null ? null : jarFile.getParentFile();
        String fileName = parentDir == null ? null 
            : (stripLastSlashIfExists(fileCanonicalPath(parentDir)) + File.separator + resourceName);
        File configFile = fileName == null ? null 
            : new File(fileName);

        try {
          //looks like we have a match
          if (configFile != null &amp;&amp; configFile.exists() &amp;&amp; configFile.isFile()) {
            inputStream = new FileInputStream(configFile);
            properties.load(inputStream);
            success = true;
            String theLog = &quot;Reading resource: &quot; + resourceName + &quot;, from: &quot; + fileCanonicalPath(configFile);
            if (callingLog != null) {</pre></div></td></tr></table>
<table border="0" class="bodyTable">
<tr class="a">
<th>File</th>
<th>Line</th></tr>
<tr class="b">
<td>edu\internet2\middleware\grouperClient\GrouperClient.java</td>
<td><a href="./xref/edu/internet2/middleware/grouperClient/GrouperClient.html#L1811">1811</a></td></tr>
<tr class="a">
<td>edu\internet2\middleware\grouperClient\GrouperClient.java</td>
<td><a href="./xref/edu/internet2/middleware/grouperClient/GrouperClient.html#L1890">1890</a></td></tr>
<tr class="b"><td colspan='2'>
<div>
<pre>    result.setStemNameScope(stemNameScope);

    Boolean ascending = GrouperClientUtils.argMapBoolean(argMap, argMapNotUsed, 
       &quot;ascending&quot; + suffix);
    if (ascending != null) {
      result.setAscending(ascending ? &quot;T&quot; : &quot;F&quot;);
    }
     
    String sortString = GrouperClientUtils.argMapString(argMap, argMapNotUsed, 
        &quot;sortString&quot; + suffix, false);
    result.setSortString(sortString);
    
    Integer pageNumber = GrouperClientUtils.argMapInteger(argMap, argMapNotUsed, 
        &quot;pageNumber&quot; + suffix, false, null);
    if (pageNumber != null) {
      result.setPageNumber(pageNumber.toString());
    }
    
    Integer pageSize = GrouperClientUtils.argMapInteger(argMap, argMapNotUsed, 
        &quot;pageSize&quot; + suffix, false, null);
    if (pageSize != null) {
      result.setPageSize(pageSize.toString());
    }
     
    return result;
  }

    /**
     * retrieve a query filter from the args with suffix (if child group)
     * @param argMap
     * @param argMapNotUsed
     * @param suffix if a child of a previous one
     * @param required
     * @return the query filter
     */
    private static WsStemQueryFilter retrieveStemQueryFilterFromArgs(Map&lt;String, String&gt; argMap,</pre></div></td></tr></table>
<table border="0" class="bodyTable">
<tr class="a">
<th>File</th>
<th>Line</th></tr>
<tr class="b">
<td>edu\internet2\middleware\grouperClient\config\ConfigPropertiesCascadeCommonUtils.java</td>
<td><a href="./xref/edu/internet2/middleware/grouperClient/config/ConfigPropertiesCascadeCommonUtils.html#L8485">8485</a></td></tr>
<tr class="a">
<td>edu\internet2\middleware\grouperClient\util\GcElUtilsSafe.java</td>
<td><a href="./xref/edu/internet2/middleware/grouperClient/util/GcElUtilsSafe.html#L5506">5506</a></td></tr>
<tr class="b">
<td>edu\internet2\middleware\grouperClient\util\GrouperClientCommonUtils.java</td>
<td><a href="./xref/edu/internet2/middleware/grouperClient/util/GrouperClientCommonUtils.html#L8588">8588</a></td></tr>
<tr class="a"><td colspan='2'>
<div>
<pre>  }

  /**
   * Note, this is 
   * web service format string
   */
  private static final String WS_DATE_FORMAT = &quot;yyyy/MM/dd HH:mm:ss.SSS&quot;;

  /**
   * Note, this is 
   * web service format string
   */
  private static final String WS_DATE_FORMAT2 = &quot;yyyy/MM/dd_HH:mm:ss.SSS&quot;;

  /**
   * convert a date to a string using the standard web service pattern
   * yyyy/MM/dd HH:mm:ss.SSS Note that HH is 0-23
   * 
   * @param date
   * @return the string, or null if the date is null
   */
  public static String dateToString(Date date) {
    if (date == null) {
      return null;
    }
    SimpleDateFormat simpleDateFormat = new SimpleDateFormat(WS_DATE_FORMAT);
    return simpleDateFormat.format(date);
  }

  /**
   * convert a string to a date using the standard web service pattern Note
   * that HH is 0-23
   * 
   * @param dateString
   * @return the string, or null if the date was null
   */
  public static Date stringToDate(String dateString) {
    if (isBlank(dateString)) {
      return null;
    }
    SimpleDateFormat simpleDateFormat = new SimpleDateFormat(WS_DATE_FORMAT);
    try {
      return simpleDateFormat.parse(dateString);
    } catch (ParseException e) {
      SimpleDateFormat simpleDateFormat2 = new SimpleDateFormat(WS_DATE_FORMAT2);
      try {
        return simpleDateFormat2.parse(dateString);
      } catch (ParseException e2) {
        throw new RuntimeException(&quot;Cannot convert '&quot; + dateString
            + &quot;' to a date based on format: &quot; + WS_DATE_FORMAT, e);
      }
    }
  }</pre></div></td></tr></table>
<table border="0" class="bodyTable">
<tr class="b">
<th>File</th>
<th>Line</th></tr>
<tr class="a">
<td>edu\internet2\middleware\grouperClient\config\ConfigPropertiesCascadeCommonUtils.java</td>
<td><a href="./xref/edu/internet2/middleware/grouperClient/config/ConfigPropertiesCascadeCommonUtils.html#L8886">8886</a></td></tr>
<tr class="b">
<td>edu\internet2\middleware\grouperClient\util\GrouperClientCommonUtils.java</td>
<td><a href="./xref/edu/internet2/middleware/grouperClient/util/GrouperClientCommonUtils.html#L8994">8994</a></td></tr>
<tr class="a"><td colspan='2'>
<div>
<pre>    StreamGobbler&lt;Object&gt; outputGobbler = null;
    StreamGobbler&lt;Object&gt; errorGobbler = null;
    try {
      process = Runtime.getRuntime().exec(arguments);

      outputGobbler = new StreamGobbler&lt;Object&gt;(process.getInputStream(), &quot;.out&quot;, command);
      errorGobbler = new StreamGobbler&lt;Object&gt;(process.getErrorStream(), &quot;.err&quot;, command);

      Future&lt;Object&gt; futureOutput = retrieveExecutorService().submit(outputGobbler);
      Future&lt;Object&gt; futureError = retrieveExecutorService().submit(errorGobbler);
      
      try {
        process.waitFor();
      } finally {
        
        //finish running these threads
        try {
          futureOutput.get();
        } finally {
          //ignore if cant get
        }
        try {
          futureError.get();
        } finally {
          //ignore if cant get
        }
      }
    } catch (Exception e) {</pre></div></td></tr></table>
<table border="0" class="bodyTable">
<tr class="b">
<th>File</th>
<th>Line</th></tr>
<tr class="a">
<td>edu\internet2\middleware\grouperClient\ws\beans\WsRestAssignAttributesBatchRequest.java</td>
<td><a href="./xref/edu/internet2/middleware/grouperClient/ws/beans/WsRestAssignAttributesBatchRequest.html#L97">97</a></td></tr>
<tr class="b">
<td>edu\internet2\middleware\grouperClient\ws\beans\WsRestAssignAttributesRequest.java</td>
<td><a href="./xref/edu/internet2/middleware/grouperClient/ws/beans/WsRestAssignAttributesRequest.html#L426">426</a></td></tr>
<tr class="a">
<td>edu\internet2\middleware\grouperClient\ws\beans\WsRestAssignPermissionsRequest.java</td>
<td><a href="./xref/edu/internet2/middleware/grouperClient/ws/beans/WsRestAssignPermissionsRequest.html#L275">275</a></td></tr>
<tr class="b">
<td>edu\internet2\middleware\grouperClient\ws\beans\WsRestGetAttributeAssignmentsRequest.java</td>
<td><a href="./xref/edu/internet2/middleware/grouperClient/ws/beans/WsRestGetAttributeAssignmentsRequest.html#L386">386</a></td></tr>
<tr class="a">
<td>edu\internet2\middleware\grouperClient\ws\beans\WsRestGetPermissionAssignmentsRequest.java</td>
<td><a href="./xref/edu/internet2/middleware/grouperClient/ws/beans/WsRestGetPermissionAssignmentsRequest.html#L354">354</a></td></tr>
<tr class="b"><td colspan='2'>
<div>
<pre>  }

  /** if acting as someone else */
  private WsSubjectLookup actAsSubjectLookup;
  
  /**
   * if acting as someone else
   * @return act as subject
   */
  public WsSubjectLookup getActAsSubjectLookup() {
    return this.actAsSubjectLookup;
  }

  /**
   * if acting as someone else
   * @param actAsSubjectLookup1
   */
  public void setActAsSubjectLookup(WsSubjectLookup actAsSubjectLookup1) {
    this.actAsSubjectLookup = actAsSubjectLookup1;
  }

  /**
   * T|F, for if the extended subject information should be
   * returned (anything more than just the id)
   */
  private String includeSubjectDetail;
  
  /**
   * T|F, for if the extended subject information should be
   * returned (anything more than just the id)
   * @return T|F
   */
  public String getIncludeSubjectDetail() {
    return this.includeSubjectDetail;
  }
  
  /**
   * T|F, for if the extended subject information should be
   * returned (anything more than just the id)
   * @param includeSubjectDetail1
   */
  public void setIncludeSubjectDetail(String includeSubjectDetail1) {
    this.includeSubjectDetail = includeSubjectDetail1;
  }

  /** are the additional subject attributes (data) to return. 
   * If blank, whatever is configured in the grouper-ws.properties will be sent
   */
  private String[] subjectAttributeNames;

  
  
  /**
   * are the additional subject attributes (data) to return.
   * If blank, whatever is configured in the grouper-ws.properties will be sent
   * @return subject attribute names
   */
  public String[] getSubjectAttributeNames() {
    return this.subjectAttributeNames;
  }

  /**
   * are the additional subject attributes (data) to return.
   * If blank, whatever is configured in the grouper-ws.properties will be sent
   * @param subjectAttributeNames1
   */
  public void setSubjectAttributeNames(String[] subjectAttributeNames1) {
    this.subjectAttributeNames = subjectAttributeNames1;
  }

  /** T or F as to if the group detail should be returned */
  private String includeGroupDetail;
  
  
  
  /**
   * T or F as to if the group detail should be returned
   * @return T|F
   */
  public String getIncludeGroupDetail() {
    return this.includeGroupDetail;
  }

  /**
   * T or F as to if the group detail should be returned
   * @param includeGroupDetail1
   */
  public void setIncludeGroupDetail(String includeGroupDetail1) {
    this.includeGroupDetail = includeGroupDetail1;
  }

  /** optional: reserved for future use */
  private  WsParam[] params;</pre></div></td></tr></table>
<table border="0" class="bodyTable">
<tr class="a">
<th>File</th>
<th>Line</th></tr>
<tr class="b">
<td>edu\internet2\middleware\grouperClient\config\ConfigPropertiesCascadeCommonUtils.java</td>
<td><a href="./xref/edu/internet2/middleware/grouperClient/config/ConfigPropertiesCascadeCommonUtils.html#L7029">7029</a></td></tr>
<tr class="a">
<td>edu\internet2\middleware\grouperClient\util\GcElUtilsSafe.java</td>
<td><a href="./xref/edu/internet2/middleware/grouperClient/util/GcElUtilsSafe.html#L5937">5937</a></td></tr>
<tr class="b">
<td>edu\internet2\middleware\grouperClient\util\GrouperClientCommonUtils.java</td>
<td><a href="./xref/edu/internet2/middleware/grouperClient/util/GrouperClientCommonUtils.html#L7106">7106</a></td></tr>
<tr class="a"><td colspan='2'>
<div>
<pre>  }

  /**
   * &lt;p&gt;Introspects the &lt;code&gt;Throwable&lt;/code&gt; to obtain the cause.&lt;/p&gt;
   * 
   * &lt;ol&gt;
   * &lt;li&gt;Try known exception types.&lt;/li&gt;
   * &lt;li&gt;Try the supplied array of method names.&lt;/li&gt;
   * &lt;li&gt;Try the field 'detail'.&lt;/li&gt;
   * &lt;/ol&gt;
   * 
   * &lt;p&gt;A &lt;code&gt;null&lt;/code&gt; set of method names means use the default set.
   * A &lt;code&gt;null&lt;/code&gt; in the set of method names will be ignored.&lt;/p&gt;
   *
   * @param throwable  the throwable to introspect for a cause, may be null
   * @param methodNames  the method names, null treated as default set
   * @return the cause of the &lt;code&gt;Throwable&lt;/code&gt;,
   *  &lt;code&gt;null&lt;/code&gt; if none found or null throwable input
   * @since 1.0
   */
  public static Throwable getCause(Throwable throwable, String[] methodNames) {
      if (throwable == null) {
          return null;
      }
      Throwable cause = getCauseUsingWellKnownTypes(throwable);
      if (cause == null) {
          if (methodNames == null) {
              methodNames = CAUSE_METHOD_NAMES;
          }
          for (int i = 0; i &lt; methodNames.length; i++) {
              String methodName = methodNames[i];
              if (methodName != null) {
                  cause = getCauseUsingMethodName(throwable, methodName);
                  if (cause != null) {
                      break;
                  }
              }
          }

          if (cause == null) {
              cause = getCauseUsingFieldName(throwable, &quot;detail&quot;);
          }
      }
      return cause;
  }

  /**
   * &lt;p&gt;Finds a &lt;code&gt;Throwable&lt;/code&gt; by method name.&lt;/p&gt;
   * 
   * @param throwable  the exception to examine
   * @param methodName  the name of the method to find and invoke
   * @return the wrapped exception, or &lt;code&gt;null&lt;/code&gt; if not found
   */
  private static Throwable getCauseUsingMethodName(Throwable throwable, String methodName) {</pre></div></td></tr></table>
<table border="0" class="bodyTable">
<tr class="b">
<th>File</th>
<th>Line</th></tr>
<tr class="a">
<td>edu\internet2\middleware\grouperClient\ws\beans\WsRestAssignAttributeDefNameInheritanceRequest.java</td>
<td><a href="./xref/edu/internet2/middleware/grouperClient/ws/beans/WsRestAssignAttributeDefNameInheritanceRequest.html#L111">111</a></td></tr>
<tr class="b">
<td>edu\internet2\middleware\grouperClient\ws\beans\WsRestAttributeDefNameDeleteRequest.java</td>
<td><a href="./xref/edu/internet2/middleware/grouperClient/ws/beans/WsRestAttributeDefNameDeleteRequest.html#L47">47</a></td></tr>
<tr class="a">
<td>edu\internet2\middleware\grouperClient\ws\beans\WsRestAttributeDefNameSaveRequest.java</td>
<td><a href="./xref/edu/internet2/middleware/grouperClient/ws/beans/WsRestAttributeDefNameSaveRequest.html#L48">48</a></td></tr>
<tr class="b"><td colspan='2'>
<div>
<pre>  }

  /**
   * is the GrouperTransactionType for the request.  If blank, defaults to
   * NONE (will finish as much as possible).  Generally the only values for this param that make sense
   * are NONE (or blank), and READ_WRITE_NEW.
   * @return txType
   */
  public String getTxType() {
    return this.txType;
  }

  /**
   * is the GrouperTransactionType for the request.  If blank, defaults to
   * NONE (will finish as much as possible).  Generally the only values for this param that make sense
   * are NONE (or blank), and READ_WRITE_NEW.
   * @param txType1
   */
  public void setTxType(String txType1) {
    this.txType = txType1;
  }

  /**
   * is the GrouperTransactionType for the request.  If blank, defaults to
   * NONE (will finish as much as possible).  Generally the only values for this param that make sense
   * are NONE (or blank), and READ_WRITE_NEW.
   */
  private String txType;
  
  
  /** is the version of the client.  Must be in GrouperWsVersion, e.g. v1_3_000 */
  private String clientVersion;
  
  /**
   * is the version of the client.  Must be in GrouperWsVersion, e.g. v1_3_000
   * @return version
   */
  public String getClientVersion() {
    return this.clientVersion;
  }

  /**
   * is the version of the client.  Must be in GrouperWsVersion, e.g. v1_3_000
   * @param clientVersion1
   */
  public void setClientVersion(String clientVersion1) {
    this.clientVersion = clientVersion1;
  }

  /** if acting as someone else */
  private WsSubjectLookup actAsSubjectLookup;
  
  /**
   * if acting as someone else
   * @return act as subject
   */
  public WsSubjectLookup getActAsSubjectLookup() {
    return this.actAsSubjectLookup;
  }

  /**
   * if acting as someone else
   * @param actAsSubjectLookup1
   */
  public void setActAsSubjectLookup(WsSubjectLookup actAsSubjectLookup1) {
    this.actAsSubjectLookup = actAsSubjectLookup1;
  }

  /** optional: reserved for future use */
  private  WsParam[] params;

  
  
  /**
   * optional: reserved for future use
   * @return params
   */
  public WsParam[] getParams() {
    return this.params;
  }

  /**
   * optional: reserved for future use
   * @param params1
   */
  public void setParams(WsParam[] params1) {
    this.params = params1;
  }

  


}</pre></div></td></tr></table>
<table border="0" class="bodyTable">
<tr class="a">
<th>File</th>
<th>Line</th></tr>
<tr class="b">
<td>edu\internet2\middleware\grouperClient\config\ConfigPropertiesCascadeCommonUtils.java</td>
<td><a href="./xref/edu/internet2/middleware/grouperClient/config/ConfigPropertiesCascadeCommonUtils.html#L611">611</a></td></tr>
<tr class="a">
<td>edu\internet2\middleware\grouperClient\util\GcElUtilsSafe.java</td>
<td><a href="./xref/edu/internet2/middleware/grouperClient/util/GcElUtilsSafe.html#L644">644</a></td></tr>
<tr class="b">
<td>edu\internet2\middleware\grouperClient\util\GrouperClientCommonUtils.java</td>
<td><a href="./xref/edu/internet2/middleware/grouperClient/util/GrouperClientCommonUtils.html#L674">674</a></td></tr>
<tr class="a"><td colspan='2'>
<div>
<pre>    }
    String parentStemName = name.substring(0,lastColonIndex);
    return parentStemName;

  }
  
  /**
   * return the string or the other if the first is blank
   * @param string
   * @param defaultStringIfBlank
   * @return the string or the default one
   */
  public static String defaultIfBlank(String string, String defaultStringIfBlank) {
    return isBlank(string) ? defaultStringIfBlank : string;
  }
  
  /**
   * genericized method to see if first is null, if so then return second, else first.
   * @param &lt;T&gt;
   * @param theValue first input
   * @param defaultIfTheValueIsNull second input
   * @return the first if not null, second if no
   */
  public static &lt;T&gt; T defaultIfNull(T theValue, T defaultIfTheValueIsNull) {
    return theValue != null ? theValue : defaultIfTheValueIsNull;
  }
  
  /**
   * add each element of listToAdd if it is not already in list
   * @param &lt;T&gt;
   * @param list to add to
   * @param listToAdd each element will be added to list, or null if none
   */
  public static &lt;T&gt; void addIfNotThere(Collection&lt;T&gt; list, Collection&lt;T&gt; listToAdd) {
    //maybe nothing to do
    if (listToAdd == null) {
      return;
    }
    for (T t : listToAdd) {
      if (!list.contains(t)) {
        list.add(t);
      }
    }
  }</pre></div></td></tr></table>
<table border="0" class="bodyTable">
<tr class="b">
<th>File</th>
<th>Line</th></tr>
<tr class="a">
<td>edu\internet2\middleware\grouperClient\ws\beans\WsRestGroupDeleteRequest.java</td>
<td><a href="./xref/edu/internet2/middleware/grouperClient/ws/beans/WsRestGroupDeleteRequest.html#L34">34</a></td></tr>
<tr class="b">
<td>edu\internet2\middleware\grouperClient\ws\beans\WsRestStemSaveRequest.java</td>
<td><a href="./xref/edu/internet2/middleware/grouperClient/ws/beans/WsRestStemSaveRequest.html#L31">31</a></td></tr>
<tr class="a"><td colspan='2'>
<div>
<pre>  private String txType;
  
  /** field */
  private String clientVersion;
  
  /** field */
  private WsSubjectLookup actAsSubjectLookup;
  
  /** field */
  private WsParam[] params;
  
  /**
   * @return the clientVersion
   */
  public String getClientVersion() {
    return this.clientVersion;
  }

  
  /**
   * @param clientVersion1 the clientVersion to set
   */
  public void setClientVersion(String clientVersion1) {
    this.clientVersion = clientVersion1;
  }

  
  /**
   * @return the actAsSubjectLookup
   */
  public WsSubjectLookup getActAsSubjectLookup() {
    return this.actAsSubjectLookup;
  }

  
  /**
   * @param actAsSubjectLookup1 the actAsSubjectLookup to set
   */
  public void setActAsSubjectLookup(WsSubjectLookup actAsSubjectLookup1) {
    this.actAsSubjectLookup = actAsSubjectLookup1;
  }

  
  /**
   * @return the params
   */
  public WsParam[] getParams() {
    return this.params;
  }


  
  /**
   * @param params1 the params to set
   */
  public void setParams(WsParam[] params1) {
    this.params = params1;
  }

  /**
   * field
   * @return the txType
   */
  public String getTxType() {
    return this.txType;
  }


  
  /**
   * field
   * @param txType1 the txType to set
   */
  public void setTxType(String txType1) {
    this.txType = txType1;
  }


  
  /**
   * field
   * @return the wsGroupLookups
   */
  public WsGroupLookup[] getWsGroupLookups() {</pre></div></td></tr></table>
<table border="0" class="bodyTable">
<tr class="b">
<th>File</th>
<th>Line</th></tr>
<tr class="a">
<td>edu\internet2\middleware\grouperClient\api\GcAssignAttributes.java</td>
<td><a href="./xref/edu/internet2/middleware/grouperClient/api/GcAssignAttributes.html#L440">440</a></td></tr>
<tr class="b">
<td>edu\internet2\middleware\grouperClient\api\GcGetAttributeAssignments.java</td>
<td><a href="./xref/edu/internet2/middleware/grouperClient/api/GcGetAttributeAssignments.html#L631">631</a></td></tr>
<tr class="a"><td colspan='2'>
<div>
<pre>        assignAttributes.setWsOwnerMembershipLookups(GrouperClientUtils.toArray(this.ownerMembershipLookups, WsMembershipLookup.class));
      }
      
      //############# ATTRIBUTE DEFS
      List&lt;WsAttributeDefLookup&gt; ownerAttributeDefLookups = new ArrayList&lt;WsAttributeDefLookup&gt;();
      //add names and/or uuids
      for (String ownerAttributeDefName : this.ownerAttributeDefNames) {
        ownerAttributeDefLookups.add(new WsAttributeDefLookup(ownerAttributeDefName, null));
      }
      for (String ownerAttributeDefUuid : this.ownerAttributeDefUuids) {
        ownerAttributeDefLookups.add(new WsAttributeDefLookup(null, ownerAttributeDefUuid));
      }
      for (Long ownerAttributeDefIdIndex : this.ownerAttributeDefIdIndexes) {
        ownerAttributeDefLookups.add(new WsAttributeDefLookup(null, null, ownerAttributeDefIdIndex.toString()));
      }
      if (GrouperClientUtils.length(ownerAttributeDefLookups) &gt; 0) {</pre></div></td></tr></table>
<table border="0" class="bodyTable">
<tr class="b">
<th>File</th>
<th>Line</th></tr>
<tr class="a">
<td>edu\internet2\middleware\grouperClient\config\ConfigPropertiesCascadeCommonUtils.java</td>
<td><a href="./xref/edu/internet2/middleware/grouperClient/config/ConfigPropertiesCascadeCommonUtils.html#L8833">8833</a></td></tr>
<tr class="b">
<td>edu\internet2\middleware\grouperClient\util\GrouperClientCommonUtils.java</td>
<td><a href="./xref/edu/internet2/middleware/grouperClient/util/GrouperClientCommonUtils.html#L8938">8938</a></td></tr>
<tr class="a"><td colspan='2'>
<div>
<pre>        throw new RuntimeException(e);

      }
      return null;
    }
  }
  
  /**
   * &lt;pre&gt;This will execute a command (with args). In this method, 
   * if the exit code of the command is not zero, an exception will be thrown.
   * Example call: execCommand(new String[]{&quot;/bin/bash&quot;, &quot;-c&quot;, &quot;cd /someFolder; runSomeScript.sh&quot;}, true);
   * &lt;/pre&gt;
   * @param arguments are the commands
   * @return the output text of the command.
   */
  public static CommandResult execCommand(String[] arguments) {
    return execCommand(arguments, true);
  }
  
  /**
   * threadpool
   */
  private static ExecutorService executorService = Executors.newCachedThreadPool(new DaemonThreadFactory());


  /**
   * 
   * @return executor service
   */
  public static ExecutorService retrieveExecutorService() {
    return executorService;
  }
  
  /**
   * &lt;pre&gt;This will execute a command (with args). Under normal operation, 
   * if the exit code of the command is not zero, an exception will be thrown.
   * If the parameter exceptionOnExitValueNeZero is set to true, the 
   * results of the call will be returned regardless of the exit status.
   * Example call: execCommand(new String[]{&quot;/bin/bash&quot;, &quot;-c&quot;, &quot;cd /someFolder; runSomeScript.sh&quot;}, true);
   * &lt;/pre&gt;
   * @param arguments are the commands
   * @param exceptionOnExitValueNeZero if this is set to false, the 
   * results of the call will be returned regardless of the exit status
   * @return the output text of the command, and the error and return code if exceptionOnExitValueNeZero is false.
   */
  public static CommandResult execCommand(String[] arguments, boolean exceptionOnExitValueNeZero) {
    Process process = null;

    StringBuilder commandBuilder = new StringBuilder();
    for (int i = 0; i &lt; arguments.length; i++) {
      commandBuilder.append(arguments[i]).append(&quot; &quot;);
    }
    String command = commandBuilder.toString();</pre></div></td></tr></table>
<table border="0" class="bodyTable">
<tr class="b">
<th>File</th>
<th>Line</th></tr>
<tr class="a">
<td>edu\internet2\middleware\grouperClient\config\ConfigPropertiesCascadeCommonUtils.java</td>
<td><a href="./xref/edu/internet2/middleware/grouperClient/config/ConfigPropertiesCascadeCommonUtils.html#L7073">7073</a></td></tr>
<tr class="b">
<td>edu\internet2\middleware\grouperClient\util\GcElUtilsSafe.java</td>
<td><a href="./xref/edu/internet2/middleware/grouperClient/util/GcElUtilsSafe.html#L6006">6006</a></td></tr>
<tr class="a">
<td>edu\internet2\middleware\grouperClient\util\GrouperClientCommonUtils.java</td>
<td><a href="./xref/edu/internet2/middleware/grouperClient/util/GrouperClientCommonUtils.html#L7150">7150</a></td></tr>
<tr class="b"><td colspan='2'>
<div>
<pre>  }

  /**
   * &lt;p&gt;Finds a &lt;code&gt;Throwable&lt;/code&gt; by method name.&lt;/p&gt;
   * 
   * @param throwable  the exception to examine
   * @param methodName  the name of the method to find and invoke
   * @return the wrapped exception, or &lt;code&gt;null&lt;/code&gt; if not found
   */
  private static Throwable getCauseUsingMethodName(Throwable throwable, String methodName) {
      Method method = null;
      try {
          method = throwable.getClass().getMethod(methodName, (Class[])null);
      } catch (NoSuchMethodException ignored) {
      } catch (SecurityException ignored) {
      }

      if (method != null &amp;&amp; Throwable.class.isAssignableFrom(method.getReturnType())) {
          try {
              return (Throwable) method.invoke(throwable, EMPTY_OBJECT_ARRAY);
          } catch (IllegalAccessException ignored) {
          } catch (IllegalArgumentException ignored) {
          } catch (InvocationTargetException ignored) {
          }
      }
      return null;
  }

  /**
   * &lt;p&gt;Finds a &lt;code&gt;Throwable&lt;/code&gt; by field name.&lt;/p&gt;
   * 
   * @param throwable  the exception to examine
   * @param fieldName  the name of the attribute to examine
   * @return the wrapped exception, or &lt;code&gt;null&lt;/code&gt; if not found
   */
  private static Throwable getCauseUsingFieldName(Throwable throwable, String fieldName) {</pre></div></td></tr></table>
<table border="0" class="bodyTable">
<tr class="a">
<th>File</th>
<th>Line</th></tr>
<tr class="b">
<td>edu\internet2\middleware\grouperClient\api\GcAssignAttributes.java</td>
<td><a href="./xref/edu/internet2/middleware/grouperClient/api/GcAssignAttributes.html#L409">409</a></td></tr>
<tr class="a">
<td>edu\internet2\middleware\grouperClient\api\GcGetAttributeAssignments.java</td>
<td><a href="./xref/edu/internet2/middleware/grouperClient/api/GcGetAttributeAssignments.html#L600">600</a></td></tr>
<tr class="b"><td colspan='2'>
<div>
<pre>        assignAttributes.setWsOwnerGroupLookups(GrouperClientUtils.toArray(ownerGroupLookups, WsGroupLookup.class));
      }

      //############# STEMS
      List&lt;WsStemLookup&gt; ownerStemLookups = new ArrayList&lt;WsStemLookup&gt;();
      //add names and/or uuids
      for (String ownerStemName : this.ownerStemNames) {
        ownerStemLookups.add(new WsStemLookup(ownerStemName, null));
      }
      for (String ownerStemUuid : this.ownerStemUuids) {
        ownerStemLookups.add(new WsStemLookup(null, ownerStemUuid));
      }
      for (Long ownerStemIdIndex : this.ownerStemIdIndexes) {
        ownerStemLookups.add(new WsStemLookup(null, null, ownerStemIdIndex.toString()));
      }
      if (GrouperClientUtils.length(ownerStemLookups) &gt; 0) {</pre></div></td></tr></table>
<table border="0" class="bodyTable">
<tr class="a">
<th>File</th>
<th>Line</th></tr>
<tr class="b">
<td>edu\internet2\middleware\grouperClient\examples\LdapExample.java</td>
<td><a href="./xref/edu/internet2/middleware/grouperClient/examples/LdapExample.html#L48">48</a></td></tr>
<tr class="a">
<td>edu\internet2\middleware\grouperClient\examples\LdapExample2.java</td>
<td><a href="./xref/edu/internet2/middleware/grouperClient/examples/LdapExample2.html#L41">41</a></td></tr>
<tr class="b"><td colspan='2'>
<div>
<pre>public class LdapExample {

  /**
   * 
   * @param url e.g. ldaps://penngroups.upenn.edu/dc=upenn,dc=edu
   * @param user
   * @param pass
   * @return the context
   * @throws NamingException 
   */
  @SuppressWarnings(&quot;unchecked&quot;)
  public static DirContext context(String url, String user, String pass) throws NamingException {
    // Set up the environment for creating the initial context
    Hashtable env = new Hashtable();
    env.put(Context.INITIAL_CONTEXT_FACTORY, 
        &quot;com.sun.jndi.ldap.LdapCtxFactory&quot;);
    env.put(Context.PROVIDER_URL, url);

    env.put(Context.SECURITY_AUTHENTICATION, &quot;simple&quot;);
    env.put(Context.SECURITY_PRINCIPAL, &quot;uid=&quot; + user + &quot;,ou=entities,dc=upenn,dc=edu&quot;);
    env.put(Context.SECURITY_CREDENTIALS, pass);

    // Create the initial context
    DirContext context = new InitialDirContext(env);
    return context;
  }
  
  /**
   * @param args
   * @throws Exception 
   */
  @SuppressWarnings(&quot;unchecked&quot;)
  public static void main(String[] args) throws Exception {</pre></div></td></tr></table>
<table border="0" class="bodyTable">
<tr class="a">
<th>File</th>
<th>Line</th></tr>
<tr class="b">
<td>edu\internet2\middleware\grouperClient\ws\beans\WsRestGetGroupsRequest.java</td>
<td><a href="./xref/edu/internet2/middleware/grouperClient/ws/beans/WsRestGetGroupsRequest.html#L319">319</a></td></tr>
<tr class="a">
<td>edu\internet2\middleware\grouperClient\ws\beans\WsRestGetSubjectsRequest.java</td>
<td><a href="./xref/edu/internet2/middleware/grouperClient/ws/beans/WsRestGetSubjectsRequest.html#L187">187</a></td></tr>
<tr class="b"><td colspan='2'>
<div>
<pre>    this.memberFilter = fieldName1;
  }

  
  /**
   * @return the includeGroupDetail
   */
  public String getIncludeGroupDetail() {
    return this.includeGroupDetail;
  }

  
  /**
   * @param includeGroupDetail1 the includeGroupDetail to set
   */
  public void setIncludeGroupDetail(String includeGroupDetail1) {
    this.includeGroupDetail = includeGroupDetail1;
  }

  
  /**
   * @return the includeSubjectDetail
   */
  public String getIncludeSubjectDetail() {
    return this.includeSubjectDetail;
  }

  
  /**
   * @param includeSubjectDetail1 the includeSubjectDetail to set
   */
  public void setIncludeSubjectDetail(String includeSubjectDetail1) {
    this.includeSubjectDetail = includeSubjectDetail1;
  }

  
  /**
   * @return the subjectAttributeNames
   */
  public String[] getSubjectAttributeNames() {
    return this.subjectAttributeNames;
  }

  
  /**
   * @param subjectAttributeNames1 the subjectAttributeNames to set
   */
  public void setSubjectAttributeNames(String[] subjectAttributeNames1) {
    this.subjectAttributeNames = subjectAttributeNames1;
  }


  
  /**
   * @return the params
   */
  public WsParam[] getParams() {
    return this.params;
  }


  
  /**
   * @param params1 the params to set
   */
  public void setParams(WsParam[] params1) {
    this.params = params1;
  }

  /**
   * To query members at a certain point in time or time range in the past, set this value
   * and/or the value of pointInTimeTo.  This parameter specifies the start of the range
   * of the point in time query.  If this is specified but pointInTimeTo is not specified, 
   * then the point in time query range will be from the time specified to now.  
   * Format:  yyyy/MM/dd HH:mm:ss.SSS
   * @return the pointInTimeFrom
   */
  public String getPointInTimeFrom() {</pre></div></td></tr></table>
<table border="0" class="bodyTable">
<tr class="a">
<th>File</th>
<th>Line</th></tr>
<tr class="b">
<td>edu\internet2\middleware\grouperClient\ws\beans\WsGetGroupsResults.java</td>
<td><a href="./xref/edu/internet2/middleware/grouperClient/ws/beans/WsGetGroupsResults.html#L53">53</a></td></tr>
<tr class="a">
<td>edu\internet2\middleware\grouperClient\ws\beans\WsMemberChangeSubjectResults.java</td>
<td><a href="./xref/edu/internet2/middleware/grouperClient/ws/beans/WsMemberChangeSubjectResults.html#L51">51</a></td></tr>
<tr class="b"><td colspan='2'>
<div>
<pre>  public void setResults(WsGetGroupsResult[] results1) {
    this.results = results1;
  }

  /**
   * metadata about the result
   */
  private WsResultMeta resultMetadata = new WsResultMeta();

  /**
   * attributes of subjects returned, in same order as the data
   */
  private String[] subjectAttributeNames;

  /**
   * @return the resultMetadata
   */
  public WsResultMeta getResultMetadata() {
    return this.resultMetadata;
  }

  /**
   * attributes of subjects returned, in same order as the data
   * @return the attributeNames
   */
  public String[] getSubjectAttributeNames() {
    return this.subjectAttributeNames;
  }

  /**
   * attributes of subjects returned, in same order as the data
   * @param attributeNamesa the attributeNames to set
   */
  public void setSubjectAttributeNames(String[] attributeNamesa) {
    this.subjectAttributeNames = attributeNamesa;
  }

  /**
   * metadata about the result
   */
  private WsResponseMeta responseMetadata = new WsResponseMeta();

  /**
   * @see edu.internet2.middleware.grouper.ws.rest.WsResponseBean#getResponseMetadata()
   * @return the response metadata
   */
  public WsResponseMeta getResponseMetadata() {
    return this.responseMetadata;
  }

  
  /**
   * @param resultMetadata1 the resultMetadata to set
   */
  public void setResultMetadata(WsResultMeta resultMetadata1) {
    this.resultMetadata = resultMetadata1;
  }

  
  /**
   * @param responseMetadata1 the responseMetadata to set
   */
  public void setResponseMetadata(WsResponseMeta responseMetadata1) {
    this.responseMetadata = responseMetadata1;
  }

}</pre></div></td></tr></table>
<table border="0" class="bodyTable">
<tr class="a">
<th>File</th>
<th>Line</th></tr>
<tr class="b">
<td>edu\internet2\middleware\grouperClient\ws\beans\WsRestAddMemberRequest.java</td>
<td><a href="./xref/edu/internet2/middleware/grouperClient/ws/beans/WsRestAddMemberRequest.html#L218">218</a></td></tr>
<tr class="a">
<td>edu\internet2\middleware\grouperClient\ws\beans\WsRestGetGroupsRequest.java</td>
<td><a href="./xref/edu/internet2/middleware/grouperClient/ws/beans/WsRestGetGroupsRequest.html#L320">320</a></td></tr>
<tr class="b">
<td>edu\internet2\middleware\grouperClient\ws\beans\WsRestGetMembersRequest.java</td>
<td><a href="./xref/edu/internet2/middleware/grouperClient/ws/beans/WsRestGetMembersRequest.html#L266">266</a></td></tr>
<tr class="a">
<td>edu\internet2\middleware\grouperClient\ws\beans\WsRestGetSubjectsRequest.java</td>
<td><a href="./xref/edu/internet2/middleware/grouperClient/ws/beans/WsRestGetSubjectsRequest.html#L188">188</a></td></tr>
<tr class="b">
<td>edu\internet2\middleware\grouperClient\ws\beans\WsRestHasMemberRequest.java</td>
<td><a href="./xref/edu/internet2/middleware/grouperClient/ws/beans/WsRestHasMemberRequest.html#L170">170</a></td></tr>
<tr class="a"><td colspan='2'>
<div>
<pre>  }

  
  /**
   * @return the includeGroupDetail
   */
  public String getIncludeGroupDetail() {
    return this.includeGroupDetail;
  }

  
  /**
   * who to act as if not the connecting user
   * @param includeGroupDetail1 the includeGroupDetail to set
   */
  public void setIncludeGroupDetail(String includeGroupDetail1) {
    this.includeGroupDetail = includeGroupDetail1;
  }

  
  /**
   * @return the includeSubjectDetail
   */
  public String getIncludeSubjectDetail() {
    return this.includeSubjectDetail;
  }

  
  /**
   * @param includeSubjectDetail1 the includeSubjectDetail to set
   */
  public void setIncludeSubjectDetail(String includeSubjectDetail1) {
    this.includeSubjectDetail = includeSubjectDetail1;
  }

  
  /**
   * @return the subjectAttributeNames
   */
  public String[] getSubjectAttributeNames() {
    return this.subjectAttributeNames;
  }

  
  /**
   * @param subjectAttributeNames1 the subjectAttributeNames to set
   */
  public void setSubjectAttributeNames(String[] subjectAttributeNames1) {
    this.subjectAttributeNames = subjectAttributeNames1;
  }


  
  /**
   * @return the params
   */
  public WsParam[] getParams() {
    return this.params;
  }


  
  /**
   * @param params1 the params to set
   */
  public void setParams(WsParam[] params1) {
    this.params = params1;
  }


  /**
   * T or F, if this is a search by identifier, with no source, or the external source,
   * and the subject is not found, then add an external subject (if the user is allowed
   * @return T or F or blank
   */
  public String getAddExternalSubjectIfNotFound() {</pre></div></td></tr></table>
<table border="0" class="bodyTable">
<tr class="b">
<th>File</th>
<th>Line</th></tr>
<tr class="a">
<td>edu\internet2\middleware\grouperClient\ws\beans\WsRestGetGroupsRequest.java</td>
<td><a href="./xref/edu/internet2/middleware/grouperClient/ws/beans/WsRestGetGroupsRequest.html#L319">319</a></td></tr>
<tr class="b">
<td>edu\internet2\middleware\grouperClient\ws\beans\WsRestGetMembershipsRequest.java</td>
<td><a href="./xref/edu/internet2/middleware/grouperClient/ws/beans/WsRestGetMembershipsRequest.html#L386">386</a></td></tr>
<tr class="a"><td colspan='2'>
<div>
<pre>    this.memberFilter = fieldName1;
  }

  
  /**
   * @return the includeGroupDetail
   */
  public String getIncludeGroupDetail() {
    return this.includeGroupDetail;
  }

  
  /**
   * @param includeGroupDetail1 the includeGroupDetail to set
   */
  public void setIncludeGroupDetail(String includeGroupDetail1) {
    this.includeGroupDetail = includeGroupDetail1;
  }

  
  /**
   * @return the includeSubjectDetail
   */
  public String getIncludeSubjectDetail() {
    return this.includeSubjectDetail;
  }

  
  /**
   * @param includeSubjectDetail1 the includeSubjectDetail to set
   */
  public void setIncludeSubjectDetail(String includeSubjectDetail1) {
    this.includeSubjectDetail = includeSubjectDetail1;
  }

  
  /**
   * @return the subjectAttributeNames
   */
  public String[] getSubjectAttributeNames() {
    return this.subjectAttributeNames;
  }

  
  /**
   * @param subjectAttributeNames1 the subjectAttributeNames to set
   */
  public void setSubjectAttributeNames(String[] subjectAttributeNames1) {
    this.subjectAttributeNames = subjectAttributeNames1;
  }


  
  /**
   * @return the params
   */
  public WsParam[] getParams() {
    return this.params;
  }


  
  /**
   * @param params1 the params to set
   */
  public void setParams(WsParam[] params1) {
    this.params = params1;
  }</pre></div></td></tr></table>
<table border="0" class="bodyTable">
<tr class="b">
<th>File</th>
<th>Line</th></tr>
<tr class="a">
<td>edu\internet2\middleware\grouperClient\ws\beans\WsRestDeleteMemberRequest.java</td>
<td><a href="./xref/edu/internet2/middleware/grouperClient/ws/beans/WsRestDeleteMemberRequest.html#L152">152</a></td></tr>
<tr class="b">
<td>edu\internet2\middleware\grouperClient\ws\beans\WsRestGetMembershipsRequest.java</td>
<td><a href="./xref/edu/internet2/middleware/grouperClient/ws/beans/WsRestGetMembershipsRequest.html#L387">387</a></td></tr>
<tr class="a"><td colspan='2'>
<div>
<pre>  }

  
  /**
   * @return the includeGroupDetail
   */
  public String getIncludeGroupDetail() {
    return this.includeGroupDetail;
  }

  
  /**
   * @param includeGroupDetail1 the includeGroupDetail to set
   */
  public void setIncludeGroupDetail(String includeGroupDetail1) {
    this.includeGroupDetail = includeGroupDetail1;
  }

  
  /**
   * @return the includeSubjectDetail
   */
  public String getIncludeSubjectDetail() {
    return this.includeSubjectDetail;
  }

  
  /**
   * @param includeSubjectDetail1 the includeSubjectDetail to set
   */
  public void setIncludeSubjectDetail(String includeSubjectDetail1) {
    this.includeSubjectDetail = includeSubjectDetail1;
  }

  
  /**
   * @return the subjectAttributeNames
   */
  public String[] getSubjectAttributeNames() {
    return this.subjectAttributeNames;
  }

  
  /**
   * @param subjectAttributeNames1 the subjectAttributeNames to set
   */
  public void setSubjectAttributeNames(String[] subjectAttributeNames1) {
    this.subjectAttributeNames = subjectAttributeNames1;
  }


  
  /**
   * @return the params
   */
  public WsParam[] getParams() {
    return this.params;
  }


  
  /**
   * @param params1 the params to set
   */
  public void setParams(WsParam[] params1) {
    this.params = params1;
  }

}</pre></div></td></tr></table>
<table border="0" class="bodyTable">
<tr class="b">
<th>File</th>
<th>Line</th></tr>
<tr class="a">
<td>edu\internet2\middleware\grouperClient\config\ConfigPropertiesCascadeCommonUtils.java</td>
<td><a href="./xref/edu/internet2/middleware/grouperClient/config/ConfigPropertiesCascadeCommonUtils.html#L4588">4588</a></td></tr>
<tr class="b">
<td>edu\internet2\middleware\grouperClient\util\GcElUtilsSafe.java</td>
<td><a href="./xref/edu/internet2/middleware/grouperClient/util/GcElUtilsSafe.html#L3058">3058</a></td></tr>
<tr class="a">
<td>edu\internet2\middleware\grouperClient\util\GrouperClientCommonUtils.java</td>
<td><a href="./xref/edu/internet2/middleware/grouperClient/util/GrouperClientCommonUtils.html#L4651">4651</a></td></tr>
<tr class="b"><td colspan='2'>
<div>
<pre>    }
    
    throw new RuntimeException(&quot;Cannot convert to int: &quot; + className(input));
  }

  /**
   * convert an object to a int
   * @param input
   * @param valueIfNull is if the input is null or empty, return this value
   * @return the number
   */
  public static int intValue(Object input, int valueIfNull) {
    if (input == null || &quot;&quot;.equals(input)) {
      return valueIfNull;
    }
    return intObjectValue(input, false);
  }

  /**
   * get the int value of an object, do not throw an exception if there is an
   * error
   * 
   * @param input
   *          is a number or String
   * 
   * @return the int equivalent
   */
  public static int intValueNoError(Object input) {
    if (input == null || (input instanceof String 
        &amp;&amp; isBlank((String)input))) {
      return NOT_FOUND;
    }
    try {
      return intValue(input);
    } catch (Exception e) {
      //no need to log here
    }
  
    return NOT_FOUND;
  }

  /** special number when a number is not found */
  public static final int NOT_FOUND = -999999999;</pre></div></td></tr></table>
<table border="0" class="bodyTable">
<tr class="a">
<th>File</th>
<th>Line</th></tr>
<tr class="b">
<td>edu\internet2\middleware\grouperClient\ws\beans\WsRestAddMemberRequest.java</td>
<td><a href="./xref/edu/internet2/middleware/grouperClient/ws/beans/WsRestAddMemberRequest.html#L218">218</a></td></tr>
<tr class="a">
<td>edu\internet2\middleware\grouperClient\ws\beans\WsRestGetMembershipsRequest.java</td>
<td><a href="./xref/edu/internet2/middleware/grouperClient/ws/beans/WsRestGetMembershipsRequest.html#L387">387</a></td></tr>
<tr class="b"><td colspan='2'>
<div>
<pre>  }

  
  /**
   * @return the includeGroupDetail
   */
  public String getIncludeGroupDetail() {
    return this.includeGroupDetail;
  }

  
  /**
   * who to act as if not the connecting user
   * @param includeGroupDetail1 the includeGroupDetail to set
   */
  public void setIncludeGroupDetail(String includeGroupDetail1) {
    this.includeGroupDetail = includeGroupDetail1;
  }

  
  /**
   * @return the includeSubjectDetail
   */
  public String getIncludeSubjectDetail() {
    return this.includeSubjectDetail;
  }

  
  /**
   * @param includeSubjectDetail1 the includeSubjectDetail to set
   */
  public void setIncludeSubjectDetail(String includeSubjectDetail1) {
    this.includeSubjectDetail = includeSubjectDetail1;
  }

  
  /**
   * @return the subjectAttributeNames
   */
  public String[] getSubjectAttributeNames() {
    return this.subjectAttributeNames;
  }

  
  /**
   * @param subjectAttributeNames1 the subjectAttributeNames to set
   */
  public void setSubjectAttributeNames(String[] subjectAttributeNames1) {
    this.subjectAttributeNames = subjectAttributeNames1;
  }


  
  /**
   * @return the params
   */
  public WsParam[] getParams() {
    return this.params;
  }


  
  /**
   * @param params1 the params to set
   */
  public void setParams(WsParam[] params1) {
    this.params = params1;
  }</pre></div></td></tr></table>
<table border="0" class="bodyTable">
<tr class="a">
<th>File</th>
<th>Line</th></tr>
<tr class="b">
<td>edu\internet2\middleware\grouperClient\ws\beans\WsRestDeleteMemberRequest.java</td>
<td><a href="./xref/edu/internet2/middleware/grouperClient/ws/beans/WsRestDeleteMemberRequest.html#L152">152</a></td></tr>
<tr class="a">
<td>edu\internet2\middleware\grouperClient\ws\beans\WsRestGetGroupsRequest.java</td>
<td><a href="./xref/edu/internet2/middleware/grouperClient/ws/beans/WsRestGetGroupsRequest.html#L320">320</a></td></tr>
<tr class="b">
<td>edu\internet2\middleware\grouperClient\ws\beans\WsRestGetMembersRequest.java</td>
<td><a href="./xref/edu/internet2/middleware/grouperClient/ws/beans/WsRestGetMembersRequest.html#L266">266</a></td></tr>
<tr class="a">
<td>edu\internet2\middleware\grouperClient\ws\beans\WsRestGetSubjectsRequest.java</td>
<td><a href="./xref/edu/internet2/middleware/grouperClient/ws/beans/WsRestGetSubjectsRequest.html#L188">188</a></td></tr>
<tr class="b">
<td>edu\internet2\middleware\grouperClient\ws\beans\WsRestHasMemberRequest.java</td>
<td><a href="./xref/edu/internet2/middleware/grouperClient/ws/beans/WsRestHasMemberRequest.html#L170">170</a></td></tr>
<tr class="a"><td colspan='2'>
<div>
<pre>  }

  
  /**
   * @return the includeGroupDetail
   */
  public String getIncludeGroupDetail() {
    return this.includeGroupDetail;
  }

  
  /**
   * @param includeGroupDetail1 the includeGroupDetail to set
   */
  public void setIncludeGroupDetail(String includeGroupDetail1) {
    this.includeGroupDetail = includeGroupDetail1;
  }

  
  /**
   * @return the includeSubjectDetail
   */
  public String getIncludeSubjectDetail() {
    return this.includeSubjectDetail;
  }

  
  /**
   * @param includeSubjectDetail1 the includeSubjectDetail to set
   */
  public void setIncludeSubjectDetail(String includeSubjectDetail1) {
    this.includeSubjectDetail = includeSubjectDetail1;
  }

  
  /**
   * @return the subjectAttributeNames
   */
  public String[] getSubjectAttributeNames() {
    return this.subjectAttributeNames;
  }

  
  /**
   * @param subjectAttributeNames1 the subjectAttributeNames to set
   */
  public void setSubjectAttributeNames(String[] subjectAttributeNames1) {
    this.subjectAttributeNames = subjectAttributeNames1;
  }


  
  /**
   * @return the params
   */
  public WsParam[] getParams() {
    return this.params;
  }


  
  /**
   * @param params1 the params to set
   */
  public void setParams(WsParam[] params1) {
    this.params = params1;
  }</pre></div></td></tr></table>
<table border="0" class="bodyTable">
<tr class="b">
<th>File</th>
<th>Line</th></tr>
<tr class="a">
<td>edu\internet2\middleware\grouperClient\api\GcAssignAttributes.java</td>
<td><a href="./xref/edu/internet2/middleware/grouperClient/api/GcAssignAttributes.html#L474">474</a></td></tr>
<tr class="b">
<td>edu\internet2\middleware\grouperClient\api\GcAssignPermissions.java</td>
<td><a href="./xref/edu/internet2/middleware/grouperClient/api/GcAssignPermissions.html#L349">349</a></td></tr>
<tr class="a"><td colspan='2'>
<div>
<pre>        assignAttributes.setAttributeDefTypesToReplace(GrouperClientUtils.toArray(this.attributeDefTypesToReplace, String.class));
      }
      List&lt;WsAttributeDefLookup&gt; attributeDefLookupsToReplace = new ArrayList&lt;WsAttributeDefLookup&gt;();
      //add names and/or uuids
      for (String attributeDefNameToReplace : this.attributeDefNamesToReplace) {
        attributeDefLookupsToReplace.add(new WsAttributeDefLookup(attributeDefNameToReplace, null));
      }
      for (String attributeDefUuidToReplace : this.attributeDefUuidsToReplace) {
        attributeDefLookupsToReplace.add(new WsAttributeDefLookup(null, attributeDefUuidToReplace));
      }
      for (Long attributeDefIdIndexToReplace : this.attributeDefIdIndexesToReplace) {
        attributeDefLookupsToReplace.add(new WsAttributeDefLookup(null, null, attributeDefIdIndexToReplace.toString()));
      }
      if (GrouperClientUtils.length(attributeDefLookupsToReplace) &gt; 0) {</pre></div></td></tr></table>
<table border="0" class="bodyTable">
<tr class="b">
<th>File</th>
<th>Line</th></tr>
<tr class="a">
<td>edu\internet2\middleware\grouperClient\api\GcAssignPermissions.java</td>
<td><a href="./xref/edu/internet2/middleware/grouperClient/api/GcAssignPermissions.html#L323">323</a></td></tr>
<tr class="b">
<td>edu\internet2\middleware\grouperClient\api\GcGetPermissionAssignments.java</td>
<td><a href="./xref/edu/internet2/middleware/grouperClient/api/GcGetPermissionAssignments.html#L476">476</a></td></tr>
<tr class="a"><td colspan='2'>
<div>
<pre>        assignPermissions.setPermissionDefNameLookups(GrouperClientUtils.toArray(permissionDefNameLookups, WsAttributeDefNameLookup.class));
      }

      //########### GROUPS
      List&lt;WsGroupLookup&gt; roleLookups = new ArrayList&lt;WsGroupLookup&gt;();
      //add names and/or uuids
      for (String ownerGroupName : this.roleNames) {
        roleLookups.add(new WsGroupLookup(ownerGroupName, null));
      }
      for (String ownerGroupUuid : this.roleUuids) {
        roleLookups.add(new WsGroupLookup(null, ownerGroupUuid));
      }
      for (Long ownerGroupIdIndex : this.roleIdIndexes) {
        roleLookups.add(new WsGroupLookup(null, null, ownerGroupIdIndex.toString()));
      }
      if (GrouperClientUtils.length(roleLookups) &gt; 0) {</pre></div></td></tr></table>
<table border="0" class="bodyTable">
<tr class="b">
<th>File</th>
<th>Line</th></tr>
<tr class="a">
<td>edu\internet2\middleware\grouperClient\ws\beans\WsAssignGrouperPrivilegesLiteResult.java</td>
<td><a href="./xref/edu/internet2/middleware/grouperClient/ws/beans/WsAssignGrouperPrivilegesLiteResult.html#L31">31</a></td></tr>
<tr class="b">
<td>edu\internet2\middleware\grouperClient\ws\beans\WsAssignGrouperPrivilegesResults.java</td>
<td><a href="./xref/edu/internet2/middleware/grouperClient/ws/beans/WsAssignGrouperPrivilegesResults.html#L31">31</a></td></tr>
<tr class="a"><td colspan='2'>
<div>
<pre>  public WsAssignGrouperPrivilegesLiteResult() {
    //empty
  }

  /**
    * metadata about the result
    */
  private WsResultMeta resultMetadata = new WsResultMeta();

  /**
   * attributes of subjects returned, in same order as the data
   */
  private String[] subjectAttributeNames;

  /**
   * @return the resultMetadata
   */
  public WsResultMeta getResultMetadata() {
    return this.resultMetadata;
  }

  /**
   * attributes of subjects returned, in same order as the data
   * @return the attributeNames
   */
  public String[] getSubjectAttributeNames() {
    return this.subjectAttributeNames;
  }

  /**
   * attributes of subjects returned, in same order as the data
   * @param attributeNamesa the attributeNames to set
   */
  public void setSubjectAttributeNames(String[] attributeNamesa) {
    this.subjectAttributeNames = attributeNamesa;
  }

  /**
   * metadata about the result
   */
  private WsResponseMeta responseMetadata = new WsResponseMeta();

  /**
   * @see edu.internet2.middleware.grouper.ws.rest.WsResponseBean#getResponseMetadata()
   * @return the response metadata
   */
  public WsResponseMeta getResponseMetadata() {
    return this.responseMetadata;
  }

  
  /**
   * @param resultMetadata1 the resultMetadata to set
   */
  public void setResultMetadata(WsResultMeta resultMetadata1) {
    this.resultMetadata = resultMetadata1;
  }

  
  /**
   * @param responseMetadata1 the responseMetadata to set
   */
  public void setResponseMetadata(WsResponseMeta responseMetadata1) {
    this.responseMetadata = responseMetadata1;
  }

  /**
   * field 
   */
  private WsParam[] params;</pre></div></td></tr></table>
<table border="0" class="bodyTable">
<tr class="b">
<th>File</th>
<th>Line</th></tr>
<tr class="a">
<td>edu\internet2\middleware\grouperClient\ws\beans\WsRestGroupDeleteRequest.java</td>
<td><a href="./xref/edu/internet2/middleware/grouperClient/ws/beans/WsRestGroupDeleteRequest.html#L48">48</a></td></tr>
<tr class="b">
<td>edu\internet2\middleware\grouperClient\ws\beans\WsRestGroupSaveRequest.java</td>
<td><a href="./xref/edu/internet2/middleware/grouperClient/ws/beans/WsRestGroupSaveRequest.html#L48">48</a></td></tr>
<tr class="a">
<td>edu\internet2\middleware\grouperClient\ws\beans\WsRestStemSaveRequest.java</td>
<td><a href="./xref/edu/internet2/middleware/grouperClient/ws/beans/WsRestStemSaveRequest.html#L45">45</a></td></tr>
<tr class="b"><td colspan='2'>
<div>
<pre>  public String getClientVersion() {
    return this.clientVersion;
  }

  
  /**
   * @param clientVersion1 the clientVersion to set
   */
  public void setClientVersion(String clientVersion1) {
    this.clientVersion = clientVersion1;
  }

  
  /**
   * @return the actAsSubjectLookup
   */
  public WsSubjectLookup getActAsSubjectLookup() {
    return this.actAsSubjectLookup;
  }

  
  /**
   * @param actAsSubjectLookup1 the actAsSubjectLookup to set
   */
  public void setActAsSubjectLookup(WsSubjectLookup actAsSubjectLookup1) {
    this.actAsSubjectLookup = actAsSubjectLookup1;
  }

  
  /**
   * @return the params
   */
  public WsParam[] getParams() {
    return this.params;
  }


  
  /**
   * @param params1 the params to set
   */
  public void setParams(WsParam[] params1) {
    this.params = params1;
  }

  /**
   * field
   * @return the txType
   */
  public String getTxType() {
    return this.txType;
  }


  
  /**
   * field
   * @param txType1 the txType to set
   */
  public void setTxType(String txType1) {
    this.txType = txType1;
  }


  
  /**
   * field
   * @return the wsGroupLookups
   */
  public WsGroupLookup[] getWsGroupLookups() {</pre></div></td></tr></table>
<table border="0" class="bodyTable">
<tr class="a">
<th>File</th>
<th>Line</th></tr>
<tr class="b">
<td>edu\internet2\middleware\grouperClient\config\ConfigPropertiesCascadeCommonUtils.java</td>
<td><a href="./xref/edu/internet2/middleware/grouperClient/config/ConfigPropertiesCascadeCommonUtils.html#L4540">4540</a></td></tr>
<tr class="a">
<td>edu\internet2\middleware\grouperClient\util\GcElUtilsSafe.java</td>
<td><a href="./xref/edu/internet2/middleware/grouperClient/util/GcElUtilsSafe.html#L3018">3018</a></td></tr>
<tr class="b">
<td>edu\internet2\middleware\grouperClient\util\GrouperClientCommonUtils.java</td>
<td><a href="./xref/edu/internet2/middleware/grouperClient/util/GrouperClientCommonUtils.html#L4603">4603</a></td></tr>
<tr class="a"><td colspan='2'>
<div>
<pre>      e.printStackTrace();
    }
  
    return NOT_FOUND;
  }

  /**
   * get the Integer value of an object
   * 
   * @param input
   *          is a number or String
   * @param allowNullBlank true if convert null or blank to null
   * 
   * @return the Integer equivalent
   */
  public static Integer intObjectValue(Object input, boolean allowNullBlank) {
  
    if (input instanceof Integer) {
      return (Integer) input;
    } 
  
    if (allowNullBlank &amp;&amp; isBlank(input)) {
      return null;
    }
    
    return Integer.valueOf(intValue(input));
  }

  /**
   * convert an object to a int
   * @param input
   * @return the number
   */
  public static int intValue(Object input) {
    if (input instanceof String) {
      String string = (String)input;
      return Integer.parseInt(string);
    }
    if (input instanceof Number) {
      return ((Number)input).intValue();
    }</pre></div></td></tr></table>
<table border="0" class="bodyTable">
<tr class="b">
<th>File</th>
<th>Line</th></tr>
<tr class="a">
<td>edu\internet2\middleware\grouperClient\ws\beans\WsRestAssignAttributesRequest.java</td>
<td><a href="./xref/edu/internet2/middleware/grouperClient/ws/beans/WsRestAssignAttributesRequest.html#L35">35</a></td></tr>
<tr class="b">
<td>edu\internet2\middleware\grouperClient\ws\beans\WsRestAssignPermissionsRequest.java</td>
<td><a href="./xref/edu/internet2/middleware/grouperClient/ws/beans/WsRestAssignPermissionsRequest.html#L35">35</a></td></tr>
<tr class="a"><td colspan='2'>
<div>
<pre>  private String assignmentNotes;
  
  
  
  /**
   * notes on the assignment (optional)
   * @return notes
   */
  public String getAssignmentNotes() {
    return this.assignmentNotes;
  }

  /**
   * notes on the assignment (optional)
   * @param assignmentNotes1
   */
  public void setAssignmentNotes(String assignmentNotes1) {
    this.assignmentNotes = assignmentNotes1;
  }

  /**
   * enabled time, or null for enabled now
   * @return enabled time
   */
  public String getAssignmentEnabledTime() {
    return this.assignmentEnabledTime;
  }

  /**
   * enabled time, or null for enabled now
   * @param assignmentEnabledTime1
   */
  public void setAssignmentEnabledTime(String assignmentEnabledTime1) {
    this.assignmentEnabledTime = assignmentEnabledTime1;
  }

  /**
   * disabled time, or null for not disabled
   * @return disabled time
   */
  public String getAssignmentDisabledTime() {
    return this.assignmentDisabledTime;
  }

  /**
   * disabled time, or null for not disabled
   * @param assignmentDisabledTime1
   */
  public void setAssignmentDisabledTime(String assignmentDisabledTime1) {
    this.assignmentDisabledTime = assignmentDisabledTime1;
  }

  /**
   * really only for permissions, if the assignee can delegate to someone else.  TRUE|FALSE|GRANT
   * @return delegatable
   */
  public String getDelegatable() {
    return this.delegatable;
  }

  /**
   * really only for permissions, if the assignee can delegate to someone else.  TRUE|FALSE|GRANT
   * @param delegatable1
   */
  public void setDelegatable(String delegatable1) {
    this.delegatable = delegatable1;
  }</pre></div></td></tr></table>
<table border="0" class="bodyTable">
<tr class="b">
<th>File</th>
<th>Line</th></tr>
<tr class="a">
<td>edu\internet2\middleware\grouperClient\ws\beans\WsRestFindAttributeDefNamesRequest.java</td>
<td><a href="./xref/edu/internet2/middleware/grouperClient/ws/beans/WsRestFindAttributeDefNamesRequest.html#L146">146</a></td></tr>
<tr class="b">
<td>edu\internet2\middleware\grouperClient\ws\beans\WsRestGetGroupsRequest.java</td>
<td><a href="./xref/edu/internet2/middleware/grouperClient/ws/beans/WsRestGetGroupsRequest.html#L184">184</a></td></tr>
<tr class="a"><td colspan='2'>
<div>
<pre>  }

  
  /**
   * page size if paging on a sort filter or parent
   * @return the pageSize
   */
  public String getPageSize() {
    return this.pageSize;
  }

  
  /**
   * page size if paging on a sort filter or parent
   * @param pageSize1 the pageSize to set
   */
  public void setPageSize(String pageSize1) {
    this.pageSize = pageSize1;
  }

  
  /**
   * page number 1 indexed if paging on a sort filter or parent
   * @return the pageNumber
   */
  public String getPageNumber() {
    return this.pageNumber;
  }

  
  /**
   * page number 1 indexed if paging on a sort filter or parent
   * @param pageNumber1 the pageNumber to set
   */
  public void setPageNumber(String pageNumber1) {
    this.pageNumber = pageNumber1;
  }

  
  /**
   * must be an hql query field, e.g. 
   * can sort on name, displayName, extension, displayExtension
   * @return the sortString
   */
  public String getSortString() {
    return this.sortString;
  }

  
  /**
   * must be an hql query field, e.g. 
   * can sort on name, displayName, extension, displayExtension
   * @param sortString1 the sortString to set
   */
  public void setSortString(String sortString1) {
    this.sortString = sortString1;
  }

  
  /**
   * ascending or null for ascending, F for descending.  
   * @return the ascending
   */
  public String getAscending() {
    return this.ascending;
  }

  
  /**
   * ascending or null for ascending, F for descending.  
   * @param ascending1 the ascending to set
   */
  public void setAscending(String ascending1) {
    this.ascending = ascending1;
  }

  
  /**
   * wsInheritanceSetRelation if there is one wsAttributeDefNameLookup, and this is specified, then find 
   * the attribute def names which are related to the lookup by this relation, e.g. IMPLIED_BY_THIS, 
   * IMPLIED_BY_THIS_IMMEDIATE, THAT_IMPLY_THIS, THAT_IMPLY_THIS_IMMEDIATE
   * @return the wsInheritanceSetRelation
   */
  public String getWsInheritanceSetRelation() {</pre></div></td></tr></table>
<table border="0" class="bodyTable">
<tr class="b">
<th>File</th>
<th>Line</th></tr>
<tr class="a">
<td>edu\internet2\middleware\grouperClient\config\ConfigPropertiesCascadeCommonUtils.java</td>
<td><a href="./xref/edu/internet2/middleware/grouperClient/config/ConfigPropertiesCascadeCommonUtils.html#L5723">5723</a></td></tr>
<tr class="b">
<td>edu\internet2\middleware\grouperClient\util\GcElUtilsSafe.java</td>
<td><a href="./xref/edu/internet2/middleware/grouperClient/util/GcElUtilsSafe.html#L3448">3448</a></td></tr>
<tr class="a">
<td>edu\internet2\middleware\grouperClient\util\GrouperClientCommonUtils.java</td>
<td><a href="./xref/edu/internet2/middleware/grouperClient/util/GrouperClientCommonUtils.html#L5800">5800</a></td></tr>
<tr class="b"><td colspan='2'>
<div>
<pre>  }

  /**
   * find the length of ascii chars (non ascii are counted as two)
   * @param input is the string to operate on
   * @param requiredLength length we need the string to be
   * @return the length of ascii chars
   */
  public static String truncateAscii(String input, int requiredLength) {
    if (input == null) {
      return input;
    }
    //see what real length is
    int utfLength = input.length();
    
    //see if not worth checking
    if (utfLength * 2 &lt; requiredLength) {
      return input;
    }
    
    //count how many non asciis
    int asciiLength = 0;
    for (int i=0;i&lt;utfLength;i++) {
      
      asciiLength++;
      
      //keep count of non ascii chars
      if (!isAscii(input.charAt(i))) {
        asciiLength++;
      }
      
      //see if we are over 
      if (asciiLength &gt; requiredLength) {
        //do not include the current char
        return input.substring(0,i);
      }
    }
    //must have fit
    return input;
  }
  
  /**
   * if the input is a file, read string from file.  if not, or if disabled from grouper.properties, return the input
   * @param in
   * @param disableExternalFileLookup 
   * @return the result
   */
  public static String readFromFileIfFile(String in, boolean disableExternalFileLookup) {</pre></div></td></tr></table>
<table border="0" class="bodyTable">
<tr class="a">
<th>File</th>
<th>Line</th></tr>
<tr class="b">
<td>edu\internet2\middleware\grouperClient\ws\beans\WsAddMemberResults.java</td>
<td><a href="./xref/edu/internet2/middleware/grouperClient/ws/beans/WsAddMemberResults.html#L76">76</a></td></tr>
<tr class="a">
<td>edu\internet2\middleware\grouperClient\ws\beans\WsGetGroupsResults.java</td>
<td><a href="./xref/edu/internet2/middleware/grouperClient/ws/beans/WsGetGroupsResults.html#L55">55</a></td></tr>
<tr class="b">
<td>edu\internet2\middleware\grouperClient\ws\beans\WsMemberChangeSubjectResults.java</td>
<td><a href="./xref/edu/internet2/middleware/grouperClient/ws/beans/WsMemberChangeSubjectResults.html#L53">53</a></td></tr>
<tr class="a"><td colspan='2'>
<div>
<pre>  }

  /**
   * metadata about the result
   */
  private WsResultMeta resultMetadata = new WsResultMeta();

  /**
   * attributes of subjects returned, in same order as the data
   */
  private String[] subjectAttributeNames;

  /**
   * @return the resultMetadata
   */
  public WsResultMeta getResultMetadata() {
    return this.resultMetadata;
  }

  /**
   * attributes of subjects returned, in same order as the data
   * @return the attributeNames
   */
  public String[] getSubjectAttributeNames() {
    return this.subjectAttributeNames;
  }

  /**
   * attributes of subjects returned, in same order as the data
   * @param attributeNamesa the attributeNames to set
   */
  public void setSubjectAttributeNames(String[] attributeNamesa) {
    this.subjectAttributeNames = attributeNamesa;
  }

  /**
   * metadata about the result
   */
  private WsResponseMeta responseMetadata = new WsResponseMeta();

  /**
   * @return the response metadata
   */
  public WsResponseMeta getResponseMetadata() {
    return this.responseMetadata;
  }

  
  /**
   * @param resultMetadata1 the resultMetadata to set
   */
  public void setResultMetadata(WsResultMeta resultMetadata1) {
    this.resultMetadata = resultMetadata1;
  }

  
  /**
   * @param responseMetadata1 the responseMetadata to set
   */
  public void setResponseMetadata(WsResponseMeta responseMetadata1) {
    this.responseMetadata = responseMetadata1;
  }

}</pre></div></td></tr></table>
<table border="0" class="bodyTable">
<tr class="b">
<th>File</th>
<th>Line</th></tr>
<tr class="a">
<td>edu\internet2\middleware\grouperClient\ws\beans\WsAttributeDefName.java</td>
<td><a href="./xref/edu/internet2/middleware/grouperClient/ws/beans/WsAttributeDefName.html#L114">114</a></td></tr>
<tr class="b">
<td>edu\internet2\middleware\grouperClient\ws\beans\WsGroup.java</td>
<td><a href="./xref/edu/internet2/middleware/grouperClient/ws/beans/WsGroup.html#L106">106</a></td></tr>
<tr class="a"><td colspan='2'>
<div>
<pre>  }

  /**
   * friendly description of this attributeDefName
   * @return the description
   */
  public String getDescription() {
    return this.description;
  }

  /**
   * friendly extensions of attributeDefName and parent stems
   * @return the displayName
   */
  public String getDisplayName() {
    return this.displayName;
  }

  /**
   * Full name of the attributeDefName (all extensions of parent stems, separated by colons, 
   * and the extention of this attributeDefName
   * @return the name
   */
  public String getName() {
    return this.name;
  }

  /**
   * universally unique identifier of this attributeDefName
   * @return the uuid
   */
  public String getUuid() {
    return this.uuid;
  }

  /**
   * friendly description of this attributeDefName
   * @param description1 the description to set
   */
  public void setDescription(String description1) {
    this.description = description1;
  }

  /**
   * friendly extensions of attributeDefName and parent stems
   * @param displayName1 the displayName to set
   */
  public void setDisplayName(String displayName1) {
    this.displayName = displayName1;
  }

  /**
   * Full name of the attributeDefName (all extensions of parent stems, separated by colons, 
   * and the extention of this attributeDefName
   * @param name1 the name to set
   */
  public void setName(String name1) {
    this.name = name1;
  }

  /**
   * universally unique identifier of this attributeDefName
   * @param uuid1 the uuid to set
   */
  public void setUuid(String uuid1) {
    this.uuid = uuid1;
  }

  /**
   * extension of attributeDefName, the part to the right of last colon in name
   * @return the extension
   */
  public String getExtension() {</pre></div></td></tr></table>
<table border="0" class="bodyTable">
<tr class="b">
<th>File</th>
<th>Line</th></tr>
<tr class="a">
<td>edu\internet2\middleware\grouperClient\ws\beans\WsGetAttributeAssignmentsResults.java</td>
<td><a href="./xref/edu/internet2/middleware/grouperClient/ws/beans/WsGetAttributeAssignmentsResults.html#L74">74</a></td></tr>
<tr class="b">
<td>edu\internet2\middleware\grouperClient\ws\beans\WsGetPermissionAssignmentsResults.java</td>
<td><a href="./xref/edu/internet2/middleware/grouperClient/ws/beans/WsGetPermissionAssignmentsResults.html#L96">96</a></td></tr>
<tr class="a"><td colspan='2'>
<div>
<pre>  }

  /**
   * the assignments being queried
   */
  private WsAttributeAssign[] wsAttributeAssigns;
  
  /**
   * the assignments being queried
   * @return the assignments being queried
   */
  public WsAttributeAssign[] getWsAttributeAssigns() {
    return this.wsAttributeAssigns;
  }

  /**
   * the assignments being queried
   * @param wsAttributeAssigns1
   */
  public void setWsAttributeAssigns(WsAttributeAssign[] wsAttributeAssigns1) {
    this.wsAttributeAssigns = wsAttributeAssigns1;
  }

  /**
   * attributes of subjects returned, in same order as the data
   */
  private String[] subjectAttributeNames;

  /**
   * attributes of subjects returned, in same order as the data
   * @return the attributeNames
   */
  public String[] getSubjectAttributeNames() {
    return this.subjectAttributeNames;
  }

  /**
   * attributes of subjects returned, in same order as the data
   * @param attributeNamesa the attributeNames to set
   */
  public void setSubjectAttributeNames(String[] attributeNamesa) {
    this.subjectAttributeNames = attributeNamesa;
  }

  /**
   * metadata about the result
   */
  private WsResultMeta resultMetadata = new WsResultMeta();

  /**
   * @return the resultMetadata
   */
  public WsResultMeta getResultMetadata() {
    return this.resultMetadata;
  }

  /**
   * metadata about the result
   */
  private WsResponseMeta responseMetadata = new WsResponseMeta();

  /**
   * groups that are in the results
   */
  private WsGroup[] wsGroups;

  /**
   * stems that are in the results
   */
  private WsStem[] wsStems;</pre></div></td></tr></table>
<table border="0" class="bodyTable">
<tr class="b">
<th>File</th>
<th>Line</th></tr>
<tr class="a">
<td>edu\internet2\middleware\grouperClient\ws\beans\WsQueryFilter.java</td>
<td><a href="./xref/edu/internet2/middleware/grouperClient/ws/beans/WsQueryFilter.html#L308">308</a></td></tr>
<tr class="b">
<td>edu\internet2\middleware\grouperClient\ws\beans\WsStemQueryFilter.java</td>
<td><a href="./xref/edu/internet2/middleware/grouperClient/ws/beans/WsStemQueryFilter.html#L267">267</a></td></tr>
<tr class="a"><td colspan='2'>
<div>
<pre>  }

  /**
   * true or null for ascending, false for descending.  If you pass true or false, must pass a sort string
   * @return the ascending
   */
  public String getAscending() {
    return this.ascending;
  }

  /**
   * page number 1 indexed if paging
   * @return the pageNumber
   */
  public String getPageNumber() {
    return this.pageNumber;
  }

  /**
   * page size if paging
   * @return the pageSize
   */
  public String getPageSize() {
    return this.pageSize;
  }

  /**
   * must be an hql query field, e.g. can sort on name, displayName, extension, displayExtension
   * @return the sortString
   */
  public String getSortString() {
    return this.sortString;
  }

  /**
   * true or null for ascending, false for descending.  If you pass true or false, must pass a sort string
   * @param ascending1 the ascending to set
   */
  public void setAscending(String ascending1) {
    this.ascending = ascending1;
  }

  /**
   * page number 1 indexed if paging
   * @param pageNumber1 the pageNumber to set
   */
  public void setPageNumber(String pageNumber1) {
    this.pageNumber = pageNumber1;
  }

  /**
   * page size if paging
   * @param pageSize1 the pageSize to set
   */
  public void setPageSize(String pageSize1) {
    this.pageSize = pageSize1;
  }

  /**
   * must be an hql query field, e.g. can sort on name, displayName, extension, displayExtension
   * @param sortString1 the sortString to set
   */
  public void setSortString(String sortString1) {
    this.sortString = sortString1;
  }

}</pre></div></td></tr></table>
<table border="0" class="bodyTable">
<tr class="b">
<th>File</th>
<th>Line</th></tr>
<tr class="a">
<td>edu\internet2\middleware\grouperClient\ws\beans\WsRestAssignGrouperPrivilegesLiteRequest.java</td>
<td><a href="./xref/edu/internet2/middleware/grouperClient/ws/beans/WsRestAssignGrouperPrivilegesLiteRequest.html#L418">418</a></td></tr>
<tr class="b">
<td>edu\internet2\middleware\grouperClient\ws\beans\WsRestAssignPermissionsLiteRequest.java</td>
<td><a href="./xref/edu/internet2/middleware/grouperClient/ws/beans/WsRestAssignPermissionsLiteRequest.html#L538">538</a></td></tr>
<tr class="a">
<td>edu\internet2\middleware\grouperClient\ws\beans\WsRestGetSubjectsLiteRequest.java</td>
<td><a href="./xref/edu/internet2/middleware/grouperClient/ws/beans/WsRestGetSubjectsLiteRequest.html#L280">280</a></td></tr>
<tr class="b"><td colspan='2'>
<div>
<pre>  public String getParamName0() {
    return this.paramName0;
  }

  /**
   * reserved for future use
   * @param _paramName0
   */
  public void setParamName0(String _paramName0) {
    this.paramName0 = _paramName0;
  }

  /**
   * reserved for future use
   * @return param
   */
  public String getParamValue0() {
    return this.paramValue0;
  }

  /**
   * reserved for future use
   * @param _paramValue0
   */
  public void setParamValue0(String _paramValue0) {
    this.paramValue0 = _paramValue0;
  }

  /**
   * reserved for future use
   * @return param
   */
  public String getParamName1() {
    return this.paramName1;
  }

  /**
   * reserved for future use
   * @param _paramName1
   */
  public void setParamName1(String _paramName1) {
    this.paramName1 = _paramName1;
  }

  /**
   * reserved for future use
   * @return param
   */
  public String getParamValue1() {
    return this.paramValue1;
  }

  /**
   * reserved for future use
   * @param _paramValue1
   */
  public void setParamValue1(String _paramValue1) {
    this.paramValue1 = _paramValue1;
  }

  /**
   * T or F as to whether this privilege is being assigned or removed
   * @return is allowed
   */
  public String getAllowed() {</pre></div></td></tr></table>
<table border="0" class="bodyTable">
<tr class="a">
<th>File</th>
<th>Line</th></tr>
<tr class="b">
<td>edu\internet2\middleware\grouperClient\ws\beans\WsRestFindAttributeDefNamesRequest.java</td>
<td><a href="./xref/edu/internet2/middleware/grouperClient/ws/beans/WsRestFindAttributeDefNamesRequest.html#L153">153</a></td></tr>
<tr class="a">
<td>edu\internet2\middleware\grouperClient\ws\beans\WsRestGetGroupsRequest.java</td>
<td><a href="./xref/edu/internet2/middleware/grouperClient/ws/beans/WsRestGetGroupsRequest.html#L191">191</a></td></tr>
<tr class="b">
<td>edu\internet2\middleware\grouperClient\ws\beans\WsRestGetMembersRequest.java</td>
<td><a href="./xref/edu/internet2/middleware/grouperClient/ws/beans/WsRestGetMembersRequest.html#L103">103</a></td></tr>
<tr class="a"><td colspan='2'>
<div>
<pre>  public String getPageSize() {
    return this.pageSize;
  }

  
  /**
   * page size if paging on a sort filter or parent
   * @param pageSize1 the pageSize to set
   */
  public void setPageSize(String pageSize1) {
    this.pageSize = pageSize1;
  }

  
  /**
   * page number 1 indexed if paging on a sort filter or parent
   * @return the pageNumber
   */
  public String getPageNumber() {
    return this.pageNumber;
  }

  
  /**
   * page number 1 indexed if paging on a sort filter or parent
   * @param pageNumber1 the pageNumber to set
   */
  public void setPageNumber(String pageNumber1) {
    this.pageNumber = pageNumber1;
  }

  
  /**
   * must be an hql query field, e.g. 
   * can sort on name, displayName, extension, displayExtension
   * @return the sortString
   */
  public String getSortString() {
    return this.sortString;
  }

  
  /**
   * must be an hql query field, e.g. 
   * can sort on name, displayName, extension, displayExtension
   * @param sortString1 the sortString to set
   */
  public void setSortString(String sortString1) {
    this.sortString = sortString1;
  }

  
  /**
   * ascending or null for ascending, F for descending.  
   * @return the ascending
   */
  public String getAscending() {
    return this.ascending;
  }

  
  /**
   * ascending or null for ascending, F for descending.  
   * @param ascending1 the ascending to set
   */
  public void setAscending(String ascending1) {
    this.ascending = ascending1;
  }

  
  /**
   * wsInheritanceSetRelation if there is one wsAttributeDefNameLookup, and this is specified, then find 
   * the attribute def names which are related to the lookup by this relation, e.g. IMPLIED_BY_THIS, 
   * IMPLIED_BY_THIS_IMMEDIATE, THAT_IMPLY_THIS, THAT_IMPLY_THIS_IMMEDIATE
   * @return the wsInheritanceSetRelation
   */
  public String getWsInheritanceSetRelation() {</pre></div></td></tr></table>
<table border="0" class="bodyTable">
<tr class="b">
<th>File</th>
<th>Line</th></tr>
<tr class="a">
<td>edu\internet2\middleware\grouperClient\api\GcAssignAttributes.java</td>
<td><a href="./xref/edu/internet2/middleware/grouperClient/api/GcAssignAttributes.html#L394">394</a></td></tr>
<tr class="b">
<td>edu\internet2\middleware\grouperClient\api\GcGetAttributeAssignments.java</td>
<td><a href="./xref/edu/internet2/middleware/grouperClient/api/GcGetAttributeAssignments.html#L585">585</a></td></tr>
<tr class="a"><td colspan='2'>
<div>
<pre>      }

      //########### GROUPS
      List&lt;WsGroupLookup&gt; ownerGroupLookups = new ArrayList&lt;WsGroupLookup&gt;();
      //add names and/or uuids
      for (String ownerGroupName : this.ownerGroupNames) {
        ownerGroupLookups.add(new WsGroupLookup(ownerGroupName, null));
      }
      for (String ownerGroupUuid : this.ownerGroupUuids) {
        ownerGroupLookups.add(new WsGroupLookup(null, ownerGroupUuid));
      }
      for (Long ownerGroupIdIndex : this.ownerGroupIdIndexes) {
        ownerGroupLookups.add(new WsGroupLookup(null, null, ownerGroupIdIndex.toString()));
      }
      if (GrouperClientUtils.length(ownerGroupLookups) &gt; 0) {</pre></div></td></tr></table>
<table border="0" class="bodyTable">
<tr class="b">
<th>File</th>
<th>Line</th></tr>
<tr class="a">
<td>edu\internet2\middleware\grouperClient\ws\beans\WsAddMemberResults.java</td>
<td><a href="./xref/edu/internet2/middleware/grouperClient/ws/beans/WsAddMemberResults.html#L76">76</a></td></tr>
<tr class="b">
<td>edu\internet2\middleware\grouperClient\ws\beans\WsAssignGrouperPrivilegesLiteResult.java</td>
<td><a href="./xref/edu/internet2/middleware/grouperClient/ws/beans/WsAssignGrouperPrivilegesLiteResult.html#L33">33</a></td></tr>
<tr class="a">
<td>edu\internet2\middleware\grouperClient\ws\beans\WsAssignGrouperPrivilegesResults.java</td>
<td><a href="./xref/edu/internet2/middleware/grouperClient/ws/beans/WsAssignGrouperPrivilegesResults.html#L33">33</a></td></tr>
<tr class="b">
<td>edu\internet2\middleware\grouperClient\ws\beans\WsGetGroupsResults.java</td>
<td><a href="./xref/edu/internet2/middleware/grouperClient/ws/beans/WsGetGroupsResults.html#L55">55</a></td></tr>
<tr class="a">
<td>edu\internet2\middleware\grouperClient\ws\beans\WsMemberChangeSubjectResults.java</td>
<td><a href="./xref/edu/internet2/middleware/grouperClient/ws/beans/WsMemberChangeSubjectResults.html#L53">53</a></td></tr>
<tr class="b"><td colspan='2'>
<div>
<pre>  }

  /**
   * metadata about the result
   */
  private WsResultMeta resultMetadata = new WsResultMeta();

  /**
   * attributes of subjects returned, in same order as the data
   */
  private String[] subjectAttributeNames;

  /**
   * @return the resultMetadata
   */
  public WsResultMeta getResultMetadata() {
    return this.resultMetadata;
  }

  /**
   * attributes of subjects returned, in same order as the data
   * @return the attributeNames
   */
  public String[] getSubjectAttributeNames() {
    return this.subjectAttributeNames;
  }

  /**
   * attributes of subjects returned, in same order as the data
   * @param attributeNamesa the attributeNames to set
   */
  public void setSubjectAttributeNames(String[] attributeNamesa) {
    this.subjectAttributeNames = attributeNamesa;
  }

  /**
   * metadata about the result
   */
  private WsResponseMeta responseMetadata = new WsResponseMeta();

  /**
   * @return the response metadata
   */
  public WsResponseMeta getResponseMetadata() {
    return this.responseMetadata;
  }

  
  /**
   * @param resultMetadata1 the resultMetadata to set
   */
  public void setResultMetadata(WsResultMeta resultMetadata1) {
    this.resultMetadata = resultMetadata1;
  }

  
  /**
   * @param responseMetadata1 the responseMetadata to set
   */
  public void setResponseMetadata(WsResponseMeta responseMetadata1) {
    this.responseMetadata = responseMetadata1;
  }</pre></div></td></tr></table>
<table border="0" class="bodyTable">
<tr class="a">
<th>File</th>
<th>Line</th></tr>
<tr class="b">
<td>edu\internet2\middleware\grouperClient\ws\beans\WsRestAssignAttributesLiteRequest.java</td>
<td><a href="./xref/edu/internet2/middleware/grouperClient/ws/beans/WsRestAssignAttributesLiteRequest.html#L808">808</a></td></tr>
<tr class="a">
<td>edu\internet2\middleware\grouperClient\ws\beans\WsRestGetGrouperPrivilegesLiteRequest.java</td>
<td><a href="./xref/edu/internet2/middleware/grouperClient/ws/beans/WsRestGetGrouperPrivilegesLiteRequest.html#L413">413</a></td></tr>
<tr class="b"><td colspan='2'>
<div>
<pre>  public String getParamName0() {
    return this.paramName0;
  }

  /**
   * reserved for future use
   * @param _paramName0
   */
  public void setParamName0(String _paramName0) {
    this.paramName0 = _paramName0;
  }

  /**
   * reserved for future use
   * @return param value 0
   */
  public String getParamValue0() {
    return this.paramValue0;
  }

  /**
   * reserved for future use
   * @param _paramValue0
   */
  public void setParamValue0(String _paramValue0) {
    this.paramValue0 = _paramValue0;
  }

  /**
   * reserved for future use
   * @return paramname1
   */
  public String getParamName1() {
    return this.paramName1;
  }

  /**
   * reserved for future use
   * @param _paramName1
   */
  public void setParamName1(String _paramName1) {
    this.paramName1 = _paramName1;
  }

  /**
   * reserved for future use
   * @return param value 1
   */
  public String getParamValue1() {
    return this.paramValue1;
  }

  /**
   * reserved for future use
   * @param _paramValue1
   */
  public void setParamValue1(String _paramValue1) {
    this.paramValue1 = _paramValue1;
  }
  
  
  
}</pre></div></td></tr></table>
<table border="0" class="bodyTable">
<tr class="a">
<th>File</th>
<th>Line</th></tr>
<tr class="b">
<td>edu\internet2\middleware\grouperClient\api\GcAssignAttributes.java</td>
<td><a href="./xref/edu/internet2/middleware/grouperClient/api/GcAssignAttributes.html#L381">381</a></td></tr>
<tr class="a">
<td>edu\internet2\middleware\grouperClient\api\GcGetAttributeAssignments.java</td>
<td><a href="./xref/edu/internet2/middleware/grouperClient/api/GcGetAttributeAssignments.html#L571">571</a></td></tr>
<tr class="b">
<td>edu\internet2\middleware\grouperClient\api\GcGetPermissionAssignments.java</td>
<td><a href="./xref/edu/internet2/middleware/grouperClient/api/GcGetPermissionAssignments.html#L464">464</a></td></tr>
<tr class="a"><td colspan='2'>
<div>
<pre>      List&lt;WsAttributeDefNameLookup&gt; attributeDefNameLookups = new ArrayList&lt;WsAttributeDefNameLookup&gt;();
      //add names and/or uuids
      for (String attributeDefNameName : this.attributeDefNameNames) {
        attributeDefNameLookups.add(new WsAttributeDefNameLookup(attributeDefNameName, null));
      }
      for (String attributeDefNameUuid : this.attributeDefNameUuids) {
        attributeDefNameLookups.add(new WsAttributeDefNameLookup(null, attributeDefNameUuid));
      }
      for (Long attributeDefNameIdIndex : this.attributeDefNameIdIndexes) {
        attributeDefNameLookups.add(new WsAttributeDefNameLookup(null, null, attributeDefNameIdIndex.toString()));
      }
      if (GrouperClientUtils.length(attributeDefNameLookups) &gt; 0) {</pre></div></td></tr></table>
<table border="0" class="bodyTable">
<tr class="b">
<th>File</th>
<th>Line</th></tr>
<tr class="a">
<td>edu\internet2\middleware\grouperClient\api\GcGetAttributeAssignments.java</td>
<td><a href="./xref/edu/internet2/middleware/grouperClient/api/GcGetAttributeAssignments.html#L553">553</a></td></tr>
<tr class="b">
<td>edu\internet2\middleware\grouperClient\api\GcGetPermissionAssignments.java</td>
<td><a href="./xref/edu/internet2/middleware/grouperClient/api/GcGetPermissionAssignments.html#L448">448</a></td></tr>
<tr class="a"><td colspan='2'>
<div>
<pre>        List&lt;WsAttributeDefLookup&gt; attributeDefLookups = new ArrayList&lt;WsAttributeDefLookup&gt;();
        //add names and/or uuids
        for (String attributeDefName : this.attributeDefNames) {
          attributeDefLookups.add(new WsAttributeDefLookup(attributeDefName, null));
        }
        for (String attributeDefUuid : this.attributeDefUuids) {
          attributeDefLookups.add(new WsAttributeDefLookup(null, attributeDefUuid));
        }
        for (Long attributeDefIdIndex : this.attributeDefIdIndexes) {
          attributeDefLookups.add(new WsAttributeDefLookup(null, null, attributeDefIdIndex.toString()));
        }
        if (GrouperClientUtils.length(attributeDefLookups) &gt; 0) {</pre></div></td></tr></table>
<table border="0" class="bodyTable">
<tr class="b">
<th>File</th>
<th>Line</th></tr>
<tr class="a">
<td>edu\internet2\middleware\grouperClient\config\ConfigPropertiesCascadeCommonUtils.java</td>
<td><a href="./xref/edu/internet2/middleware/grouperClient/config/ConfigPropertiesCascadeCommonUtils.html#L7099">7099</a></td></tr>
<tr class="b">
<td>edu\internet2\middleware\grouperClient\util\GcElUtilsSafe.java</td>
<td><a href="./xref/edu/internet2/middleware/grouperClient/util/GcElUtilsSafe.html#L5981">5981</a></td></tr>
<tr class="a">
<td>edu\internet2\middleware\grouperClient\util\GrouperClientCommonUtils.java</td>
<td><a href="./xref/edu/internet2/middleware/grouperClient/util/GrouperClientCommonUtils.html#L7176">7176</a></td></tr>
<tr class="b"><td colspan='2'>
<div>
<pre>  }

  /**
   * &lt;p&gt;Finds a &lt;code&gt;Throwable&lt;/code&gt; by field name.&lt;/p&gt;
   * 
   * @param throwable  the exception to examine
   * @param fieldName  the name of the attribute to examine
   * @return the wrapped exception, or &lt;code&gt;null&lt;/code&gt; if not found
   */
  private static Throwable getCauseUsingFieldName(Throwable throwable, String fieldName) {
      Field field = null;
      try {
          field = throwable.getClass().getField(fieldName);
      } catch (NoSuchFieldException ignored) {
      } catch (SecurityException ignored) {
      }

      if (field != null &amp;&amp; Throwable.class.isAssignableFrom(field.getType())) {
          try {
              return (Throwable) field.get(throwable);
          } catch (IllegalAccessException ignored) {
          } catch (IllegalArgumentException ignored) {
          }
      }
      return null;
  }

  /**
   * &lt;p&gt;Finds a &lt;code&gt;Throwable&lt;/code&gt; for known types.&lt;/p&gt;
   * 
   * &lt;p&gt;Uses &lt;code&gt;instanceof&lt;/code&gt; checks to examine the exception,
   * looking for well known types which could contain chained or
   * wrapped exceptions.&lt;/p&gt;
   *
   * @param throwable  the exception to examine
   * @return the wrapped exception, or &lt;code&gt;null&lt;/code&gt; if not found
   */
  private static Throwable getCauseUsingWellKnownTypes(Throwable throwable) {</pre></div></td></tr></table>
<table border="0" class="bodyTable">
<tr class="a">
<th>File</th>
<th>Line</th></tr>
<tr class="b">
<td>edu\internet2\middleware\grouperClient\ws\beans\WsRestAssignAttributesLiteRequest.java</td>
<td><a href="./xref/edu/internet2/middleware/grouperClient/ws/beans/WsRestAssignAttributesLiteRequest.html#L808">808</a></td></tr>
<tr class="a">
<td>edu\internet2\middleware\grouperClient\ws\beans\WsRestAssignGrouperPrivilegesLiteRequest.java</td>
<td><a href="./xref/edu/internet2/middleware/grouperClient/ws/beans/WsRestAssignGrouperPrivilegesLiteRequest.html#L418">418</a></td></tr>
<tr class="b">
<td>edu\internet2\middleware\grouperClient\ws\beans\WsRestAssignPermissionsLiteRequest.java</td>
<td><a href="./xref/edu/internet2/middleware/grouperClient/ws/beans/WsRestAssignPermissionsLiteRequest.html#L538">538</a></td></tr>
<tr class="a">
<td>edu\internet2\middleware\grouperClient\ws\beans\WsRestGetGrouperPrivilegesLiteRequest.java</td>
<td><a href="./xref/edu/internet2/middleware/grouperClient/ws/beans/WsRestGetGrouperPrivilegesLiteRequest.html#L413">413</a></td></tr>
<tr class="b">
<td>edu\internet2\middleware\grouperClient\ws\beans\WsRestGetPermissionAssignmentsLiteRequest.java</td>
<td><a href="./xref/edu/internet2/middleware/grouperClient/ws/beans/WsRestGetPermissionAssignmentsLiteRequest.html#L727">727</a></td></tr>
<tr class="a">
<td>edu\internet2\middleware\grouperClient\ws\beans\WsRestGetSubjectsLiteRequest.java</td>
<td><a href="./xref/edu/internet2/middleware/grouperClient/ws/beans/WsRestGetSubjectsLiteRequest.html#L280">280</a></td></tr>
<tr class="b"><td colspan='2'>
<div>
<pre>  public String getParamName0() {
    return this.paramName0;
  }

  /**
   * reserved for future use
   * @param _paramName0
   */
  public void setParamName0(String _paramName0) {
    this.paramName0 = _paramName0;
  }

  /**
   * reserved for future use
   * @return param value 0
   */
  public String getParamValue0() {
    return this.paramValue0;
  }

  /**
   * reserved for future use
   * @param _paramValue0
   */
  public void setParamValue0(String _paramValue0) {
    this.paramValue0 = _paramValue0;
  }

  /**
   * reserved for future use
   * @return paramname1
   */
  public String getParamName1() {
    return this.paramName1;
  }

  /**
   * reserved for future use
   * @param _paramName1
   */
  public void setParamName1(String _paramName1) {
    this.paramName1 = _paramName1;
  }

  /**
   * reserved for future use
   * @return param value 1
   */
  public String getParamValue1() {
    return this.paramValue1;
  }

  /**
   * reserved for future use
   * @param _paramValue1
   */
  public void setParamValue1(String _paramValue1) {
    this.paramValue1 = _paramValue1;
  }</pre></div></td></tr></table></div>
      </div>
    </div>
    <div class="clear">
      <hr/>
    </div>
    <div id="footer">
      <div class="xright">
              Copyright &#169;                    2014
                        <a href="http://www.internet2.edu/">Internet2</a>.
            All Rights Reserved.      
                    
                  </div>
      <div class="clear">
        <hr/>
      </div>
    </div>
  </body>
</html>
